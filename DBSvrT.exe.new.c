/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

void __thiscall CConfig::CConfig(CConfig *this);
void __thiscall CConfig::~CConfig(CConfig *this);
void __thiscall CConfig::Close(CConfig *this);
void __cdecl free_var(lisp::var v);
Token __thiscall CConfig::GetToken(CConfig *this);
lisp::var *__thiscall CConfig::Find(CConfig *this, lisp::var *result, const char *key);
lisp::var *__thiscall CConfig::GetValue(CConfig *this, lisp::var *result);
char *__cdecl Strdup(const char *str);
lisp::var *__thiscall CConfig::GetList(CConfig *this, lisp::var *result);
int __thiscall CConfig::Open(CConfig *this, const char *szFilename);
const char *__thiscall CConfig::Get(CConfig *this, const char *key);
const char *__thiscall CConfig::Get(CConfig *this, const char *key, const char *defaultValue);
int __thiscall CConfig::GetInt(CConfig *this, const char *key, int defaultValue);
unsigned int __cdecl CConfig::GetTimeStamp();
_DWORD *__thiscall lisp::var::var(_DWORD *this);
// _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD); weak
int __thiscall lisp::var::stringp(lisp::var *this);
int __thiscall lisp::var::integerp(lisp::var *this);
int __thiscall lisp::var::consp(lisp::var *this);
lisp::var *__thiscall lisp::var::car(lisp::var *this);
lisp::var *__thiscall lisp::var::cdr(lisp::var *this);
int __thiscall lisp::var::operator char const *(_DWORD *this);
int __thiscall lisp::var::null(lisp::var *this);
_DWORD *__thiscall lisp::_string::_string(_DWORD *this, int a2);
const char *__thiscall lisp::_object::GetString(lisp::_object *this);
_DWORD *__thiscall sub_4020E0(_DWORD *this);
void *sub_402100();
_DWORD *__thiscall lisp::_integer::_integer(_DWORD *this, int a2);
_DWORD *__thiscall lisp::_cons::_cons(_DWORD *this, int a2, char a3);
int __thiscall lisp::var::operator int(_DWORD *this);
CMemory **__cdecl operator new(size_t Size);
void __cdecl operator delete(int a1);
int __stdcall DialogProc(HWND__ *hwndDlg, unsigned int uMsg, unsigned int wParam, int lParam);
int __cdecl CDB::Open(const char *szServer);
void __stdcall CDB::Close();
CDB *__thiscall CDB::CDB(CDB *this);
void __thiscall CDB::~CDB(CDB *this);
int CDB::Execute(CDB *this, const char *format, ...);
__int16 CDB::ExecuteInsertUnique(CDB *this, const char *format, ...);
int CDB::ExecuteNoData(CDB *this, const char *format, ...);
int __thiscall CDB::Fetch(CDB *this);
void __thiscall CDB::Reset(CDB *this);
CDBConnect *__cdecl CDBConnect::Alloc();
LONG __thiscall CDBConnect::Free(_DWORD *this);
void __thiscall CDBConnect::CDBConnect(CDBConnect *this);
void __thiscall CDBConnect::~CDBConnect(CDBConnect *this);
void __thiscall CIOSpinLock::Enter(volatile LONG *this);
LONG __thiscall CIOSpinLock::Leave(volatile LONG *this);
SQLHANDLE *__thiscall CDBConnect::`scalar deleting destructor'(SQLHANDLE *this, char a2);
// int __thiscall unknown_libname_7(_DWORD); weak
int __cdecl CDBConfig::Open();
_DWORD *CDBConfig::Close();
// _DWORD __stdcall unknown_libname_8(_DWORD, _DWORD); weak
int __thiscall lisp::var::pop(int *this, int a2);
int __thiscall lisp::var::length(lisp::var *this);
void *__thiscall std::string::operator=(void *this, char *Str);
_DWORD *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::clear(_DWORD *this);
_DWORD *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::find(int *this, _DWORD *a1, int a2);
int *__thiscall std::vector<IPAddrMask>::reserve(_DWORD *this, unsigned int a2);
void *__thiscall std::vector<IPAddrMask>::push_back(void **this, int a2);
int __thiscall sub_4038C0(void *this);
void *__thiscall std::string::assign(void *this, char *Str);
// int __cdecl std::char_traits<char>::length(char *Str); idb
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Key(int a1);
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::lower_bound(_DWORD *this, int a1, int a2);
int __stdcall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Erase(void *); // idb
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lmost(_DWORD *this);
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rmost(_DWORD *this);
BOOL __stdcall std::less<int>::operator()(_DWORD *a1, _DWORD *a2);
int __thiscall std::vector<IPAddrMask>::capacity(_DWORD *this);
int __thiscall std::vector<CIOSocket::CIOTimer>::end(_DWORD *this, int a2);
int __thiscall std::vector<IPAddrMask>::size(_DWORD *this);
int __thiscall sub_403B00(void *this);
int __thiscall std::vector<IPAddrMask>::insert(_DWORD *this, int a2, int a3, int a4);
int __thiscall std::vector<IPAddrMask>::_Destroy(void *this, int a2, int a3);
int __thiscall sub_403BD0(void *this, void *a2, int a3, int a4);
void __noreturn std::vector<IPAddrMask>::_Xlen();
void __thiscall std::length_error::length_error(std::length_error *this, const std::length_error *that);
void __thiscall std::logic_error::logic_error(std::logic_error *this, const std::logic_error *that);
int __thiscall sub_403CF0(char *this);
void *__thiscall std::logic_error::`vector deleting destructor'(void *this, char a2);
void __thiscall std::logic_error::~logic_error(std::logic_error *this);
void __thiscall std::length_error::~length_error(std::length_error *this);
_DWORD *__thiscall std::length_error::`vector deleting destructor'(_DWORD *this, char a2);
void __stdcall std::allocator<CSyncPacket::CElement>::deallocate(int a1, int a2);
CMemory **__stdcall sub_403E10(int a1);
void *__thiscall sub_403E30(void *this, int a2);
int __thiscall sub_403E50(void *this);
_DWORD *__thiscall std::length_error::length_error(_DWORD *this, struct exception *a2);
exception *__thiscall std::logic_error::logic_error(exception *this, struct exception *a2);
_DWORD *__thiscall std::string::string(void *this, char *Str);
// int __thiscall unknown_libname_9(_DWORD); weak
void *__thiscall std::string::assign(void *this, void *Src, size_t Size);
// int __cdecl std::char_traits<char>::copy(void *, void *Src, size_t Size); idb
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(int a1);
// _DWORD __cdecl unknown_libname_10(_DWORD); weak
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(int a1);
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(int a1);
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Myval(int a1);
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lbound(_DWORD *this, _DWORD *a2);
void *__thiscall std::string::string(void *this, int a2);
void __stdcall std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node>::destroy(void *a1);
int __thiscall std::string::~string(_DWORD *this);
int __thiscall std::string::c_str(void *this);
int *__thiscall std::vector<IPAddrMask>::_Insert_n(int *this, int a2, unsigned int a3, int *a4);
std::_String_base *__thiscall std::string::assign(std::_String_base *this, std::_String_base *a2, unsigned int a3, size_t a4);
int __thiscall std::string::_Tidy(_DWORD *this, char a2, size_t Size);
// int __thiscall unknown_libname_11(_DWORD); weak
std::_String_base *__thiscall std::string::erase(std::_String_base *this, unsigned int a2, unsigned int a3);
void *__cdecl sub_4046C0(void *a1, void *Src, size_t Size);
// int __thiscall unknown_libname_12(_DWORD); weak
int __thiscall std::string::_Eos(_DWORD *this, int a2);
// _DWORD __cdecl std::char_traits<char>::assign(_DWORD, _DWORD); weak
int std::allocator<IPAddrMask>::max_size();
BOOL __thiscall std::string::_Grow(size_t *this, unsigned int a2, char a3);
// _DWORD __stdcall unknown_libname_13(_DWORD); weak
int __thiscall sub_404840(int *this);
_DWORD *__stdcall std::vector<IPAddrMask>::iterator::operator+(_DWORD *a1, int a2);
int __thiscall std::vector<IPAddrMask>::iterator::operator-(int *this, int a1);
// int __thiscall unknown_libname_24(_DWORD); weak
bool __thiscall std::string::_Inside(_DWORD *this, unsigned int a2);
int __thiscall std::string::_Copy(_DWORD *this, int a2, size_t Size);
CMemory **__stdcall std::allocator<char>::allocate(size_t Size);
CMemory **__cdecl sub_404AF0(size_t Size);
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(int *this);
// _DWORD __stdcall unknown_libname_14(_DWORD); weak
int __thiscall std::vector<IPAddrMask>::const_iterator::operator-(_DWORD *this, _DWORD *a2);
void *__thiscall std::vector<IPAddrMask>::_Ucopy<std::vector<IPAddrMask>::iterator>(void *this, int a2, int a3, void *a4);
int __cdecl std::_Destroy_range<IPAddrMask>(int a1, int a2);
void *__cdecl std::_Uninitialized_fill_n<IPAddrMask *,unsigned int,IPAddrMask,std::allocator<IPAddrMask>>(void *a1, int a2, int a3);
CMemory **__cdecl sub_404C20(int a1);
// void __cdecl __ExceptionPtrDestroy(void *); idb
void *__thiscall std::vector<IPAddrMask>::_Ucopy<IPAddrMask *>(void *this, int a2, int a3, void *a4);
_DWORD *__cdecl std::fill<IPAddrMask *,IPAddrMask>(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl std::copy_backward<IPAddrMask *,IPAddrMask *>(int a1, int a2, int a3);
void *__thiscall std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node::`scalar deleting destructor'(void *this, char a2);
int __thiscall std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node::~_Node(char *this);
int __thiscall std::pair<int const,std::string>::~pair<int const,std::string>(_DWORD *this);
void *__cdecl std::_Uninitialized_copy<std::vector<IPAddrMask>::iterator,IPAddrMask *,std::allocator<IPAddrMask>>(int a1, int a2, void *a3);
int __cdecl std::_Destroy_range<IPAddrMask>(int a1, int a2);
void *__cdecl std::_Uninit_fill_n<IPAddrMask *,unsigned int,IPAddrMask,std::allocator<IPAddrMask>>(void *a1, int a2, int a3);
void *__cdecl std::_Uninitialized_copy<IPAddrMask *,IPAddrMask *,std::allocator<IPAddrMask>>(int a1, int a2, void *a3);
_DWORD *__cdecl std::_Copy_backward_opt<IPAddrMask *,IPAddrMask *>(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__stdcall std::allocator<IPAddrMask>::construct(void *a1, int a2);
// int __cdecl unknown_libname_15(_DWORD, _DWORD); weak
void *__cdecl std::_Uninit_copy<std::vector<IPAddrMask>::iterator,IPAddrMask *,std::allocator<IPAddrMask>>(int a1, int a2, void *a3);
void *__cdecl std::_Uninit_copy<IPAddrMask *,IPAddrMask *,std::allocator<IPAddrMask>>(int a1, int a2, void *a3);
_DWORD *__cdecl std::_Construct<IPAddrMask,IPAddrMask>(void *a1, int a2);
// void *__cdecl operator new(unsigned int, void *); idb
// int __thiscall unknown_libname_16(_DWORD); weak
// int __thiscall unknown_libname_17(_DWORD); weak
// _DWORD __stdcall unknown_libname_18(_DWORD); weak
_DWORD *__thiscall sub_405130(_DWORD *this);
_DWORD *__thiscall sub_405160(void *this);
char __thiscall sub_405190(_DWORD *this, unsigned int a2);
void *__thiscall sub_405210(void *this);
void *__thiscall sub_405240(void *this, int a2, int a3);
int *__thiscall sub_405280(int *this);
void *__thiscall sub_4052F0(void *this, int a2, char a3);
CMemory **__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Buynode(void *this);
void __stdcall std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::destroy(int a1);
void *__thiscall sub_4054C0(void *this, int a2, char a3);
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(int a1);
void *__thiscall sub_405510(void *this, _BYTE *a2, char a3);
CMemory **__stdcall std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node>::allocate(int a1);
_DWORD *__stdcall std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::construct(void *a1, int a2);
// _DWORD __stdcall unknown_libname_19(_DWORD); weak
CMemory **__cdecl sub_405590(int a1);
_DWORD *__cdecl std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *,std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>(void *a1, int a2);
int *__thiscall std::vector<IPAddrMask>::~vector<IPAddrMask>(void *this);
int *__thiscall std::vector<IPAddrMask>::_Tidy(int *this);
int __thiscall std::map<int,std::string>::~map<int,std::string>(void *this);
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::~_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>(void *this);
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Tidy(int *this);
void *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::begin(_DWORD *this, void *a2);
_DWORD *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::erase(_DWORD *this, _DWORD *a2, int a3, char a4);
_DWORD *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::erase(int *this, _DWORD *a2, int a3);
void __thiscall std::out_of_range::out_of_range(std::out_of_range *this, const std::out_of_range *that);
void __thiscall std::out_of_range::~out_of_range(std::out_of_range *this);
_DWORD *__thiscall std::out_of_range::`vector deleting destructor'(_DWORD *this, char a2);
_DWORD *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::iterator::operator++(int *this, _DWORD *a2, int a3);
exception *__thiscall std::out_of_range::out_of_range(exception *this, struct exception *a2);
int *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rrotate(int *this, int a2);
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Min(int a1);
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Max(int a1);
int *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lrotate(int *this, int a2);
void *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::iterator::operator++(void *this);
void *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::operator++(void *this);
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::_Inc(int *this);
char __cdecl std::swap<char>(char *a1, char *a2);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
ATOM __cdecl MyRegisterClass(HINSTANCE hInstance);
int __cdecl InitInstance(HINSTANCE__ *hInstance, int nCmdShow);
int __stdcall TestException();
LRESULT __stdcall WndProc(HWND__ *hWnd, unsigned int message, unsigned int wParam, int lParam);
int __stdcall About(HWND__ *hDlg, unsigned int message, unsigned int wParam, int lParam);
unsigned int __stdcall StartThread(void *formal);
unsigned int __stdcall StopThread(void *arglist);
std::_String_base *__thiscall sub_406EB0(std::_String_base *this, int a1);
std::_String_base *__thiscall sub_406ED0(std::_String_base *this, int a2, int a3, size_t Size);
void __cdecl DesMem(void *buf, int mlen, int isencrypting);
void __cdecl endes(char *inblock, char *outblock);
void __cdecl permute(char *inblock, char (*perm)[16][8], char *outblock);
void __cdecl iter(int num, char *inblock, char *outblock);
void __cdecl f(int a1, int a2, int a3);
void __cdecl perm32(char *inblock, char *outblock);
void __cdecl expand(char *right, char *bigright);
_BYTE *__cdecl sub_4078C0(char *a1, _BYTE *a2);
void __cdecl dedes(char *inblock, char *outblock);
void __cdecl DesKeyInit(char *password);
void __stdcall sinit();
int __cdecl getcomp(int k, int v);
void __cdecl kinit(char *key64bit);
int __stdcall p32init();
void __cdecl perminit(char (*perm)[16][8], char *p);
void __cdecl ExclusiveOr(char *dest, char *src);
int __cdecl DesWriteBlockEx(void *buf, int len);
int __cdecl DesReadBlockEx(void *buf, int len);
// unsigned int __usercall SnapCurrentProcessMiniDump@<eax>(DWORD a1@<eax>, DWORD a2@<edx>, DWORD a3@<ecx>, DWORD a4@<ebx>, DWORD a5@<edi>, DWORD a6@<esi>, _CONTEXT *lpContext);
void __thiscall CIOException::CInit::CInit(CIOException::CInit *this);
char *__cdecl GetFilePart(char *source);
void __cdecl __noreturn SecurityHandler();
BOOL __stdcall sendMail();
int __cdecl sendMail_0(const char *host, const char *from, const char *to, const char *body);
int __cdecl sendFile(unsigned int sock, const char *name);
// void __usercall GenerateExceptionReport(DWORD a1@<ebx>, DWORD a2@<edi>, DWORD a3@<esi>, _EXCEPTION_POINTERS *data);
BOOL hprintf(HANDLE hFile, LPCSTR a2, ...);
void __cdecl CreateMiniDump(_EXCEPTION_POINTERS *pException);
void __cdecl RecordModuleList(void *LogFile);
// int __cdecl _getdrive();
// int __cdecl RecordSystemInformation(HANDLE hFile); idb
const char *__cdecl GetExceptionDescription(unsigned int ExceptionCode);
void __cdecl PrintStack(void *LogFile, unsigned int begin, unsigned int end);
void __cdecl ImageHelpStackWalk(void *LogFile, _CONTEXT *ptrContext);
void __cdecl IntelStackWalk(void *LogFile, _CONTEXT *ptrContext);
// int __userpurge RecordExceptionInfo@<eax>(DWORD a1@<ebx>, DWORD a2@<edi>, DWORD a3@<esi>, _EXCEPTION_POINTERS *data);
void __thiscall CIOException::CInit::~CInit(CIOException::CInit *this);
void ELOG(const char *lpszFormat, ...);
void __stdcall __spoils<edx,ecx> EBREAK();
// int __usercall EBreak@<eax>(DWORD a1@<ebx>, DWORD a2@<edi>, DWORD a3@<esi>);
// int __usercall CIOException::Filter@<eax>(DWORD a1@<ebx>, DWORD a2@<edi>, DWORD a3@<esi>, _EXCEPTION_POINTERS *pExp);
void __cdecl CIOException::Open(const char *szMailServer, const char *szMailFrom, const char *szMailTo);
BOOL CIOException::Enable();
LONG CIOException::Disable();
LONG CIOException::IsEnable();
int __stdcall CIOException::SendMail();
void __cdecl CIOException::DumpStack(int nThread, void **hThread, unsigned int *nThreadId);
void __cdecl ImageHelpStackWalk_0(void *LogFile, void *hThread);
// int cleanup(void); weak
// int cleanup_0(void); weak
void __thiscall CIOSpinLock::Wait(CIOSpinLock *this);
struct _RTL_CRITICAL_SECTION *__thiscall CIOCriticalSection::CIOCriticalSection(struct _RTL_CRITICAL_SECTION *this);
void __thiscall CIOCriticalSection::~CIOCriticalSection(CIOCriticalSection *this);
void __thiscall CIOCriticalSection::Enter(CIOCriticalSection *this);
void __thiscall CIOCriticalSection::Leave(CIOCriticalSection *this);
int __thiscall sub_40ACE0(void *this);
int __cdecl CIOSocket::CreateIOThread(int nThread);
unsigned int __thiscall CIOSocket::AddIOThread(void *this);
int __cdecl CIOSocket::CloseIOThread();
void sub_40AEF0();
_DWORD *__thiscall CIOObject::~CIOObject(_DWORD *this);
void __thiscall CIOObject::AddRef(CIOObject *this, volatile int *pRef);
void __thiscall CIOObject::Release(CIOObject *this, volatile int *pRef);
int __thiscall CIOObject::RegisterWait(void *this, void *a2);
void __thiscall CIOObject::OnTimerCallback(CIOObject *this, int nId);
void __thiscall CIOObject::OnIOCallback(CIOObject *this, int bSucess, unsigned int dwTransferred, _OVERLAPPED *lpOverlapped);
int *__thiscall CIOSocket::CIOTimerInstance::OnTimerCallback(void *this, int a2);
void __thiscall CIOSocket::CIOTimerInstance::OnIOCallback(CIOSocket::CIOTimerInstance *this, int bSucess, unsigned int dwTransferred, _OVERLAPPED *lpOverlapped);
int __stdcall CIOSocket::WaitThread(int a1);
void __stdcall __noreturn CIOSocket::IOThread(void *arglist);
int CIOSocket::DumpStack();
CIOBuffer *__cdecl CIOBuffer::Alloc();
LONG __thiscall CIOBuffer::Free(_DWORD *this);
int __stdcall CIOBuffer::FreeAll();
void __thiscall CIOSocket::CIOSocket(CIOSocket *this, unsigned int s);
void __thiscall CIOSocket::~CIOSocket(CIOSocket *this);
void __thiscall CIOSocket::Close(char *this);
void __thiscall CIOSocket::OnIOCallback(CIOSocket *this, int bSuccess, unsigned int dwTransferred, _OVERLAPPED *lpOverlapped);
void __thiscall CIOSocket::OnCreate(CIOSocket *this);
void __thiscall CIOSocket::ReadCallback(CIOSocket *this, unsigned int dwTransferred);
void __thiscall CIOSocket::Read(CIOSocket *this, unsigned int dwLeft);
void __thiscall CIOSocket::WriteCallback(CIOSocket *this, unsigned int dwTransferred);
void __thiscall CIOSocket::Write(CIOSocket *this, CIOBuffer *pBuffer);
_DWORD *__thiscall sub_40BF80(_DWORD *this);
void __thiscall CIOServer::~CIOServer(CIOServer *this);
void __thiscall CIOServer::Close(CIOServer *this);
int __thiscall CIOServer::Start(CIOServer *this, int nPort);
BOOL __thiscall sub_40C1A0(HANDLE *this);
int __thiscall sub_40C1D0(_DWORD *this);
void __thiscall CIOServer::OnIOCallback(CIOServer *this, int bSuccess, unsigned int dwTransferred, _OVERLAPPED *lpOverlapped);
void __thiscall CIOSocket::Initialize(CIOSocket *this);
void __thiscall CIOObject::OnFree(CIOObject *this);
_DWORD *__thiscall CIOObject::`vector deleting destructor'(_DWORD *this, char a2);
void __thiscall CIOSocket::CIOTimer::CIOTimer(CIOSocket::CIOTimer *this, CIOObject *pObject, unsigned int dwTime, int nId);
void __thiscall CIOObject::Release(volatile LONG *this);
BOOL __thiscall CIOObject::PostObject(void *this, DWORD dwNumberOfBytesTransferred);
CIOObject *__thiscall CIOObject::CIOObject(CIOObject *this);
void __thiscall CIOObject::AddRef(volatile LONG *this);
void *__thiscall CIOSocket::`vftable'(void *this, char a2);
void __thiscall CIOBuffer::Release(CIOBuffer *this);
_DWORD *__thiscall CIOServer::`vftable'(_DWORD *this, char a2);
BOOL __thiscall sub_40C590(void *this);
int __thiscall sub_40C5B0(void *this);
int *__thiscall sub_40C5D0(int this, int a2);
int __thiscall sub_40C620(int this);
BOOL __thiscall std::vector<CIOSocket::CIOTimer>::empty(void *this);
int __thiscall sub_40C690(int *this);
int __thiscall std::vector<CIOSocket::CIOTimer>::push_back(int this, int a2);
int __thiscall std::vector<CIOSocket::CIOTimer>::pop_back(_DWORD *this);
int __thiscall std::vector<CIOSocket::CIOTimer>::capacity(_DWORD *this);
int __thiscall std::vector<CIOSocket::CIOTimer>::size(_DWORD *this);
int __thiscall std::vector<CIOSocket::CIOTimer>::insert(_DWORD *this, int a2, int a3, int a4);
int __thiscall std::vector<CIOSocket::CIOTimer>::_Destroy(void *this, int a2, int a3);
int __thiscall std::vector<CIOSocket::CIOTimer>::_Ufill(void *this, void *a2, int a3, int a4);
void *__thiscall std::vector<CIOSocket::CIOTimer>::_Insert_n(_DWORD *this, int a2, unsigned int a3, int *a4);
int __thiscall std::priority_queue<CIOSocket::CIOTimer>::empty(void *this);
void __noreturn std::vector<CIOSocket::CIOTimer>::_Xlen();
CMemory **__stdcall std::allocator<CIOSocket::CIOTimer>::allocate(int a1);
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator+(int *this, _DWORD *a1, int a2);
int __thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator-(int *this, int a1);
int std::allocator<CIOSocket::CIOTimer>::max_size();
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator+=(_DWORD *this, int a2);
int __thiscall std::vector<CIOSocket::CIOTimer>::const_iterator::operator-(_DWORD *this, _DWORD *a2);
int *__cdecl std::push_heap<std::vector<CIOSocket::CIOTimer>::iterator,std::less<CIOSocket::CIOTimer>>(int a1, int a2);
int __cdecl std::pop_heap<std::vector<CIOSocket::CIOTimer>::iterator,std::less<CIOSocket::CIOTimer>>(int a1, int a2, char a3);
int __cdecl std::_Destroy_range<CIOSocket::CIOTimer>(int a1, int a2);
void *__cdecl sub_40CE50(void *a1, int a2, int a3);
void *__thiscall sub_40CE90(void *this, int a2, int a3, void *a4);
_DWORD *__cdecl std::fill<CIOSocket::CIOTimer *,CIOSocket::CIOTimer>(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl sub_40CEF0(int a1, int a2, int a3);
CMemory **__cdecl std::_Allocate<CIOSocket::CIOTimer>(int a1);
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator--(_DWORD *this);
BOOL __stdcall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::operator!=(int a1);
int std::_Dist_type<std::vector<CIOSocket::CIOTimer>::iterator>();
int *__cdecl std::_Push_heap_0<std::vector<CIOSocket::CIOTimer>::iterator,int,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(int a1, int a2);
int *std::_Pop_heap_0<std::vector<CIOSocket::CIOTimer>::iterator,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(int a1, int a2, ...);
int __cdecl std::_Destroy_range<CIOSocket::CIOTimer>(int a1, int a2);
void *__cdecl std::_Uninit_fill_n<CIOSocket::CIOTimer *,unsigned int,CIOSocket::CIOTimer,std::allocator<CIOSocket::CIOTimer>>(void *a1, int a2, int a3);
void *__cdecl sub_40D180(int a1, int a2, void *a3);
_DWORD *__cdecl std::_Copy_backward_opt<CIOSocket::CIOTimer *,CIOSocket::CIOTimer *>(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__stdcall std::allocator<CIOSocket::CIOTimer>::construct(void *a1, int a2);
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator-(int *this, _DWORD *a1, int a2);
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator-=(_DWORD *this, int a2);
int *__cdecl std::_Push_heap<std::vector<CIOSocket::CIOTimer>::iterator,int,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(int a1, int a2, int a3, int a4, int a5, int a6);
int *__cdecl sub_40D340(int a1, int a2, int a3, int a4, int a5, int a6);
void *__cdecl std::_Uninit_copy<CIOSocket::CIOTimer *,CIOSocket::CIOTimer *,std::allocator<CIOSocket::CIOTimer>>(int a1, int a2, void *a3);
_DWORD *__cdecl std::_Construct<CIOSocket::CIOTimer,CIOSocket::CIOTimer>(void *a1, int a2);
void sub_40D4A0();
BOOL __stdcall std::less<CIOSocket::CIOTimer>::operator()(int a1, int a2);
BOOL __thiscall CIOSocket::CIOTimer::operator<(_DWORD *this, _DWORD *a2);
int *__cdecl std::_Adjust_heap<std::vector<CIOSocket::CIOTimer>::iterator,int,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(int a1, int a2, int a3, int a4, int a5, int a6);
void *__thiscall std::priority_queue<CIOSocket::CIOTimer>::priority_queue<CIOSocket::CIOTimer,std::vector<CIOSocket::CIOTimer>,std::less<CIOSocket::CIOTimer>>(void *this);
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::vector<CIOSocket::CIOTimer>(void *this);
char __thiscall sub_40D690(_DWORD *this, unsigned int a2);
void *__thiscall sub_40D710(void *this, char a2);
_DWORD *__thiscall sub_40D730(_DWORD *this);
void *__thiscall CServer::`vector deleting destructor'(void *this, char a2);
int *__thiscall std::priority_queue<CIOSocket::CIOTimer>::~priority_queue<CIOSocket::CIOTimer,std::vector<CIOSocket::CIOTimer>,std::less<CIOSocket::CIOTimer>>(void *this);
int *__thiscall std::vector<CIOSocket::CIOTimer>::~vector<CIOSocket::CIOTimer>(void *this);
int *__thiscall std::vector<CIOSocket::CIOTimer>::_Tidy(int *this);
_DWORD *__thiscall lisp::var::operator=(_DWORD *this, int a2);
int __thiscall lisp::_string::GetInteger(lisp::_string *this);
unsigned int __thiscall lisp::_string::GetUnsigned(lisp::_string *this);
int __thiscall lisp::_cons::length(lisp::_cons *this);
_DWORD *__thiscall sub_40D920(_DWORD *this);
void __thiscall CLog::CInit::~CInit(CLog::CInit *this);
void __cdecl CLog::AddV(int nType, char *format, char *va);
void __stdcall CLog::Flush();
void LOG_INFO(char *format, ...);
void LOG_NORMAL(char *format, ...);
void LOG_ERR(char *format, ...);
void __cdecl LOG_DB(int nMainType, int nType, int nID1, int nID2, int nIID, int nVal1, int nVal2, int nVal3, int nVal4);
void __cdecl LOG_PAY(int nLogType, int nID, int nPayType, int nValue);
// int __thiscall Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(_DWORD); weak
// int __thiscall Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(_DWORD); weak
void __thiscall CMemory::CInit::CInit(CMemory::CInit *this);
CMemory *__thiscall CMemory::CMemory(CMemory *this);
int __thiscall CMemory::_heap_init(CMemory *this);
void __thiscall CMemory::_heap_term(CMemory *this);
int __thiscall CMemory::__sbh_heap_init(CMemory *this, unsigned int threshold);
CMemory **__cdecl CMemory::_malloc(size_t Size);
void *__thiscall CMemory::_heap_alloc_base(CMemory *this, unsigned int size);
CMemory::tagEntry **__thiscall CMemory::__sbh_alloc_block(CMemory *this, int intSize);
CMemory::tagHeader *__thiscall CMemory::__sbh_alloc_new_region(CMemory *this);
int __thiscall CMemory::__sbh_alloc_new_group(CMemory *this, CMemory::tagHeader *pHeader);
void __cdecl CMemory::_free(void *pBlock);
void __thiscall CMemory::_free_base(HANDLE *this, LPCVOID lpMem);
CMemory::tagHeader *__thiscall CMemory::__sbh_find_block(CMemory *this, void *pvAlloc);
void __thiscall CMemory::__sbh_free_block(CMemory *this, CMemory::tagHeader *pHeader, void *pvAlloc);
void *__thiscall CMemory::_calloc_base(CMemory *this, unsigned int size);
CMemory **__cdecl CMemory::_realloc(void *pBlock, unsigned int newsize);
void *__thiscall CMemory::_realloc_base(CMemory *this, void *pBlock, unsigned int newsize);
int __thiscall CMemory::__sbh_resize_block(CMemory *this, CMemory::tagHeader *pHeader, void *pvAlloc, int intNew);
void *__thiscall CMemory::_expand_base(CMemory *this, void *pBlock, unsigned int newsize);
unsigned int __thiscall CMemory::_msize_base(CMemory *this, void *pblock);
void *__cdecl CNoMemoryObject::operator new(size_t Size);
void __cdecl CNoMemoryObject::operator delete(void *Block);
void __thiscall CMemory::_mlock(int this);
void __thiscall CMemory::_munlock(int this);
void __thiscall CRWLock::Wait(CRWLock *this);
void __thiscall sub_410140(volatile LONG *this);
LONG __thiscall sub_410170(volatile LONG *this);
char *__thiscall sub_410190(char *this);
void __thiscall sub_4101E0(char *this);
void __thiscall CScreen::Open(CScreen *this, int nWidth, int nHeight);
void CScreen::Add(CScreen *this, unsigned int color, const char *format, ...);
void __thiscall CScreen::AddString(CScreen *this, unsigned int color, const char *string);
// void __thiscall Concurrency::details::WorkSearchContext::ResetLRCBias(Concurrency::details::WorkSearchContext *__hidden this); idb
void __thiscall CScreen::OnPaint(CScreen *this);
void sub_410560();
CIOSocket *__thiscall CServer::CreateSocket(CServer *this, unsigned int newSocket, sockaddr_in *addr);
LONG __cdecl CServer::Add(int a1);
LONG __cdecl CServer::Remove(int a1);
int CServer::Size();
int CServer::Stop();
void __stdcall CServer::Shutdown();
int __cdecl CServer::PendingWrite();
void __thiscall CLink::Initialize(CLink *this);
void __thiscall CLink::Insert(CLink *this, CLink *pLink);
void __thiscall CLink::Remove(CLink *this);
// struct Concurrency::details::UMSThreadProxy *__thiscall Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy(Concurrency::details::UMSFreeVirtualProcessorRoot *__hidden this); idb
_DWORD *__thiscall sub_410810(_DWORD *this);
void *__thiscall CSocket::`vector deleting destructor'(void *this, char a2);
void __thiscall sub_410860(_DWORD *this);
LONG __thiscall sub_410880(int this, int a2, int a3, int a4);
void __thiscall CSyncPacket::OnIOCallback(CSyncPacket *this, int bSuccess, unsigned int dwTransferred, _OVERLAPPED *lpOverlapped);
CSocket *__thiscall CSocket::CSocket(CSocket *this, int a2, int a3);
void __thiscall sub_410AB0(_DWORD *this);
void __thiscall CSocket::OnCreate(CSocket *this);
void __thiscall CSocket::OnRead(CSocket *this);
void __thiscall CSocket::OnClose(CSocket *this);
void CSocket::Write(int a1, char a2, ...);
void __thiscall CSocket::Process(CSocket *this, DBPACKET *dbpacket);
void __thiscall CSocket::DelPlayer(CSocket *this, int nPID, int nUID, int nId);
void __thiscall CSocket::LoadPlayer(CSocket *this, int nPID, int nLoadGID, int nUID, int nId);
void __stdcall sub_413CB0(void *Src);
void __thiscall CSocket::DeleteItem(CSocket *this, int nIID, int nPID, int nIndex, int nNum, int nVal1, int nVal2, int nLogType);
void __thiscall CSocket::PutOnItem(CSocket *this, int nIID);
void __thiscall CSocket::PutOffItem(CSocket *this, int nIID);
void __thiscall CSocket::InsertItem(CSocket *this, char *packet);
void __thiscall CSocket::UpdateItemPID(CSocket *this, int nIID, int nOldPID, int nNewPID, int nIndex, int nNum, int nLogType);
void __thiscall CSocket::UpdateItemNum(CSocket *this, int nIID, int nPID, int nIndex, int nNum, int nLogType);
void __thiscall CSocket::InsertSkill(CSocket *this, int nPID, int nSkill, int nSUPoint);
void __thiscall CSocket::SkillUp(CSocket *this, int nPID, int nSkill, int nLevel, int nSUPoint);
void __thiscall CSocket::PutInStorage(CSocket *this, int nIID, int nPID, int nUID, int nUpdateType, int nNum);
void __thiscall CSocket::PutOutStorage(CSocket *this, int nIID, int nPID, int nUpdateType, int nNum);
void __thiscall CSocket::InsertQuestFlag(CSocket *this, int nPID, int nQuest, int nFlag, int bClear);
void __thiscall CSocket::UpdateQuestFlag(CSocket *this, int nPID, int nQuest, int nFlag, int bClear);
void __thiscall CSocket::SaveSpecialty(CSocket *this, int nPID, int nSpecialty);
void __thiscall CSocket::UpdateProperty(CSocket *this, int nPID, int nPrtyType, char *packet);
void __thiscall CSocket::UpdateItemXValue(CSocket *this, int nIID, int nPID, int nPrtyType, int nXValue);
void __thiscall CSocket::UpdateItemEnd(CSocket *this, int nIID, int nPID, int nCurEnd);
void __thiscall CSocket::UpdateItemPrefix(CSocket *this, int nIID, int nPID, int nNewPrefix);
void __thiscall CSocket::UpdateTransformItem(CSocket *this, int nIID, int nPID, int nExp, int nLevel, int bLevelUp);
void __stdcall sub_414E10(int a1, int a2, int a3, int a4, void *Src);
void __stdcall sub_414F80(int a1, int a2, int a3, int a4);
void __thiscall CSocket::SkillRedistribute(CSocket *this, int nPID, int nSkill, int nLevel, int nSUPoint);
void __stdcall sub_415180(int a1, int a2, int a3, int a4);
void __thiscall sub_415240(void *this, int a2, int a3, void *Src);
void __thiscall sub_415500(void *this, int a2, int a3, void *Src);
void __thiscall sub_415790(void *this, int a2, int a3, void *Src);
void __thiscall sub_4168C0(void *this, int a2, int a3);
void __thiscall CSocket::NewPlayer(CSocket *this, char *packet);
void __stdcall sub_417340(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int TargetValue, int a10, int a11);
void __thiscall CSocket::SaveRevivalPt(CSocket *this, int nPID, int nRvId);
void __thiscall CSocket::EventSave(CSocket *this, int nPID, int nCount, const char *info);
void __thiscall CSocket::ProcessEvent(CSocket *this, int nId, int nEventCode, char *packet);
void __thiscall CSocket::GuildCreateSecedeCheck(CSocket *this, int nPlayer, int nCount, const char *info);
void __thiscall CSocket::GuildSecedeCheck(CSocket *this, int nPlayer, int nPID, int nGID);
void __thiscall CSocket::GuildSameNameCheck(CSocket *this, int nPlayer, char *szGuildName);
void __thiscall CSocket::GuildCreate(CSocket *this, int nGID, char *szGuildName);
void __thiscall CSocket::GuildConflux(CSocket *this, int nGID, int nPID);
void __thiscall CSocket::GuildSecederDelete(CSocket *this, int nPID);
void __thiscall CSocket::GuildSeceder(CSocket *this, int nPID, int nSecedeDate);
void __thiscall CSocket::GuildAppointment(CSocket *this, int nPID, int nClass, int nDate);
void __thiscall CSocket::GuildDissolution(CSocket *this, int nGID, int nSecedeDate);
void __thiscall CSocket::GuildTitleChange(CSocket *this, int nGID, int nClass, char *szTitle);
void __thiscall CSocket::GuildTodayMessageChange(CSocket *this, int nGID, char *szMessage);
void __stdcall sub_417EC0(int a1, int a2, int a3);
void __thiscall CSocket::GuildSetExp(CSocket *this, int nGID, int nExp);
void __stdcall sub_418020(int a1, int a2, int a3, int a4, int a5, int a6);
void __stdcall sub_4180A0(int a1, int a2);
void __stdcall sub_418140(int a1, int a2, int a3);
void __stdcall sub_418300(int a1);
void __stdcall sub_4183A0(int a1, int a2);
void __thiscall sub_418430(void *this);
void __thiscall sub_4185D0(void *this);
void sub_4188D0();
void __stdcall sub_418930(int a1, int a2, int a3);
void __stdcall sub_4189C0(int a1, int a2);
void __stdcall sub_418A50(int a1, int a2);
void __stdcall sub_418AC0(int a1, int a2);
void __stdcall sub_418B30(int a1, int a2);
_BYTE *__stdcall sub_418BA0(int a1, int a2, _BYTE *a3);
void __thiscall sub_4191C0(void *this, int a2, int a3, int a4);
void __thiscall sub_4192D0(void *this, int a2, int a3, int a4);
void __thiscall sub_4193B0(void *this, int a2, int a3, int a4, int a5, const char *a6);
void __thiscall sub_419510(void *this, int a2, int a3, int a4, const char *a5, int a6);
void __thiscall sub_419D90(void *this, int a2, int a3, void *Src);
void __stdcall sub_41A280(const char *a1, const char *a2, const char *a3);
void __thiscall sub_41A2F0(void *this);
void __thiscall sub_41A450(void *this, int a2, int a3, void *Src);
void __thiscall sub_41A5B0(void *this, int a2, int a3);
void __thiscall sub_41A750(void *this, int a2, int a3, int a4, void *Src);
void __thiscall sub_41A890(void *this, int a2, int a3, const char *a4, const char *a5);
void __thiscall sub_41AA30(void *this, int a2, int a3, const char *a4, const char *a5);
void __stdcall sub_41AB20(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __stdcall sub_41ABA0(int a1, int a2, int a3);
void __stdcall sub_41AC30(int a1, int a2, int a3);
void __thiscall sub_41AC50(void *this, int a2, int a3);
void __stdcall sub_41AD20(int a1, int a2);
int __stdcall sub_41AD90(int a1, int a2);
void __thiscall CSyncPacket::Pop(CSyncPacket *this);
void __thiscall CSyncPacket::CElement::CElement(CSyncPacket::CElement *this, CSocket *pSocket, CIOBuffer *pBuf, DBPACKET *packet);
int __thiscall CSyncPacket::Front(char *this);
_DWORD *__thiscall CIOSocket::CIOTimerInstance::`scalar deleting destructor'(_DWORD *this, char a2);
LONG __thiscall CIOBuffer::AddRef(volatile LONG *this);
void __thiscall CSyncPacket::Push(CSyncPacket *this, CSyncPacket::CElement *element);
// void __thiscall Concurrency::details::UMSFreeVirtualProcessorRoot::~UMSFreeVirtualProcessorRoot(Concurrency::details::UMSFreeVirtualProcessorRoot *__hidden this); idb
// int __thiscall CDB::Skip(_DWORD); weak
// int __stdcall CDB::Bind(SQLPOINTER TargetValue); idb
void __thiscall CDB::Bind(CDB *this, int *n);
void __thiscall CDB::Bind(CDB *this, __int64 *n);
void __thiscall CDB::Bind(CDB *this, char *str, int size);
SQLRETURN __thiscall sub_41B2B0(int this, SQLSMALLINT TargetType, SQLPOINTER TargetValue, SQLINTEGER BufferLength, SQLINTEGER *StrLen_or_Ind);
// void __thiscall Concurrency::details::ExternalStatistics::IncrementDequeuedTaskCounter(Concurrency::details::ExternalStatistics *__hidden this, unsigned int); idb
SQLRETURN __thiscall sub_41B310(SQLHSTMT *this, SQLUSMALLINT ipar, SQLSMALLINT fParamType, SQLSMALLINT fCType, SQLSMALLINT fSqlType, SQLUINTEGER cbColDef, SQLSMALLINT ibScale, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER *pcbValue);
int __cdecl sub_41B360(int a1, int a2);
void __thiscall CDB::Bind(CDB *this, unsigned __int16 *n);
BOOL __thiscall std::vector<IPAddrMask>::empty(_DWORD *this);
_DWORD *CMemoryPool<CPacket>::Alloc();
LONG __cdecl sub_41B4B0(int a1);
void *__thiscall std::vector<CSyncPacket::CElement>::begin(int *this, void *a2);
int __thiscall std::vector<CSyncPacket::CElement>::insert(int *this, int a2, int a3, int a4);
int __thiscall std::vector<CSyncPacket::CElement>::iterator::operator*(void *this);
_DWORD *__thiscall std::vector<CSyncPacket::CElement>::iterator::operator++(_DWORD *this);
_DWORD *__thiscall sub_41B5C0(int *this, _DWORD *a1, int a2);
int __thiscall std::vector<IPAddrMask>::iterator::operator->(void *this);
_DWORD *__thiscall std::vector<IPAddrMask>::iterator::operator++(int *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_41B640(_DWORD *this);
_DWORD *__thiscall sub_41B660(_DWORD *this);
int __thiscall std::vector<CSyncPacket::CElement>::size(_DWORD *this);
void *__thiscall std::vector<CSyncPacket::CElement>::_Insert_n(_DWORD *this, int a2, unsigned int a3, int *a4);
_DWORD *__thiscall std::vector<CSyncPacket::CElement>::iterator::operator+=(_DWORD *this, int a2);
int __thiscall std::vector<CSyncPacket::CElement>::iterator::operator-(int *this, int a1);
int __thiscall std::vector<CSyncPacket::CElement>::capacity(_DWORD *this);
int __thiscall std::vector<CSyncPacket::CElement>::max_size(void *this);
int __thiscall std::vector<CSyncPacket::CElement>::_Destroy(void *this, int a2, int a3);
int __thiscall std::vector<CSyncPacket::CElement>::_Ufill(void *this, void *a2, int a3, int a4);
void __noreturn std::vector<CSyncPacket::CElement>::_Xlen();
CMemory **__stdcall std::allocator<CSyncPacket::CElement>::allocate(int a1);
int __thiscall std::vector<CSyncPacket::CElement>::const_iterator::operator-(_DWORD *this, _DWORD *a2);
int std::allocator<CSyncPacket::CElement>::max_size();
_BYTE *__cdecl PutNumeric<unsigned char>(_BYTE *a1, char a2);
_WORD *__cdecl PutNumeric<short>(_WORD *a1, __int16 a2);
_DWORD *__cdecl PutNumeric<__int64>(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl PutNumeric<int>(_DWORD *a1, int a2);
_BYTE *__cdecl GetNumeric<unsigned char>(_BYTE *a1, _BYTE *a2);
_DWORD *__cdecl GetNumeric<int>(_DWORD *a1, _DWORD *a2);
void *__thiscall std::vector<CSyncPacket::CElement>::_Ucopy<CSyncPacket::CElement *>(void *this, int a2, int a3, void *a4);
_DWORD *__cdecl std::fill<CSyncPacket::CElement *,CSyncPacket::CElement>(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__cdecl sub_41BD10(int a1, int a2, int a3);
int __cdecl sub_41BD50(int a1, int a2);
void *__cdecl sub_41BD90(void *a1, int a2, int a3);
CMemory **__cdecl sub_41BDD0(int a1);
void *__cdecl sub_41BDF0(int a1, int a2, void *a3);
_DWORD *__cdecl std::_Copy_backward_opt<CSyncPacket::CElement *,CSyncPacket::CElement *>(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __cdecl std::_Destroy_range<CSyncPacket::CElement>(int a1, int a2);
void *__cdecl std::_Uninit_fill_n<CSyncPacket::CElement *,unsigned int,CSyncPacket::CElement,std::allocator<CSyncPacket::CElement>>(void *a1, int a2, int a3);
_DWORD *__stdcall sub_41BF40(void *a1, int a2);
void *__cdecl std::_Uninit_copy<CSyncPacket::CElement *,CSyncPacket::CElement *,std::allocator<CSyncPacket::CElement>>(int a1, int a2, void *a3);
_DWORD *__cdecl std::_Construct<CSyncPacket::CElement,CSyncPacket::CElement>(void *a1, int a2);
void __thiscall CSyncPacket::CSyncPacket(CSyncPacket *this);
void *__thiscall CSyncPacket::`vector deleting destructor'(void *this, char a2);
void __thiscall CSyncPacket::~CSyncPacket(CSyncPacket *this);
_DWORD *__thiscall sub_41C1C0(void *this);
int *__thiscall std::vector<CSyncPacket::CElement>::~vector<CSyncPacket::CElement>(void *this);
void *__thiscall sub_41C210(void *this);
char __thiscall sub_41C230(_DWORD *this, unsigned int a2);
int *__thiscall std::vector<CSyncPacket::CElement>::_Tidy(int *this);
char *__thiscall sub_41C320(char *this);
LONG __thiscall CMemoryPool<CPacket>::CPool::~CPool(void *this);
LONG CMemoryPool<CPacket>::FreeAll();
BOOL __stdcall CStatus::Update();
__time32_t __stdcall InitRandom();
int sub_41C5A0();
char *__stdcall WritePacketV(char *packet, char *va);
char *WritePacket(char *packet, const char *formal, ...);
char *__stdcall ReadPacketV(char *packet, char *va);
char *ReadPacket(char *packet, const char *formal, ...);
char *__stdcall ScanPacketV(char *packet, char *end, char *va);
char *__stdcall PutString(char *packet, const char *str);
BOOL __cdecl CreatePath(const char *szPath);
BOOL __cdecl CheckResidentNum(char *szNum1, char *szNum2);
void sub_41D600();
void __cdecl LogPacket(int nType, int nSize, char *buffer);
void *__cdecl sub_41DD60(void *a1);
unsigned int sub_41DE00();
void *__thiscall sub_41DE10(void *this);
// BOOL __stdcall MiniDumpWriteDump(HANDLE hProcess, DWORD ProcessId, HANDLE hFile, MINIDUMP_TYPE DumpType, PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, PMINIDUMP_CALLBACK_INFORMATION CallbackParam);
// SQLRETURN __stdcall SQLFreeHandle(SQLSMALLINT HandleType, SQLHANDLE Handle);
// SQLRETURN __stdcall SQLConnect(SQLHDBC ConnectionHandle, SQLCHAR *ServerName, SQLSMALLINT NameLength1, SQLCHAR *UserName, SQLSMALLINT NameLength2, SQLCHAR *Authentication, SQLSMALLINT NameLength3);
// SQLRETURN __stdcall SQLAllocHandle(SQLSMALLINT HandleType, SQLHANDLE InputHandle, SQLHANDLE *OutputHandle);
// SQLRETURN __stdcall SQLSetEnvAttr(SQLHENV EnvironmentHandle, SQLINTEGER Attribute, SQLPOINTER Value, SQLINTEGER StringLength);
// SQLRETURN __stdcall SQLFreeStmt(SQLHSTMT StatementHandle, SQLUSMALLINT Option);
// SQLRETURN __stdcall SQLGetDiagRec(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLSMALLINT RecNumber, SQLCHAR *Sqlstate, SQLINTEGER *NativeError, SQLCHAR *MessageText, SQLSMALLINT BufferLength, SQLSMALLINT *TextLength);
// SQLRETURN __stdcall SQLExecDirect(SQLHSTMT StatementHandle, SQLCHAR *StatementText, SQLINTEGER TextLength);
// SQLRETURN __stdcall SQLFetch(SQLHSTMT StatementHandle);
// SQLRETURN __stdcall SQLBindCol(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType, SQLPOINTER TargetValue, SQLINTEGER BufferLength, SQLINTEGER *StrLen_or_Ind);
// SQLRETURN __stdcall SQLBindParameter(SQLHSTMT hstmt, SQLUSMALLINT ipar, SQLSMALLINT fParamType, SQLSMALLINT fCType, SQLSMALLINT fSqlType, SQLUINTEGER cbColDef, SQLSMALLINT ibScale, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER *pcbValue);
// void __thiscall __noreturn std::_String_base::_Xran(std::_String_base *__hidden this); idb
// void __thiscall std::_String_base::_Xlen(std::_String_base *__hidden this); idb
int __cdecl operator new(size_t Size); // idb
// int __cdecl fclose(FILE *Stream);
// int __cdecl isalnum(int C);
// int __cdecl ungetc_0(int Character, FILE *Stream);
// int __cdecl fgetc(FILE *Stream);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// size_t __cdecl strlen(const char *Str);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl strcat(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// int __cdecl _vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
// size_t __cdecl strcspn(const char *Str, const char *Control);
int __cdecl j__atol(const char *String);
// size_t __cdecl strspn(const char *Str, const char *Control);
// int sprintf(char *const Buffer, const char *const Format, ...);
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
_DWORD *__thiscall sub_41EED8(_DWORD *this);
// exception *__thiscall exception::exception(exception *__hidden this, const struct exception *); idb
void __thiscall exception::~exception(exception *this);
void *__thiscall exception::`vector deleting destructor'(void *this, char a2);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// uintptr_t __cdecl _beginthreadex(void *Security, unsigned int StackSize, _beginthreadex_proc_type StartAddress, void *ArgList, unsigned int InitFlag, unsigned int *ThrdAddr);
// struct tm *__cdecl gmtime(const __time32_t *const Time);
// __time32_t __cdecl time(__time32_t *const Time);
// void *__cdecl memset(void *, int Val, size_t Size);
int __cdecl _set_security_error_handler(int a1);
// char *__cdecl strrchr(const char *Str, int Ch);
// struct tm *__cdecl localtime(const __time32_t *const Time);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// int _snprintf(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
// unsigned int __cdecl strtoul(const char *String, char **EndPtr, int Radix);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
unsigned int __cdecl fwrite_0(const void *buffer, unsigned int size, unsigned int count, _iobuf *stream);
// __time32_t __cdecl mktime(struct tm *const Tm);
// int __cdecl vsprintf(char *const Buffer, const char *const Format, va_list ArgList);
// _DWORD __cdecl flsall(_DWORD); weak
// int __cdecl fflush(FILE *Stream);
int sub_42023C();
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
_DWORD __cdecl operator delete(_DWORD); // weak
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int __cdecl abs(int Number);
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
// void __cdecl srand(unsigned int Seed);
// int __cdecl tolower(int C);
// void __cdecl _lock_file(FILE *Stream);
// void __cdecl _unlock_file(FILE *Stream);
// void __cdecl __noreturn __pInconsistency(); idb
void __stdcall __noreturn _inconsistency();
void __cdecl _RTC_Initialize();
void __cdecl _RTC_Terminate();
// int __cdecl _stricmp(const char *String1, const char *String2);
int sub_429900();
int sub_429910();
int sub_429920();
int sub_429930();
int *sub_429940();
int sub_429950();
void sub_429960();
void sub_429970();
int sub_429980();
int *sub_429990();
_DWORD *sub_4299A0();
void sub_4299B0();
void sub_4299C0();
void sub_4299D0();
void sub_4299E0();
LONG sub_429A00();
void sub_429A10();
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color);
// BOOL __stdcall TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c);
// BOOL __stdcall GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// LONG __stdcall InterlockedCompareExchange(volatile LONG *Destination, LONG Exchange, LONG Comperand);
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// DWORD __stdcall GetTickCount();
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// DWORD __stdcall GetLastError();
// HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// void __stdcall Sleep(DWORD dwMilliseconds);
// BOOL __stdcall GetThreadContext(HANDLE hThread, LPCONTEXT lpContext);
// HANDLE __stdcall GetCurrentThread();
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall DeleteFileA(LPCSTR lpFileName);
// BOOL __stdcall MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// HANDLE __stdcall GetCurrentProcess();
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// DWORD __stdcall GetCurrentThreadId();
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall OutputDebugStringA(LPCSTR lpOutputString);
// int __stdcall lstrlenA(LPCSTR lpString);
// DWORD __stdcall GetCurrentProcessId();
// BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);
// BOOL __stdcall IsBadWritePtr(LPVOID lp, UINT_PTR ucb);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// DWORD __stdcall SuspendThread(HANDLE hThread);
// BOOL __stdcall SwitchToThread();
// BOOL __stdcall TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// HANDLE __stdcall CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// BOOL __stdcall SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// BOOL __stdcall PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// BOOL __stdcall GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds);
// DWORD __stdcall SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor);
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// SIZE_T __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// BOOL __stdcall CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// BOOL __stdcall IsDBCSLeadByte(BYTE TestChar);
// UINT __stdcall GetACP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// int __stdcall wvsprintfA(LPSTR, LPCSTR, va_list arglist);
// BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint);
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);
// HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
// int wsprintfA(LPSTR, LPCSTR, ...);
// UINT_PTR __stdcall SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
// BOOL __stdcall KillTimer(HWND hWnd, UINT_PTR uIDEvent);
// BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase);
// LRESULT __stdcall DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// void __stdcall PostQuitMessage(int nExitCode);
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// BOOL __stdcall UpdateWindow(HWND hWnd);
// HICON __stdcall LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName);
// HCURSOR __stdcall LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName);
// ATOM __stdcall RegisterClassExA(const WNDCLASSEXA *);
// int __stdcall LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax);
// HACCEL __stdcall LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName);
// BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// int __stdcall TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// LRESULT __stdcall DispatchMessageA(const MSG *lpMsg);
// BOOL __stdcall SetWindowTextA(HWND hWnd, LPCSTR lpString);
// BOOL __stdcall PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// INT_PTR __stdcall DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// BOOL __stdcall SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString);
// UINT __stdcall GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax);
// BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult);
// char *__stdcall inet_ntoa(struct in_addr in);
// SOCKET __stdcall accept(SOCKET s, struct sockaddr *addr, int *addrlen);
// BOOL __stdcall WSAResetEvent(HANDLE hEvent);
// int __stdcall WSAGetLastError();
// u_long __stdcall htonl(u_long hostlong);
// int __stdcall listen(SOCKET s, int backlog);
// HANDLE __stdcall WSACreateEvent();
// int __stdcall WSAEventSelect(SOCKET s, HANDLE hEventObject, int lNetworkEvents);
// BOOL __stdcall WSACloseEvent(HANDLE hEvent);
// int __stdcall WSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// int __stdcall WSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// SOCKET __stdcall socket(int af, int type, int protocol);
// int __stdcall WSACleanup();
// int __stdcall setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen);
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen);
// struct hostent *__stdcall gethostbyname(const char *name);
// u_short __stdcall htons(u_short hostshort);
// int __stdcall connect(SOCKET s, const struct sockaddr *name, int namelen);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall getsockname(SOCKET s, struct sockaddr *name, int *namelen);
// int __stdcall closesocket(SOCKET s);
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// unsigned int __stdcall inet_addr(const char *cp);
// DWORD __stdcall SymGetModuleBase(HANDLE hProcess, DWORD dwAddr);
// PVOID __stdcall SymFunctionTableAccess(HANDLE hProcess, DWORD AddrBase);
// BOOL __stdcall StackWalk(DWORD MachineType, HANDLE hProcess, HANDLE hThread, LPSTACKFRAME StackFrame, PVOID ContextRecord, PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine, PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine, PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine, PTRANSLATE_ADDRESS_ROUTINE TranslateAddress);
// BOOL __stdcall SymFromAddr(HANDLE hProcess, DWORD64 Address, PDWORD64 Displacement, PSYMBOL_INFO Symbol);
// DWORD __stdcall UnDecorateSymbolName(PCSTR name, PSTR outputString, DWORD maxStringLength, DWORD flags);
// BOOL __stdcall SymGetLineFromAddr64(HANDLE hProcess, DWORD64 qwAddr, PDWORD pdwDisplacement, PIMAGEHLP_LINE64 Line64);
// BOOL __stdcall SymInitialize(HANDLE hProcess, PCSTR UserSearchPath, BOOL fInvadeProcess);
// DWORD __stdcall SymGetOptions();
// DWORD __stdcall SymSetOptions(DWORD SymOptions);
// BOOL __stdcall SymCleanup(HANDLE hProcess);

//-------------------------------------------------------------------------
// Data declarations

int (*off_42A420[20])() =
{
  &unknown_libname_3,
  &lisp::_string::GetInteger,
  &lisp::_string::GetUnsigned,
  &lisp::_object::GetString,
  &lisp::_object::GetString,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_4,
  &unknown_libname_1,
  &unknown_libname_2,
  &sub_402100,
  &unknown_libname_2,
  &unknown_libname_2,
  &lisp::_object::GetString,
  &lisp::_object::GetString,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_2
}; // weak
int (*off_42A448[10])() =
{
  &sub_402100,
  &unknown_libname_2,
  &unknown_libname_2,
  &lisp::_object::GetString,
  &lisp::_object::GetString,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_2
}; // weak
_UNKNOWN unk_42A470; // weak
int (*off_42A474[20])() =
{
  &sub_402100,
  &unknown_libname_3,
  &unknown_libname_3,
  &lisp::_object::GetString,
  &lisp::_object::GetString,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_4,
  &unknown_libname_2,
  &sub_402100,
  &unknown_libname_2,
  &unknown_libname_2,
  &unknown_libname_5,
  &unknown_libname_6,
  &unknown_libname_4,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_1,
  &lisp::_cons::length
}; // weak
int (*off_42A49C[10])() =
{
  &sub_402100,
  &unknown_libname_2,
  &unknown_libname_2,
  &unknown_libname_5,
  &unknown_libname_6,
  &unknown_libname_4,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_1,
  &lisp::_cons::length
}; // weak
const CHAR Class[4] = { '\0', '\0', '\0', '\0' }; // idb
const char byte_42A816[2] = { '\0', '\0' }; // idb
const char byte_42A827 = '\0'; // idb
const unsigned int std::string::npos = 4294967295u;
_UNKNOWN unk_42AFCC; // weak
int (__stdcall *off_42B5BC)(int) = &CIOObject::`vector deleting destructor'; // weak
int (__stdcall *off_42B5D4)(int) = &CIOSocket::`vftable'; // weak
int (__stdcall *off_42B5F8)(int) = &CIOServer::`vftable'; // weak
int (__stdcall *off_42B614)(int) = &CServer::`vector deleting destructor'; // weak
int (*off_42B62C[10])() =
{
  &sub_402100,
  &unknown_libname_2,
  &unknown_libname_2,
  &lisp::_object::GetString,
  &lisp::_object::GetString,
  &unknown_libname_1,
  &unknown_libname_4,
  &unknown_libname_1,
  &unknown_libname_1,
  &unknown_libname_2
}; // weak
int (__stdcall *off_42B738)(int) = &CSocket::`vector deleting destructor'; // weak
const char aInsertIntoGuil_3[] = "INSERT INTO Guild VALUES (%d,'%s',0,0,'','"; // idb
_UNKNOWN unk_42ED6D; // weak
_UNKNOWN unk_42ED6E; // weak
_UNKNOWN unk_42EDA8; // weak
_UNKNOWN unk_42EDA9; // weak
int (__stdcall *off_42F84C)(int) = &CIOSocket::CIOTimerInstance::`scalar deleting destructor'; // weak
int (__stdcall *off_42F870)(int) = &CServer::`vector deleting destructor'; // weak
int (__stdcall *off_42F888)(int) = &CSyncPacket::`vector deleting destructor'; // weak
_UNKNOWN unk_437900; // weak
void *std::logic_error::`vftable' = &std::logic_error::`vector deleting destructor'; // weak
void *std::length_error::`vftable' = &std::length_error::`vector deleting destructor'; // weak
void *std::out_of_range::`vftable' = &std::out_of_range::`vector deleting destructor'; // weak
int (__stdcall *off_437A20)(char) = &exception::`vector deleting destructor'; // weak
void (__cdecl *const __rtc_izz[1])() = { NULL };
void (__cdecl *const __rtc_tzz[1])() = { NULL };
const _ThrowInfo _TI3_AVlength_error_std__ = { 0u, &std::length_error::~length_error, NULL, &_CTA3_AVlength_error_std__ }; // idb
const _ThrowInfo _TI3_AVout_of_range_std__ = { 0u, &std::out_of_range::~out_of_range, NULL, &_CTA3_AVout_of_range_std__ }; // idb
int dword_43C0A0 = 5000; // weak
char p[64] =
{
  ':',
  '2',
  '*',
  '\"',
  '\x1A',
  '\x12',
  '\n',
  '\x02',
  '<',
  '4',
  ',',
  '$',
  '\x1C',
  '\x14',
  '\f',
  '\x04',
  '>',
  '6',
  '.',
  '&',
  '\x1E',
  '\x16',
  '\x0E',
  '\x06',
  '@',
  '8',
  '0',
  '(',
  ' ',
  '\x18',
  '\x10',
  '\b',
  '9',
  '1',
  ')',
  '!',
  '\x19',
  '\x11',
  '\t',
  '\x01',
  ';',
  '3',
  '+',
  '#',
  '\x1B',
  '\x13',
  '\v',
  '\x03',
  '=',
  '5',
  '-',
  '%',
  '\x1D',
  '\x15',
  '\r',
  '\x05',
  '?',
  '7',
  '/',
  '\'',
  '\x1F',
  '\x17',
  '\x0F',
  '\a'
};
char fp[64] =
{
  '(',
  '\b',
  '0',
  '\x10',
  '8',
  '\x18',
  '@',
  ' ',
  '\'',
  '\a',
  '/',
  '\x0F',
  '7',
  '\x17',
  '?',
  '\x1F',
  '&',
  '\x06',
  '.',
  '\x0E',
  '6',
  '\x16',
  '>',
  '\x1E',
  '%',
  '\x05',
  '-',
  '\r',
  '5',
  '\x15',
  '=',
  '\x1D',
  '$',
  '\x04',
  ',',
  '\f',
  '4',
  '\x14',
  '<',
  '\x1C',
  '#',
  '\x03',
  '+',
  '\v',
  '3',
  '\x13',
  ';',
  '\x1B',
  '\"',
  '\x02',
  '*',
  '\n',
  '2',
  '\x12',
  ':',
  '\x1A',
  '!',
  '\x01',
  ')',
  '\t',
  '1',
  '\x11',
  '9',
  '\x19'
};
char byte_43C1A0[56] =
{
  '9',
  '1',
  ')',
  '!',
  '\x19',
  '\x11',
  '\t',
  '\x01',
  ':',
  '2',
  '*',
  '\"',
  '\x1A',
  '\x12',
  '\n',
  '\x02',
  ';',
  '3',
  '+',
  '#',
  '\x1B',
  '\x13',
  '\v',
  '\x03',
  '<',
  '4',
  ',',
  '$',
  '?',
  '7',
  '/',
  '\'',
  '\x1F',
  '\x17',
  '\x0F',
  '\a',
  '>',
  '6',
  '.',
  '&',
  '\x1E',
  '\x16',
  '\x0E',
  '\x06',
  '=',
  '5',
  '-',
  '%',
  '\x1D',
  '\x15',
  '\r',
  '\x05',
  '\x1C',
  '\x14',
  '\f',
  '\x04'
}; // idb
char totrot[16] =
{
  '\x01',
  '\x02',
  '\x04',
  '\x06',
  '\b',
  '\n',
  '\f',
  '\x0E',
  '\x0F',
  '\x11',
  '\x13',
  '\x15',
  '\x17',
  '\x19',
  '\x1B',
  '\x1C'
}; // idb
char pc2[48] =
{
  '\x0E',
  '\x11',
  '\v',
  '\x18',
  '\x01',
  '\x05',
  '\x03',
  '\x1C',
  '\x0F',
  '\x06',
  '\x15',
  '\n',
  '\x17',
  '\x13',
  '\f',
  '\x04',
  '\x1A',
  '\b',
  '\x10',
  '\a',
  '\x1B',
  '\x14',
  '\r',
  '\x02',
  ')',
  '4',
  '\x1F',
  '%',
  '/',
  '7',
  '\x1E',
  '(',
  '3',
  '-',
  '!',
  '0',
  ',',
  '1',
  '\'',
  '8',
  '\"',
  '5',
  '.',
  '*',
  '2',
  '$',
  '\x1D',
  ' '
}; // idb
char byte_43C218[512] =
{
  '\x0E',
  '\x04',
  '\r',
  '\x01',
  '\x02',
  '\x0F',
  '\v',
  '\b',
  '\x03',
  '\n',
  '\x06',
  '\f',
  '\x05',
  '\t',
  '\0',
  '\a',
  '\0',
  '\x0F',
  '\a',
  '\x04',
  '\x0E',
  '\x02',
  '\r',
  '\x01',
  '\n',
  '\x06',
  '\f',
  '\v',
  '\t',
  '\x05',
  '\x03',
  '\b',
  '\x04',
  '\x01',
  '\x0E',
  '\b',
  '\r',
  '\x06',
  '\x02',
  '\v',
  '\x0F',
  '\f',
  '\t',
  '\a',
  '\x03',
  '\n',
  '\x05',
  '\0',
  '\x0F',
  '\f',
  '\b',
  '\x02',
  '\x04',
  '\t',
  '\x01',
  '\a',
  '\x05',
  '\v',
  '\x03',
  '\x0E',
  '\n',
  '\0',
  '\x06',
  '\r',
  '\x0F',
  '\x01',
  '\b',
  '\x0E',
  '\x06',
  '\v',
  '\x03',
  '\x04',
  '\t',
  '\a',
  '\x02',
  '\r',
  '\f',
  '\0',
  '\x05',
  '\n',
  '\x03',
  '\r',
  '\x04',
  '\a',
  '\x0F',
  '\x02',
  '\b',
  '\x0E',
  '\f',
  '\0',
  '\x01',
  '\n',
  '\x06',
  '\t',
  '\v',
  '\x05',
  '\0',
  '\x0E',
  '\a',
  '\v',
  '\n',
  '\x04',
  '\r',
  '\x01',
  '\x05',
  '\b',
  '\f',
  '\x06',
  '\t',
  '\x03',
  '\x02',
  '\x0F',
  '\r',
  '\b',
  '\n',
  '\x01',
  '\x03',
  '\x0F',
  '\x04',
  '\x02',
  '\v',
  '\x06',
  '\a',
  '\f',
  '\0',
  '\x05',
  '\x0E',
  '\t',
  '\n',
  '\0',
  '\t',
  '\x0E',
  '\x06',
  '\x03',
  '\x0F',
  '\x05',
  '\x01',
  '\r',
  '\f',
  '\a',
  '\v',
  '\x04',
  '\x02',
  '\b',
  '\r',
  '\a',
  '\0',
  '\t',
  '\x03',
  '\x04',
  '\x06',
  '\n',
  '\x02',
  '\b',
  '\x05',
  '\x0E',
  '\f',
  '\v',
  '\x0F',
  '\x01',
  '\r',
  '\x06',
  '\x04',
  '\t',
  '\b',
  '\x0F',
  '\x03',
  '\0',
  '\v',
  '\x01',
  '\x02',
  '\f',
  '\x05',
  '\n',
  '\x0E',
  '\a',
  '\x01',
  '\n',
  '\r',
  '\0',
  '\x06',
  '\t',
  '\b',
  '\a',
  '\x04',
  '\x0F',
  '\x0E',
  '\x03',
  '\v',
  '\x05',
  '\x02',
  '\f',
  '\a',
  '\r',
  '\x0E',
  '\x03',
  '\0',
  '\x06',
  '\t',
  '\n',
  '\x01',
  '\x02',
  '\b',
  '\x05',
  '\v',
  '\f',
  '\x04',
  '\x0F',
  '\r',
  '\b',
  '\v',
  '\x05',
  '\x06',
  '\x0F',
  '\0',
  '\x03',
  '\x04',
  '\a',
  '\x02',
  '\f',
  '\x01',
  '\n',
  '\x0E',
  '\t',
  '\n',
  '\x06',
  '\t',
  '\0',
  '\f',
  '\v',
  '\a',
  '\r',
  '\x0F',
  '\x01',
  '\x03',
  '\x0E',
  '\x05',
  '\x02',
  '\b',
  '\x04',
  '\x03',
  '\x0F',
  '\0',
  '\x06',
  '\n',
  '\x01',
  '\r',
  '\b',
  '\t',
  '\x04',
  '\x05',
  '\v',
  '\f',
  '\a',
  '\x02',
  '\x0E',
  '\x02',
  '\f',
  '\x04',
  '\x01',
  '\a',
  '\n',
  '\v',
  '\x06',
  '\b',
  '\x05',
  '\x03',
  '\x0F',
  '\r',
  '\0',
  '\x0E',
  '\t',
  '\x0E',
  '\v',
  '\x02',
  '\f',
  '\x04',
  '\a',
  '\r',
  '\x01',
  '\x05',
  '\0',
  '\x0F',
  '\n',
  '\x03',
  '\t',
  '\b',
  '\x06',
  '\x04',
  '\x02',
  '\x01',
  '\v',
  '\n',
  '\r',
  '\a',
  '\b',
  '\x0F',
  '\t',
  '\f',
  '\x05',
  '\x06',
  '\x03',
  '\0',
  '\x0E',
  '\v',
  '\b',
  '\f',
  '\a',
  '\x01',
  '\x0E',
  '\x02',
  '\r',
  '\x06',
  '\x0F',
  '\0',
  '\t',
  '\n',
  '\x04',
  '\x05',
  '\x03',
  '\f',
  '\x01',
  '\n',
  '\x0F',
  '\t',
  '\x02',
  '\x06',
  '\b',
  '\0',
  '\r',
  '\x03',
  '\x04',
  '\x0E',
  '\a',
  '\x05',
  '\v',
  '\n',
  '\x0F',
  '\x04',
  '\x02',
  '\a',
  '\f',
  '\t',
  '\x05',
  '\x06',
  '\x01',
  '\r',
  '\x0E',
  '\0',
  '\v',
  '\x03',
  '\b',
  '\t',
  '\x0E',
  '\x0F',
  '\x05',
  '\x02',
  '\b',
  '\f',
  '\x03',
  '\a',
  '\0',
  '\x04',
  '\n',
  '\x01',
  '\r',
  '\v',
  '\x06',
  '\x04',
  '\x03',
  '\x02',
  '\f',
  '\t',
  '\x05',
  '\x0F',
  '\n',
  '\v',
  '\x0E',
  '\x01',
  '\a',
  '\x06',
  '\0',
  '\b',
  '\r',
  '\x04',
  '\v',
  '\x02',
  '\x0E',
  '\x0F',
  '\0',
  '\b',
  '\r',
  '\x03',
  '\f',
  '\t',
  '\a',
  '\x05',
  '\n',
  '\x06',
  '\x01',
  '\r',
  '\0',
  '\v',
  '\a',
  '\x04',
  '\t',
  '\x01',
  '\n',
  '\x0E',
  '\x03',
  '\x05',
  '\f',
  '\x02',
  '\x0F',
  '\b',
  '\x06',
  '\x01',
  '\x04',
  '\v',
  '\r',
  '\f',
  '\x03',
  '\a',
  '\x0E',
  '\n',
  '\x0F',
  '\x06',
  '\b',
  '\0',
  '\x05',
  '\t',
  '\x02',
  '\x06',
  '\v',
  '\r',
  '\b',
  '\x01',
  '\x04',
  '\n',
  '\a',
  '\t',
  '\x05',
  '\0',
  '\x0F',
  '\x0E',
  '\x02',
  '\x03',
  '\f',
  '\r',
  '\x02',
  '\b',
  '\x04',
  '\x06',
  '\x0F',
  '\v',
  '\x01',
  '\n',
  '\t',
  '\x03',
  '\x0E',
  '\x05',
  '\0',
  '\f',
  '\a',
  '\x01',
  '\x0F',
  '\r',
  '\b',
  '\n',
  '\x03',
  '\a',
  '\x04',
  '\f',
  '\x05',
  '\x06',
  '\v',
  '\0',
  '\x0E',
  '\t',
  '\x02',
  '\a',
  '\v',
  '\x04',
  '\x01',
  '\t',
  '\f',
  '\x0E',
  '\x02',
  '\0',
  '\x06',
  '\n',
  '\r',
  '\x0F',
  '\x03',
  '\x05',
  '\b',
  '\x02',
  '\x01',
  '\x0E',
  '\a',
  '\x04',
  '\n',
  '\b',
  '\r',
  '\x0F',
  '\f',
  '\t',
  '\0',
  '\x03',
  '\x05',
  '\x06',
  '\v'
}; // idb
char byte_43C418[32] =
{
  '\x10',
  '\a',
  '\x14',
  '\x15',
  '\x1D',
  '\f',
  '\x1C',
  '\x11',
  '\x01',
  '\x0F',
  '\x17',
  '\x1A',
  '\x05',
  '\x12',
  '\x1F',
  '\n',
  '\x02',
  '\b',
  '\x18',
  '\x0E',
  ' ',
  '\x1B',
  '\x03',
  '\t',
  '\x13',
  '\r',
  '\x1E',
  '\x06',
  '\x16',
  '\v',
  '\x04',
  '\x19'
}; // idb
int bytebit[8] = { 128, 64, 32, 16, 8, 4, 2, 1 }; // idb
int nibblebit[4] = { 8, 4, 2, 1 }; // idb
int g_nEnable = 1;
LONG Target = 1; // idb
int g_nAllocBuffer = -1;
int color[3] = { 16711680, 0, 255 }; // idb
tagRECT g_rtCreate[4] =
{
  { 257064, 257961, 257381, 258397 },
  { 256806, 259175, 257135, 259598 },
  { 257135, 259191, 257590, 259562 },
  { 257590, 259203, 257907, 259573 }
};
int g_denoHP_0[3] = { 10, 14, 13 }; // idb
int g_denoMP_0[3] = { 13, 10, 12 }; // idb
int dword_43C4D8[] = { 18 }; // weak
int (*off_43D2A4)(void) = &__pInconsistency; // weak
CHAR buf[80] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
BYTE UserName = 0u; // idb
SQLCHAR Destination[64] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
CDBConnect *g_pool = NULL;
SQLHANDLE EnvironmentHandle = NULL; // idb
LONG Addend = 0; // idb
CIOSpinLock g_lock = { 0 };
unsigned int CDBConfig::s_nSystem = 0u;
unsigned int dword_43D974 = 0u;
u_short nPort = 0u; // idb
int dword_43D97C = 0; // weak
int dword_43D980 = 0; // weak
int CDBConfig::s_nNumberOfThreads = 0;
_DWORD CDBConfig::s_strODBC[7] = { 0, 0, 0, 0, 0, 0, 0 }; // idb
_DWORD CDBConfig::s_strMailServer[7] = { 0, 0, 0, 0, 0, 0, 0 }; // idb
_DWORD CDBConfig::s_strMailFrom[7] = { 0, 0, 0, 0, 0, 0, 0 }; // idb
_DWORD CDBConfig::s_strMailTo[7] = { 0, 0, 0, 0, 0, 0, 0 }; // idb
_DWORD CDBConfig::s_vSubNet[4] = { 0, 0, 0, 0 }; // idb
_DWORD dword_43DA08[4] = { 0, 0, 0, 0 }; // idb
HANDLE hHandle = NULL; // idb
CHAR ClassName[104] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
CHAR WindowName[100] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
HINSTANCE hInstance = NULL; // idb
char byte_43DAF0[96] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_43DB50[4096] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb
char byte_43EB50[4096]; // idb
char byte_43FB50[4096]; // idb
char byte_440B50[4096]; // idb
char byte_441B50[4096]; // idb
char fperm[16][16][8];
char iperm[16][16][8];
char byte_443B4F[]; // weak
char pcr[56]; // idb
char pc1m[56];
unsigned int g_dwStackTop;
unsigned int g_dwStack;
LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter; // idb
char g_szDumpPath[260];
CHAR body[260]; // idb
__time32_t Time; // idb
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
char *host; // idb
const char *g_szMailFrom;
const char *g_szMailTo;
CIOException::CInit unk_443E04; // idb
int BeenHere;
void *nThread; // idb
void *g_nThreadId;
void **g_hThread;
DWORD nCount; // idb
int dword_443E20[64]; // idb
HANDLE Handles[64]; // idb
int dword_444020; // weak
HANDLE hEvent; // idb
int g_nTerminating;
int CIOSocket::s_nRunningThread;
HANDLE CompletionPort; // idb
LONG dword_444034; // idb
CIOCriticalSection stru_444038; // idb
_UNKNOWN unk_444058; // weak
_UNKNOWN unk_44405C; // weak
CIOSocket::CIOTimerInstance g_instance;
_DWORD dword_444080[32]; // idb
lisp::var lisp::nil;
_UNKNOWN unk_444104; // weak
unsigned int g_nNext[3];
FILE *stream; // idb
CScreen *CScreen::s_pScreen;
CLog::CInit unk_444154; // idb
LONG dword_444158; // idb
CMemory *g_pMemory[16];
CScreen *stru_4441A4;
int CSocket::s_nIID;
int g_nCreate;
_UNKNOWN g_syncPacket; // weak
int dword_448DE0; // weak
LONG dword_448DE4; // idb
CScreen CStatus::s_screen;
unsigned int CDBConfig::s_nEvent;
char byte_448E28[256]; // idb
LONG dword_448F28; // idb
int dword_448F2C[]; // weak
int dword_448F30[32]; // idb
int dword_448FB0; // weak
int dword_448FDC; // weak


//----- (00401000) --------------------------------------------------------
void __thiscall CConfig::CConfig(CConfig *this)
{
  lisp::var::var(&this->m_root.m_pObject);
  this->m_fp = 0;
}

//----- (00401030) --------------------------------------------------------
void __thiscall CConfig::~CConfig(CConfig *this)
{
  CConfig::Close(this);
}

//----- (00401050) --------------------------------------------------------
void __thiscall CConfig::Close(CConfig *this)
{
  int v1; // ecx
  int v2; // [esp-4h] [ebp-10h]

  if ( this->m_fp )
  {
    fclose(this->m_fp);
    this->m_fp = 0;
  }
  std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&this->m_root);
  free_var((lisp::var)&this->m_root);
  v2 = v1;
  std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&lisp::nil);
  lisp::var::operator=(&this->m_root.m_pObject, v2);
}
// 4010A0: variable 'v1' is possibly undefined
// 401F90: using guessed type _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD);

//----- (004010C0) --------------------------------------------------------
void __cdecl free_var(lisp::var v)
{
  int v1; // eax
  lisp::_object *v2; // ecx
  int v3; // eax
  lisp::_object *v4; // ecx
  char *v5; // eax
  lisp::var v6; // [esp-4h] [ebp-1Ch]
  lisp::var v7; // [esp-4h] [ebp-1Ch]
  lisp::_object *v8; // [esp+14h] [ebp-4h]

  if ( (unsigned __int8)lisp::var::consp(&v) )
  {
    v1 = lisp::var::stringp(&v);
    v6.m_pObject = v2;
    std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(v1);
    free_var(v6);
    v3 = lisp::var::integerp(&v);
    v7.m_pObject = v4;
    std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(v3);
    free_var(v7);
    operator delete((int)v.m_pObject);
  }
  else if ( (unsigned __int8)lisp::var::car(&v) )
  {
    v8 = v.m_pObject;
    v5 = (char *)v.m_pObject->GetString(v.m_pObject);
    CMemory::_free(v5);
    operator delete((int)v8);
  }
  else if ( (unsigned __int8)lisp::var::cdr(&v) )
  {
    operator delete((int)v.m_pObject);
  }
}
// 4010DD: variable 'v2' is possibly undefined
// 4010F6: variable 'v4' is possibly undefined
// 401F90: using guessed type _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD);

//----- (00401180) --------------------------------------------------------
Token __thiscall CConfig::GetToken(CConfig *this)
{
  Token result; // eax
  int v2; // [esp+10h] [ebp-14h]
  int C; // [esp+1Ch] [ebp-8h]
  int Ca; // [esp+1Ch] [ebp-8h]
  int Cb; // [esp+1Ch] [ebp-8h]
  int Cc; // [esp+1Ch] [ebp-8h]
  int Cd; // [esp+1Ch] [ebp-8h]
  CConfig *v9; // [esp+20h] [ebp-4h]
  char *i; // [esp+20h] [ebp-4h]

  while ( 2 )
  {
    C = fgetc(this->m_fp);
    switch ( C )
    {
      case -1:
        return 0;
      case 9:
      case 13:
      case 32:
        continue;
      case 10:
        ++this->m_nLine;
        return 3;
      case 34:
        v9 = this;
        while ( 2 )
        {
          Ca = fgetc(this->m_fp);
          switch ( Ca )
          {
            case -1:
              return 0;
            case 10:
              ++this->m_nLine;
              return 3;
            case 13:
              continue;
            case 34:
              Cb = fgetc(this->m_fp);
              if ( Cb == -1 )
              {
                v9->m_szSymbol[0] = 0;
                return 2;
              }
              if ( Cb == 34 )
              {
                v9->m_szSymbol[0] = 34;
                v9 = (CConfig *)((char *)v9 + 1);
                continue;
              }
              break;
            default:
              v9->m_szSymbol[0] = Ca;
              v9 = (CConfig *)((char *)v9 + 1);
              continue;
          }
          break;
        }
        goto LABEL_19;
      case 39:
        v9 = this;
        while ( 2 )
        {
          Cc = fgetc(this->m_fp);
          switch ( Cc )
          {
            case -1:
              return 0;
            case 10:
              ++this->m_nLine;
              return 3;
            case 13:
              continue;
            case 39:
              Cb = fgetc(this->m_fp);
              if ( Cb == -1 )
              {
                v9->m_szSymbol[0] = 0;
                result = T_STRING;
              }
              else
              {
                if ( Cb == 39 )
                {
                  v9->m_szSymbol[0] = 39;
                  v9 = (CConfig *)((char *)v9 + 1);
                  continue;
                }
LABEL_19:
                ungetc_0(Cb, this->m_fp);
                v9->m_szSymbol[0] = 0;
                result = T_STRING;
              }
              break;
            default:
              v9->m_szSymbol[0] = Cc;
              v9 = (CConfig *)((char *)v9 + 1);
              continue;
          }
          break;
        }
        return result;
      case 40:
        return 7;
      case 41:
        return 8;
      case 44:
        return 5;
      case 58:
        return 6;
      case 59:
        do
        {
          v2 = fgetc(this->m_fp);
          if ( v2 == -1 )
            return 0;
        }
        while ( v2 != 10 );
        ++this->m_nLine;
        return 3;
      case 61:
        return 4;
      default:
        if ( isalnum(C) || C == 45 )
        {
          this->m_szSymbol[0] = C;
          for ( i = &this->m_szSymbol[1]; ; ++i )
          {
            Cd = fgetc(this->m_fp);
            if ( Cd == -1 )
              goto LABEL_41;
            if ( !isalnum(Cd) )
              break;
            *i = Cd;
          }
          ungetc_0(Cd, this->m_fp);
LABEL_41:
          *i = 0;
          return 1;
        }
        return 9;
    }
  }
}

//----- (004015F0) --------------------------------------------------------
lisp::var *__thiscall CConfig::Find(CConfig *this, lisp::var *result, const char *key)
{
  lisp::var *v3; // eax
  _DWORD *v4; // eax
  const char *v5; // eax
  int v6; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // [esp-4h] [ebp-10h]
  lisp::var v11; // [esp+8h] [ebp-4h] BYREF

  std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&this->m_root);
  while ( !(unsigned __int8)lisp::var::null(&v11) )
  {
    v3 = (lisp::var *)lisp::var::stringp(&v11);
    v4 = (_DWORD *)lisp::var::stringp(v3);
    v5 = (const char *)lisp::var::operator char const *(v4);
    if ( !_stricmp(v5, key) )
    {
      v6 = lisp::var::stringp(&v11);
      std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(v6);
      return result;
    }
    v8 = lisp::var::integerp(&v11);
    v10 = v9;
    std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(v8);
    lisp::var::operator=(&v11, v10);
  }
  std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&lisp::nil);
  return result;
}
// 40165E: variable 'v9' is possibly undefined
// 401F90: using guessed type _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD);

//----- (00401690) --------------------------------------------------------
lisp::var *__thiscall CConfig::GetValue(CConfig *this, lisp::var *result)
{
  char *v2; // eax
  lisp::var *v3; // eax
  _DWORD *v4; // [esp+0h] [ebp-20h]
  CMemory **v6; // [esp+8h] [ebp-18h]
  Token v7; // [esp+10h] [ebp-10h]

  do
    v7 = CConfig::GetToken(this);
  while ( v7 == T_NEWLINE );
  if ( v7 == T_VARIABLE || v7 == T_STRING )
  {
    v6 = operator new(8u);
    if ( v6 )
    {
      v2 = Strdup(this->m_szSymbol);
      v4 = lisp::_string::_string(v6, (int)v2);
    }
    else
    {
      v4 = 0;
    }
    unknown_libname_13(v4);
    v3 = result;
  }
  else
  {
    if ( v7 == T_OPEN )
    {
      CConfig::GetList(this, result);
    }
    else
    {
      this->m_token = v7;
      std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&lisp::nil);
    }
    v3 = result;
  }
  return v3;
}
// 401F90: using guessed type _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD);
// 404820: using guessed type _DWORD __stdcall unknown_libname_13(_DWORD);

//----- (00401770) --------------------------------------------------------
char *__cdecl Strdup(const char *str)
{
  CMemory **v1; // eax
  size_t v3; // [esp-4h] [ebp-8h]

  v3 = strlen(str) + 1;
  v1 = CMemory::_malloc(v3);
  return (char *)memcpy(v1, str, v3);
}

//----- (004017B0) --------------------------------------------------------
lisp::var *__thiscall CConfig::GetList(CConfig *this, lisp::var *result)
{
  lisp::var *v2; // eax
  lisp::_object *v3; // ecx
  lisp::_object *v4; // ecx
  int v5; // ecx
  int v6; // [esp-8h] [ebp-44h] BYREF
  lisp::var v7; // [esp-4h] [ebp-40h] BYREF
  _DWORD *v8; // [esp+0h] [ebp-3Ch]
  _DWORD *v9; // [esp+4h] [ebp-38h]
  CConfig *v10; // [esp+8h] [ebp-34h]
  int *v11; // [esp+Ch] [ebp-30h]
  lisp::var *v12; // [esp+10h] [ebp-2Ch]
  CMemory **v13; // [esp+14h] [ebp-28h]
  _DWORD *v14; // [esp+18h] [ebp-24h]
  lisp::var *v15; // [esp+1Ch] [ebp-20h]
  CMemory **v16; // [esp+20h] [ebp-1Ch]
  _DWORD *v17; // [esp+24h] [ebp-18h]
  lisp::var v18; // [esp+28h] [ebp-14h] BYREF
  lisp::var v19; // [esp+2Ch] [ebp-10h] BYREF
  int v20; // [esp+38h] [ebp-4h]

  v10 = this;
  CConfig::GetValue(this, &v19);
  if ( (unsigned __int8)lisp::var::null(&v19) )
  {
    if ( v10->m_token == T_CLOSE )
    {
      std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&lisp::nil);
      v2 = result;
    }
    else
    {
      v16 = operator new(8u);
      v20 = 0;
      if ( v16 )
        v9 = lisp::_integer::_integer(v16, v10->m_token);
      else
        v9 = 0;
      v17 = v9;
      v20 = -1;
      unknown_libname_13(v9);
      v2 = result;
    }
  }
  else
  {
    CConfig::GetList(v10, &v18);
    if ( (unsigned __int8)lisp::var::cdr(&v18) )
    {
      v7.m_pObject = v3;
      v15 = &v7;
      std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&v19);
      free_var(v7);
      std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&v18);
      v2 = result;
    }
    else
    {
      v13 = operator new(0xCu);
      v20 = 1;
      if ( v13 )
      {
        v7.m_pObject = v4;
        v12 = &v7;
        std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&v18);
        v6 = v5;
        v11 = &v6;
        std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&v19);
        v8 = lisp::_cons::_cons(v13, v6, (char)v7.m_pObject);
      }
      else
      {
        v8 = 0;
      }
      v14 = v8;
      v20 = -1;
      unknown_libname_13(v8);
      v2 = result;
    }
  }
  return v2;
}
// 40187E: variable 'v3' is possibly undefined
// 4018C0: variable 'v4' is possibly undefined
// 4018CF: variable 'v5' is possibly undefined
// 401F90: using guessed type _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD);
// 404820: using guessed type _DWORD __stdcall unknown_libname_13(_DWORD);

//----- (00401920) --------------------------------------------------------
int __thiscall CConfig::Open(CConfig *this, const char *szFilename)
{
  lisp::_object *v3; // ecx
  lisp::_object *v4; // ecx
  char *v5; // eax
  lisp::_object *v6; // ecx
  lisp::var *v7; // eax
  lisp::_object *v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // [esp-8h] [ebp-88h] BYREF
  lisp::var v12; // [esp-4h] [ebp-84h] BYREF
  _DWORD *v13; // [esp+0h] [ebp-80h]
  lisp::_object *v14; // [esp+4h] [ebp-7Ch]
  lisp::_object *v15; // [esp+8h] [ebp-78h]
  _DWORD *v16; // [esp+Ch] [ebp-74h]
  int v17; // [esp+10h] [ebp-70h]
  void *Src; // [esp+14h] [ebp-6Ch]
  lisp::var *v19; // [esp+18h] [ebp-68h]
  CMemory **v20; // [esp+1Ch] [ebp-64h]
  lisp::_object *v21; // [esp+20h] [ebp-60h]
  int *v22; // [esp+24h] [ebp-5Ch]
  lisp::var *v23; // [esp+28h] [ebp-58h]
  CMemory **v24; // [esp+2Ch] [ebp-54h]
  lisp::_object *v25; // [esp+30h] [ebp-50h]
  int *v26; // [esp+34h] [ebp-4Ch]
  lisp::var *v27; // [esp+38h] [ebp-48h]
  CMemory **v28; // [esp+3Ch] [ebp-44h]
  _DWORD *v29; // [esp+40h] [ebp-40h]
  lisp::var *v30; // [esp+44h] [ebp-3Ch]
  lisp::var result; // [esp+48h] [ebp-38h] BYREF
  lisp::var *v32; // [esp+4Ch] [ebp-34h]
  lisp::var *v33; // [esp+50h] [ebp-30h]
  CMemory **v34; // [esp+54h] [ebp-2Ch]
  _DWORD *v35; // [esp+58h] [ebp-28h]
  lisp::var *v36; // [esp+5Ch] [ebp-24h]
  lisp::var v37; // [esp+60h] [ebp-20h] BYREF
  lisp::var *v38; // [esp+64h] [ebp-1Ch]
  char *String2; // [esp+68h] [ebp-18h]
  int v40; // [esp+6Ch] [ebp-14h]
  char v41[4]; // [esp+70h] [ebp-10h] BYREF
  int v42; // [esp+7Ch] [ebp-4h]

  Src = this;
  this->m_fp = fopen(szFilename, "rb");
  if ( !*((_DWORD *)Src + 128) )
  {
    LOG_ERR("'%s' File open failed at CConfig::Open", szFilename);
    return 0;
  }
  lisp::var::var(v41);
  v38 = (lisp::var *)((char *)Src + 520);
  *((_DWORD *)Src + 129) = 1;
  while ( 1 )
  {
    v40 = CConfig::GetToken((CConfig *)Src);
    v17 = v40;
    if ( !v40 )
      break;
    if ( v17 == 1 )
    {
      String2 = Strdup((const char *)Src);
      v40 = CConfig::GetToken((CConfig *)Src);
      if ( v40 != 4 )
        goto invalid;
      v40 = CConfig::GetToken((CConfig *)Src);
      lisp::var::var(&v37);
      if ( v40 == 1 || v40 == 2 )
      {
        v34 = operator new(8u);
        v42 = 0;
        if ( v34 )
        {
          v5 = Strdup((const char *)Src);
          v16 = lisp::_string::_string(v34, (int)v5);
        }
        else
        {
          v16 = 0;
        }
        v35 = v16;
        v42 = -1;
        v12.m_pObject = v4;
        v36 = &v12;
        unknown_libname_13(v16);
        lisp::var::operator=(&v37, (int)v12.m_pObject);
      }
      else
      {
        if ( v40 != 7 )
          goto invalid;
        v12.m_pObject = v3;
        v33 = &v12;
        CConfig::GetList((CConfig *)Src, &v12);
        lisp::var::operator=(&v37, (int)v12.m_pObject);
        if ( (unsigned __int8)lisp::var::cdr(&v37) )
        {
          v40 = lisp::var::operator int(&v37);
          v12.m_pObject = v6;
          v32 = &v12;
          std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&v37);
          free_var(v12);
invalid:
          LOG_ERR("Invalid format %s(%d) at CConfig::Open", szFilename, *((_DWORD *)Src + 129));
          CMemory::_free(String2);
          goto LABEL_34;
        }
      }
      v7 = CConfig::Find((CConfig *)Src, &result, String2);
      if ( (unsigned __int8)lisp::var::null(v7) )
      {
        v28 = operator new(0xCu);
        v42 = 1;
        if ( v28 )
        {
          v24 = operator new(0xCu);
          LOBYTE(v42) = 2;
          if ( v24 )
          {
            v20 = operator new(8u);
            LOBYTE(v42) = 3;
            if ( v20 )
              v15 = (lisp::_object *)lisp::_string::_string(v20, (int)String2);
            else
              v15 = 0;
            v21 = v15;
            LOBYTE(v42) = 2;
            v12.m_pObject = v15;
            v23 = &v12;
            std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&v37);
            v11 = v9;
            v22 = &v11;
            unknown_libname_13(v21);
            v14 = (lisp::_object *)lisp::_cons::_cons(v24, v11, (char)v12.m_pObject);
          }
          else
          {
            v14 = 0;
          }
          v25 = v14;
          LOBYTE(v42) = 1;
          v12.m_pObject = v14;
          v27 = &v12;
          std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&lisp::nil);
          v11 = v10;
          v26 = &v11;
          unknown_libname_13(v25);
          v13 = lisp::_cons::_cons(v28, v11, (char)v12.m_pObject);
        }
        else
        {
          v13 = 0;
        }
        v29 = v13;
        v42 = -1;
        v12.m_pObject = v8;
        v30 = &v12;
        unknown_libname_13(v13);
        lisp::var::operator=(v38, (int)v12.m_pObject);
        v38 = (lisp::var *)lisp::var::integerp(v38);
      }
      else
      {
        LOG_ERR("Duplicate key %s(%d) at CConfig::Open", szFilename, *((_DWORD *)Src + 129));
        CMemory::_free(String2);
        v19 = &v12;
        std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&v37);
        free_var(v12);
      }
LABEL_34:
      while ( v40 != 3 && v40 )
        v40 = CConfig::GetToken((CConfig *)Src);
    }
    else if ( v17 != 3 )
    {
      LOG_ERR("Invalid format %s(%d) at CConfig::Open", szFilename, *((_DWORD *)Src + 129));
    }
  }
  fclose(*((FILE **)Src + 128));
  *((_DWORD *)Src + 128) = 0;
  return 1;
}
// 401A59: variable 'v4' is possibly undefined
// 401A78: variable 'v3' is possibly undefined
// 401AA9: variable 'v6' is possibly undefined
// 401B6B: variable 'v9' is possibly undefined
// 401BA8: variable 'v10' is possibly undefined
// 401BD8: variable 'v8' is possibly undefined
// 401F90: using guessed type _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD);
// 404820: using guessed type _DWORD __stdcall unknown_libname_13(_DWORD);

//----- (00401CE0) --------------------------------------------------------
const char *__thiscall CConfig::Get(CConfig *this, const char *key)
{
  lisp::var *v2; // eax
  _DWORD *v3; // eax
  lisp::var result; // [esp+4h] [ebp-4h] BYREF

  v2 = CConfig::Find(this, &result, key);
  v3 = (_DWORD *)lisp::var::integerp(v2);
  return (const char *)lisp::var::operator char const *(v3);
}

//----- (00401D10) --------------------------------------------------------
const char *__thiscall CConfig::Get(CConfig *this, const char *key, const char *defaultValue)
{
  _DWORD *v4; // eax
  lisp::var result; // [esp+4h] [ebp-4h] BYREF

  CConfig::Find(this, &result, key);
  if ( (unsigned __int8)lisp::var::null(&result) )
    return defaultValue;
  v4 = (_DWORD *)lisp::var::integerp(&result);
  return (const char *)lisp::var::operator char const *(v4);
}

//----- (00401D90) --------------------------------------------------------
int __thiscall CConfig::GetInt(CConfig *this, const char *key, int defaultValue)
{
  _DWORD *v4; // eax
  lisp::var result; // [esp+4h] [ebp-4h] BYREF

  CConfig::Find(this, &result, key);
  if ( (unsigned __int8)lisp::var::null(&result) )
    return defaultValue;
  v4 = (_DWORD *)lisp::var::integerp(&result);
  return lisp::var::operator int(v4);
}

//----- (00401F10) --------------------------------------------------------
unsigned int __cdecl CConfig::GetTimeStamp()
{
  unsigned int result; // eax
  HMODULE v1; // [esp+4h] [ebp-8h]
  _DWORD *v2; // [esp+8h] [ebp-4h]

  v1 = GetModuleHandleA(0);
  if ( !v1 )
    return 0;
  if ( *(_WORD *)v1 != 23117 )
    return 0;
  v2 = (_DWORD *)((char *)v1 + *((_DWORD *)v1 + 15));
  if ( *v2 == 17744 )
    result = v2[2];
  else
    result = 0;
  return result;
}

//----- (00401F70) --------------------------------------------------------
_DWORD *__thiscall lisp::var::var(_DWORD *this)
{
  *this = &unk_444104;
  return this;
}

//----- (00401FB0) --------------------------------------------------------
int __thiscall lisp::var::stringp(lisp::var *this)
{
  return ((int (__thiscall *)(lisp::_object *, lisp::var *))this->m_pObject->car)(this->m_pObject, this);
}

//----- (00401FD0) --------------------------------------------------------
int __thiscall lisp::var::integerp(lisp::var *this)
{
  return ((int (__thiscall *)(lisp::_object *, lisp::var *))this->m_pObject->cdr)(this->m_pObject, this);
}

//----- (00401FF0) --------------------------------------------------------
int __thiscall lisp::var::consp(lisp::var *this)
{
  return ((int (__thiscall *)(lisp::_object *, lisp::var *))this->m_pObject->consp)(this->m_pObject, this);
}

//----- (00402010) --------------------------------------------------------
lisp::var *__thiscall lisp::var::car(lisp::var *this)
{
  return (lisp::var *)((int (__thiscall *)(lisp::_object *, lisp::var *))this->m_pObject->stringp)(
                        this->m_pObject,
                        this);
}

//----- (00402030) --------------------------------------------------------
lisp::var *__thiscall lisp::var::cdr(lisp::var *this)
{
  return (lisp::var *)((int (__thiscall *)(lisp::_object *, lisp::var *))this->m_pObject->integerp)(
                        this->m_pObject,
                        this);
}

//----- (00402050) --------------------------------------------------------
int __thiscall lisp::var::operator char const *(_DWORD *this)
{
  return (**(int (__thiscall ***)(_DWORD, _DWORD *))*this)(*this, this);
}

//----- (00402070) --------------------------------------------------------
int __thiscall lisp::var::null(lisp::var *this)
{
  return ((int (__thiscall *)(lisp::_object *, lisp::var *))this->m_pObject->null)(this->m_pObject, this);
}

//----- (00402090) --------------------------------------------------------
_DWORD *__thiscall lisp::_string::_string(_DWORD *this, int a2)
{
  sub_4020E0(this);
  *this = off_42A420;
  this[1] = a2;
  return this;
}
// 42A420: using guessed type int (*off_42A420[20])();

//----- (004020C0) --------------------------------------------------------
const char *__thiscall lisp::_object::GetString(lisp::_object *this)
{
  return (const char *)&lisp::nil;
}

//----- (004020E0) --------------------------------------------------------
_DWORD *__thiscall sub_4020E0(_DWORD *this)
{
  *this = off_42A448;
  return this;
}
// 42A448: using guessed type int (*off_42A448[10])();

//----- (00402100) --------------------------------------------------------
void *sub_402100()
{
  return &unk_42A470;
}

//----- (00402120) --------------------------------------------------------
_DWORD *__thiscall lisp::_integer::_integer(_DWORD *this, int a2)
{
  sub_4020E0(this);
  *this = off_42A474;
  this[1] = a2;
  return this;
}
// 42A474: using guessed type int (*off_42A474[20])();

//----- (00402180) --------------------------------------------------------
_DWORD *__thiscall lisp::_cons::_cons(_DWORD *this, int a2, char a3)
{
  sub_4020E0(this);
  *this = off_42A49C;
  std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&a2);
  std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&a3);
  return this;
}
// 401F90: using guessed type _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD);
// 42A49C: using guessed type int (*off_42A49C[10])();

//----- (00402200) --------------------------------------------------------
int __thiscall lisp::var::operator int(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD, _DWORD *))(*(_DWORD *)*this + 4))(*this, this);
}

//----- (00402220) --------------------------------------------------------
CMemory **__cdecl operator new(size_t Size)
{
  return CMemory::_malloc(Size);
}

//----- (00402240) --------------------------------------------------------
void __cdecl operator delete(int a1)
{
  CMemory::_free((void *)a1);
}

//----- (00402260) --------------------------------------------------------
int __stdcall DialogProc(HWND__ *hwndDlg, unsigned int uMsg, unsigned int wParam, int lParam)
{
  if ( uMsg == 272 )
  {
    SetDlgItemTextA(hwndDlg, 1000, (LPCSTR)&UserName);
    SetDlgItemTextA(hwndDlg, 1001, buf);
    return 0;
  }
  if ( uMsg != 273 )
    return 0;
  if ( (unsigned __int16)wParam == 1 )
  {
    GetDlgItemTextA(hwndDlg, 1000, (LPSTR)&UserName, 79);
    GetDlgItemTextA(hwndDlg, 1001, buf, 79);
    EndDialog(hwndDlg, 1);
    return 1;
  }
  if ( (unsigned __int16)wParam != 2 )
    return 0;
  EndDialog(hwndDlg, 0);
  return 1;
}

//----- (00402330) --------------------------------------------------------
int __cdecl CDB::Open(const char *szServer)
{
  int v1; // eax
  HMODULE v3; // eax
  int v4; // eax
  size_t v5; // eax
  HWND v6; // [esp-Ch] [ebp-74h]
  SQLHANDLE OutputHandle; // [esp+0h] [ebp-68h] BYREF
  SQLRETURN v8; // [esp+4h] [ebp-64h]
  BYTE Data[80]; // [esp+8h] [ebp-60h] BYREF
  HKEY phkResult; // [esp+5Ch] [ebp-Ch] BYREF
  DWORD cbData; // [esp+60h] [ebp-8h] BYREF
  DWORD Type; // [esp+64h] [ebp-4h] BYREF

  OutputHandle = 0;
  SQLSetEnvAttr(0, 201, (SQLPOINTER)1, -6);
  v8 = SQLAllocHandle(1, 0, &EnvironmentHandle);
  if ( v8 && v8 == 1 )
  {
    LOG_ERR("Can't Get SQL HENV");
  }
  else
  {
    SQLSetEnvAttr(EnvironmentHandle, 200, (SQLPOINTER)3, 0);
    strcpy((char *)Destination, szServer);
    if ( SQLAllocHandle(2, EnvironmentHandle, &OutputHandle) == -1 )
    {
      LOG_ERR("Can't Allocate SQL Connection Handle");
    }
    else
    {
      if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\Inixsoft\\KALServer\\DBLogin", 0, 0x20019u, &phkResult) )
      {
        cbData = 80;
        RegQueryValueExA(phkResult, "Id", 0, &Type, &UserName, &cbData);
        cbData = 80;
        RegQueryValueExA(phkResult, "Password", 0, &Type, (LPBYTE)buf, &cbData);
        RegCloseKey(phkResult);
        DesKeyInit("rkakrnl");
        v1 = strlen(buf);
        buf[DesReadBlockEx(buf, v1)] = 0;
        if ( SQLConnect(OutputHandle, Destination, -3, &UserName, -3, (SQLCHAR *)buf, -3) != -1 )
        {
          SQLFreeHandle(2, OutputHandle);
          return 1;
        }
      }
      while ( 1 )
      {
        v6 = (HWND)*(&stru_4441A4 + 1);
        v3 = GetModuleHandleA(0);
        if ( !DialogBoxParamA(v3, (LPCSTR)0x81, v6, DialogProc, 0) )
          break;
        if ( SQLConnect(OutputHandle, Destination, -3, &UserName, -3, (SQLCHAR *)buf, -3) != -1 )
        {
          SQLFreeHandle(2, OutputHandle);
          if ( RegCreateKeyExA(
                 HKEY_LOCAL_MACHINE,
                 "Software\\Inixsoft\\KALServer\\DBLogin",
                 0,
                 (LPSTR)Class,
                 0,
                 0x20006u,
                 0,
                 &phkResult,
                 0) )
          {
            LOG_ERR("can't create registry key");
            break;
          }
          strcpy((char *)Data, buf);
          DesKeyInit("rkakrnl");
          v4 = strlen((const char *)Data);
          cbData = DesWriteBlockEx(Data, v4);
          v5 = strlen((const char *)&UserName);
          RegSetValueExA(phkResult, "Id", 0, 1u, &UserName, v5 + 1);
          RegSetValueExA(phkResult, "Password", 0, 3u, Data, cbData);
          RegCloseKey(phkResult);
          return 1;
        }
      }
    }
  }
  if ( OutputHandle )
    SQLFreeHandle(2, OutputHandle);
  if ( EnvironmentHandle )
  {
    SQLFreeHandle(1, EnvironmentHandle);
    EnvironmentHandle = 0;
  }
  return 0;
}

//----- (00402630) --------------------------------------------------------
void __stdcall CDB::Close()
{
  CDBConnect *v0; // [esp+Ch] [ebp-4h]

  CIOSpinLock::Enter(&g_lock.lock);
  while ( g_pool )
  {
    v0 = g_pool;
    g_pool = g_pool->m_pNext;
    if ( v0 )
      CDBConnect::`scalar deleting destructor'(&v0->m_hStmt, 1);
  }
  CIOSpinLock::Leave(&g_lock.lock);
  if ( EnvironmentHandle )
  {
    SQLFreeHandle(1, EnvironmentHandle);
    EnvironmentHandle = 0;
  }
}

//----- (004026C0) --------------------------------------------------------
CDB *__thiscall CDB::CDB(CDB *this)
{
  this->m_pDBConnect = CDBConnect::Alloc();
  this->m_hStmt = this->m_pDBConnect->m_hStmt;
  this->m_nBind = 0;
  return this;
}

//----- (004026F0) --------------------------------------------------------
void __thiscall CDB::~CDB(CDB *this)
{
  SQLFreeStmt(this->m_hStmt, 2u);
  SQLFreeStmt(this->m_hStmt, 0);
  SQLFreeStmt(this->m_hStmt, 3u);
  CDBConnect::Free(&this->m_pDBConnect->m_hStmt);
}

//----- (00402730) --------------------------------------------------------
int CDB::Execute(CDB *this, const char *format, ...)
{
  int result; // eax
  SQLRETURN v3; // [esp+Ch] [ebp-64Ch]
  SQLCHAR MessageText[519]; // [esp+10h] [ebp-648h] BYREF
  SQLCHAR StatementText[1028]; // [esp+218h] [ebp-440h] BYREF
  SQLINTEGER TextLength; // [esp+61Ch] [ebp-3Ch]
  SQLSMALLINT v7; // [esp+620h] [ebp-38h] BYREF
  char v8[4]; // [esp+624h] [ebp-34h]
  SQLCHAR Sqlstate[8]; // [esp+628h] [ebp-30h] BYREF
  va_list ArgList; // [esp+634h] [ebp-24h]
  SQLINTEGER NativeError; // [esp+638h] [ebp-20h] BYREF
  DWORD v12; // [esp+63Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+640h] [ebp-18h]
  va_list va; // [esp+668h] [ebp+10h] BYREF

  va_start(va, format);
  va_copy(ArgList, va);
  TextLength = 1024;
  StatementText[1023] = 0;
  TextLength = _vsnprintf((char *const)StatementText, 0x3FFu, format, va);
  if ( TextLength == -1 )
  {
    ArgList = 0;
    EBREAK();
    result = 0;
  }
  else
  {
    ArgList = 0;
    v12 = GetTickCount();
    InterlockedIncrement(&Addend);
    ms_exc.registration.TryLevel = 0;
    v3 = SQLExecDirect(this->m_hStmt, StatementText, TextLength);
    ms_exc.registration.TryLevel = -1;
    InterlockedDecrement(&Addend);
    *(_DWORD *)v8 = GetTickCount() - v12;
    if ( *(_DWORD *)v8 > (unsigned int)dword_43C0A0 )
      LOG_NORMAL("SQLExecDirect() delayed(%d). '%s'", *(_DWORD *)v8, (const char *)StatementText);
    if ( v3 )
    {
      if ( (SQLGetDiagRec(3, this->m_hStmt, 1, Sqlstate, &NativeError, MessageText, 513, &v7) & 0xFFFFFFFE) != 0 )
      {
        LOG_ERR("SQL:%s:%d", (const char *)StatementText, v3);
      }
      else
      {
        LOG_ERR("SQL:%s:%s:%s", (const char *)StatementText, (const char *)Sqlstate, (const char *)MessageText);
        if ( !strcmp((const char *)Sqlstate, "08S01") )
        {
          LOG_ERR("SQL Disconnected");
          PostMessageA((HWND)*(&stru_4441A4 + 1), 0x111u, 0x8009u, 0);
        }
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 43C0A0: using guessed type int dword_43C0A0;

//----- (00402960) --------------------------------------------------------
__int16 CDB::ExecuteInsertUnique(CDB *this, const char *format, ...)
{
  SQLRETURN v3; // [esp+0h] [ebp-634h]
  SQLCHAR MessageText[519]; // [esp+4h] [ebp-630h] BYREF
  SQLCHAR StatementText[1028]; // [esp+20Ch] [ebp-428h] BYREF
  SQLINTEGER TextLength; // [esp+610h] [ebp-24h]
  SQLSMALLINT v7; // [esp+614h] [ebp-20h] BYREF
  char v8[4]; // [esp+618h] [ebp-1Ch]
  SQLCHAR Sqlstate[8]; // [esp+61Ch] [ebp-18h] BYREF
  va_list ArgList; // [esp+628h] [ebp-Ch]
  SQLINTEGER NativeError; // [esp+62Ch] [ebp-8h] BYREF
  DWORD v12; // [esp+630h] [ebp-4h]
  va_list va; // [esp+644h] [ebp+10h] BYREF

  va_start(va, format);
  va_copy(ArgList, va);
  TextLength = 1024;
  StatementText[1023] = 0;
  TextLength = _vsnprintf((char *const)StatementText, 0x3FFu, format, va);
  if ( TextLength == -1 )
  {
    ArgList = 0;
    EBREAK();
    return -1;
  }
  ArgList = 0;
  v12 = GetTickCount();
  InterlockedIncrement(&Addend);
  v3 = SQLExecDirect(this->m_hStmt, StatementText, TextLength);
  InterlockedDecrement(&Addend);
  *(_DWORD *)v8 = GetTickCount() - v12;
  if ( *(_DWORD *)v8 > (unsigned int)dword_43C0A0 )
    LOG_NORMAL("SQLExecDirect() delayed(%d). '%s'", *(_DWORD *)v8, (const char *)StatementText);
  if ( !v3 )
    return 0;
  if ( (SQLGetDiagRec(3, this->m_hStmt, 1, Sqlstate, &NativeError, MessageText, 513, &v7) & 0xFFFFFFFE) != 0 )
  {
    LOG_ERR("SQL:%s:%d", (const char *)StatementText, v3);
  }
  else
  {
    if ( !strcmp((const char *)Sqlstate, "23000") )
      return 1;
    LOG_ERR("SQL:%s:%s:%s", (const char *)StatementText, (const char *)Sqlstate, (const char *)MessageText);
    if ( !strcmp((const char *)Sqlstate, "08S01") )
    {
      LOG_ERR("SQL Disconnected");
      PostMessageA((HWND)*(&stru_4441A4 + 1), 0x111u, 0x8009u, 0);
    }
  }
  return -1;
}
// 43C0A0: using guessed type int dword_43C0A0;

//----- (00402B20) --------------------------------------------------------
int CDB::ExecuteNoData(CDB *this, const char *format, ...)
{
  int result; // eax
  SQLRETURN v3; // [esp+0h] [ebp-634h]
  SQLCHAR MessageText[519]; // [esp+4h] [ebp-630h] BYREF
  SQLCHAR StatementText[1028]; // [esp+20Ch] [ebp-428h] BYREF
  SQLINTEGER TextLength; // [esp+610h] [ebp-24h]
  SQLSMALLINT v7; // [esp+614h] [ebp-20h] BYREF
  char v8[4]; // [esp+618h] [ebp-1Ch]
  SQLCHAR Sqlstate[8]; // [esp+61Ch] [ebp-18h] BYREF
  va_list ArgList; // [esp+628h] [ebp-Ch]
  SQLINTEGER NativeError; // [esp+62Ch] [ebp-8h] BYREF
  DWORD v12; // [esp+630h] [ebp-4h]
  va_list va; // [esp+644h] [ebp+10h] BYREF

  va_start(va, format);
  va_copy(ArgList, va);
  TextLength = 1024;
  StatementText[1023] = 0;
  TextLength = _vsnprintf((char *const)StatementText, 0x3FFu, format, va);
  if ( TextLength == -1 )
  {
    ArgList = 0;
    EBREAK();
    result = 0;
  }
  else
  {
    ArgList = 0;
    v12 = GetTickCount();
    InterlockedIncrement(&Addend);
    v3 = SQLExecDirect(this->m_hStmt, StatementText, TextLength);
    InterlockedDecrement(&Addend);
    *(_DWORD *)v8 = GetTickCount() - v12;
    if ( *(_DWORD *)v8 > (unsigned int)dword_43C0A0 )
      LOG_NORMAL("SQLExecDirect() delayed(%d). '%s'", *(_DWORD *)v8, (const char *)StatementText);
    if ( v3 )
    {
      if ( v3 == 100 )
      {
        result = 0;
      }
      else
      {
        if ( (SQLGetDiagRec(3, this->m_hStmt, 1, Sqlstate, &NativeError, MessageText, 513, &v7) & 0xFFFFFFFE) != 0 )
        {
          LOG_ERR("SQL:%s:%d", (const char *)StatementText, v3);
        }
        else
        {
          LOG_ERR("SQL:%s:%s:%s", (const char *)StatementText, (const char *)Sqlstate, (const char *)MessageText);
          if ( !strcmp((const char *)Sqlstate, "08S01") )
          {
            LOG_ERR("SQL Disconnected");
            PostMessageA((HWND)*(&stru_4441A4 + 1), 0x111u, 0x8009u, 0);
          }
        }
        result = 0;
      }
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 43C0A0: using guessed type int dword_43C0A0;

//----- (00402CE0) --------------------------------------------------------
int __thiscall CDB::Fetch(CDB *this)
{
  SQLRETURN v3; // [esp+4h] [ebp-224h]
  SQLCHAR MessageText[524]; // [esp+8h] [ebp-220h] BYREF
  SQLSMALLINT TextLength; // [esp+214h] [ebp-14h] BYREF
  SQLCHAR Sqlstate[8]; // [esp+218h] [ebp-10h] BYREF
  SQLINTEGER NativeError; // [esp+224h] [ebp-4h] BYREF

  InterlockedIncrement(&Addend);
  v3 = SQLFetch(this->m_hStmt);
  InterlockedDecrement(&Addend);
  if ( (v3 & 0xFFFFFFFE) == 0 )
    return 1;
  if ( v3 == 100 )
    return 0;
  if ( (SQLGetDiagRec(3, this->m_hStmt, 1, Sqlstate, &NativeError, MessageText, 513, &TextLength) & 0xFFFFFFFE) == 0 )
    LOG_ERR("SQL Fetch Error:%s:%s", (const char *)Sqlstate, (const char *)MessageText);
  return 0;
}

//----- (00402DA0) --------------------------------------------------------
void __thiscall CDB::Reset(CDB *this)
{
  SQLFreeStmt(this->m_hStmt, 2u);
  SQLFreeStmt(this->m_hStmt, 0);
  this->m_nBind = 0;
}

//----- (00402DD0) --------------------------------------------------------
CDBConnect *__cdecl CDBConnect::Alloc()
{
  CDBConnect *result; // eax
  CDBConnect *v1; // eax
  CDBConnect *v2; // [esp+0h] [ebp-1Ch]
  CDBConnect *v3; // [esp+4h] [ebp-18h]
  CDBConnect *v4; // [esp+Ch] [ebp-10h]

  CIOSpinLock::Enter(&g_lock.lock);
  if ( g_pool )
  {
    v4 = g_pool;
    g_pool = g_pool->m_pNext;
    CIOSpinLock::Leave(&g_lock.lock);
    result = v4;
  }
  else
  {
    CIOSpinLock::Leave(&g_lock.lock);
    v3 = (CDBConnect *)operator new(0xCu);
    if ( v3 )
    {
      CDBConnect::CDBConnect(v3);
      v2 = v1;
    }
    else
    {
      v2 = 0;
    }
    result = v2;
  }
  return result;
}
// 402E58: variable 'v1' is possibly undefined

//----- (00402E90) --------------------------------------------------------
LONG __thiscall CDBConnect::Free(_DWORD *this)
{
  CIOSpinLock::Enter(&g_lock.lock);
  this[2] = g_pool;
  g_pool = (CDBConnect *)this;
  return CIOSpinLock::Leave(&g_lock.lock);
}

//----- (00402ED0) --------------------------------------------------------
void __thiscall CDBConnect::CDBConnect(CDBConnect *this)
{
  this->m_hDBC = 0;
  this->m_hStmt = 0;
  if ( SQLAllocHandle(2, EnvironmentHandle, &this->m_hDBC) == -1 )
  {
    LOG_ERR("Can't Allocate SQL Connection Handle");
  }
  else if ( SQLConnect(this->m_hDBC, Destination, -3, &UserName, -3, (SQLCHAR *)buf, -3) == -1 )
  {
    LOG_ERR("Can't connect to SQL");
    PostMessageA((HWND)*(&stru_4441A4 + 1), 0x111u, 0x8009u, 0);
  }
  else
  {
    if ( SQLAllocHandle(3, this->m_hDBC, &this->m_hStmt) != -1 )
      return;
    LOG_ERR("Can't Allocate SQL Stmt Handle");
  }
  if ( this->m_hDBC )
  {
    SQLFreeHandle(2, this->m_hDBC);
    this->m_hDBC = 0;
  }
}

//----- (00402FC0) --------------------------------------------------------
void __thiscall CDBConnect::~CDBConnect(CDBConnect *this)
{
  if ( this->m_hStmt )
    SQLFreeHandle(3, this->m_hStmt);
  if ( this->m_hDBC )
    SQLFreeHandle(2, this->m_hDBC);
}

//----- (00403000) --------------------------------------------------------
void __thiscall CIOSpinLock::Enter(volatile LONG *this)
{
  if ( InterlockedCompareExchange(this, 1, 0) )
    CIOSpinLock::Wait((CIOSpinLock *)this);
}

//----- (00403030) --------------------------------------------------------
LONG __thiscall CIOSpinLock::Leave(volatile LONG *this)
{
  return InterlockedExchange(this, 0);
}

//----- (00403050) --------------------------------------------------------
SQLHANDLE *__thiscall CDBConnect::`scalar deleting destructor'(SQLHANDLE *this, char a2)
{
  CDBConnect::~CDBConnect((CDBConnect *)this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (004030A0) --------------------------------------------------------
int __cdecl CDBConfig::Open()
{
  int v0; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  _DWORD *v12; // eax
  const char *v13; // eax
  _DWORD *v14; // eax
  const char *v15; // eax
  int v16; // eax
  int v17; // [esp-4h] [ebp-298h] BYREF
  int v18; // [esp+0h] [ebp-294h]
  char v19[4]; // [esp+Ch] [ebp-288h] BYREF
  char v20[4]; // [esp+10h] [ebp-284h] BYREF
  int *v21; // [esp+14h] [ebp-280h]
  unsigned int v22; // [esp+1Ch] [ebp-278h]
  unsigned int v23; // [esp+20h] [ebp-274h]
  char v24[4]; // [esp+24h] [ebp-270h] BYREF
  CHAR String[32]; // [esp+28h] [ebp-26Ch] BYREF
  char *Str; // [esp+48h] [ebp-24Ch]
  struct _SYSTEM_INFO SystemInfo; // [esp+4Ch] [ebp-248h] BYREF
  CConfig v28; // [esp+70h] [ebp-224h] BYREF
  lisp::var result; // [esp+284h] [ebp-10h] BYREF
  int v30; // [esp+290h] [ebp-4h]

  CConfig::CConfig(&v28);
  v30 = 0;
  if ( CConfig::Open(&v28, "DBConfig.txt") )
  {
    GetSystemInfo(&SystemInfo);
    CDBConfig::s_nNumberOfThreads = CConfig::GetInt(&v28, "NumberOfThreads", 2 * SystemInfo.dwNumberOfProcessors);
    dword_43D980 = CConfig::GetInt(&v28, "NewUID", 0);
    dword_43D97C = CConfig::GetTimeStamp();
    v1 = (char *)CConfig::Get(&v28, "ODBC", "KAL");
    std::string::operator=(CDBConfig::s_strODBC, v1);
    v2 = (char *)CConfig::Get(&v28, "MailServer");
    std::string::operator=(CDBConfig::s_strMailServer, v2);
    v3 = (char *)CConfig::Get(&v28, "MailFrom");
    std::string::operator=(CDBConfig::s_strMailFrom, v3);
    v4 = (char *)CConfig::Get(&v28, "MailTo");
    std::string::operator=(CDBConfig::s_strMailTo, v4);
    *(_DWORD *)&nPort = CConfig::GetInt(&v28, "Port", 40001);
    dword_43C0A0 = CConfig::GetInt(&v28, "SqlTick", 5000);
    CDBConfig::s_nEvent = CConfig::GetInt(&v28, "Country", 0);
    Str = (char *)CConfig::Get(&v28, "Title");
    if ( *Str )
    {
      sprintf(String, "%s on port %d", Str, *(_DWORD *)&nPort);
      SetWindowTextA((HWND)*(&stru_4441A4 + 1), String);
    }
    for ( Str = (char *)CConfig::Get(&v28, "Event", byte_42A816); ; Str += v6 )
    {
      v5 = strspn(Str, " ,");
      Str += v5;
      if ( !*Str )
        break;
      CDBConfig::s_nSystem |= 1 << j__atol(Str);
      v6 = strcspn(Str, " ,");
    }
    for ( Str = (char *)CConfig::Get(&v28, "System", &byte_42A827); ; Str += v8 )
    {
      v7 = strspn(Str, " ,");
      Str += v7;
      if ( !*Str )
        break;
      dword_43D974 |= 1 << j__atol(Str);
      v8 = strcspn(Str, " ,");
    }
    CConfig::Find(&v28, &result, "SubNet");
    if ( !(unsigned __int8)lisp::var::null(&result) )
    {
      v9 = lisp::var::integerp(&result);
      v17 = v10;
      v21 = &v17;
      std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(v9);
      lisp::var::operator=(&result, v17);
      v11 = lisp::var::length(&result);
      std::vector<IPAddrMask>::reserve(CDBConfig::s_vSubNet, v11);
      while ( !(unsigned __int8)lisp::var::null(&result) )
      {
        lisp::var::pop((int *)&result, (int)v24);
        v12 = (_DWORD *)lisp::var::pop((int *)v24, (int)v20);
        v13 = (const char *)lisp::var::operator char const *(v12);
        v22 = inet_addr(v13);
        v14 = (_DWORD *)lisp::var::pop((int *)v24, (int)v19);
        v15 = (const char *)lisp::var::operator char const *(v14);
        v23 = inet_addr(v15);
        v16 = unknown_libname_8(v23 & v22, v23);
        std::vector<IPAddrMask>::push_back((void **)CDBConfig::s_vSubNet, v16);
      }
    }
    v18 = 1;
    v30 = -1;
    CConfig::~CConfig(&v28);
    v0 = v18;
  }
  else
  {
    v30 = -1;
    CConfig::~CConfig(&v28);
    v0 = 0;
  }
  return v0;
}
// 4033C3: variable 'v10' is possibly undefined
// 401F90: using guessed type _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD);
// 403550: using guessed type _DWORD __stdcall unknown_libname_8(_DWORD, _DWORD);
// 43C0A0: using guessed type int dword_43C0A0;
// 43D97C: using guessed type int dword_43D97C;
// 43D980: using guessed type int dword_43D980;

//----- (004034D0) --------------------------------------------------------
_DWORD *CDBConfig::Close()
{
  return std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::clear(dword_43DA08);
}

//----- (00403580) --------------------------------------------------------
int __thiscall lisp::var::pop(int *this, int a2)
{
  int v2; // eax
  int v4; // [esp+4h] [ebp-4h]

  v4 = *this;
  *this = *(_DWORD *)(*(int (__thiscall **)(int *))(*(_DWORD *)*this + 16))(this);
  v2 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 12))(v4);
  std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(v2);
  return a2;
}
// 401F90: using guessed type _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD);

//----- (004035D0) --------------------------------------------------------
int __thiscall lisp::var::length(lisp::var *this)
{
  return ((int (__thiscall *)(lisp::_object *, lisp::var *))this->m_pObject->length)(this->m_pObject, this);
}

//----- (004035F0) --------------------------------------------------------
void *__thiscall std::string::operator=(void *this, char *Str)
{
  return std::string::assign(this, Str);
}

//----- (00403610) --------------------------------------------------------
_DWORD *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::clear(_DWORD *this)
{
  void **v1; // eax
  _DWORD *result; // eax

  v1 = (void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this);
  std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Erase(*v1);
  *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this) = this[1];
  this[2] = 0;
  *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lmost(this) = this[1];
  result = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rmost(this);
  *result = this[1];
  return result;
}

//----- (00403670) --------------------------------------------------------
_DWORD *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::find(int *this, _DWORD *a1, int a2)
{
  void *v3; // eax
  int v4; // eax
  _DWORD *v5; // eax
  _DWORD *v7; // [esp+0h] [ebp-18h]
  char v9[4]; // [esp+8h] [ebp-10h] BYREF
  char v10[4]; // [esp+Ch] [ebp-Ch] BYREF
  _DWORD *v11; // [esp+10h] [ebp-8h]
  char v12[4]; // [esp+14h] [ebp-4h] BYREF

  std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::lower_bound(
    this,
    (int)v12,
    a2);
  v3 = std::vector<CSyncPacket::CElement>::begin(this, v10);
  if ( (unsigned __int8)unknown_libname_18(v3)
    || (v4 = unknown_libname_17(v12),
        v5 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Key(v4),
        std::less<int>::operator()((_DWORD *)a2, v5)) )
  {
    v7 = std::vector<CSyncPacket::CElement>::begin(this, v9);
  }
  else
  {
    v7 = v12;
  }
  v11 = v7;
  *a1 = *v7;
  return a1;
}
// 405100: using guessed type int __thiscall unknown_libname_17(_DWORD);
// 405110: using guessed type _DWORD __stdcall unknown_libname_18(_DWORD);

//----- (00403700) --------------------------------------------------------
int *__thiscall std::vector<IPAddrMask>::reserve(_DWORD *this, unsigned int a2)
{
  int *result; // eax
  int v3; // [esp+0h] [ebp-38h] BYREF
  int *v4; // [esp+Ch] [ebp-2Ch]
  int *v5; // [esp+10h] [ebp-28h]
  int *v6; // [esp+14h] [ebp-24h]
  char v7[4]; // [esp+18h] [ebp-20h] BYREF
  char v8[4]; // [esp+1Ch] [ebp-1Ch] BYREF
  int v9; // [esp+20h] [ebp-18h]
  void *v10; // [esp+24h] [ebp-14h]
  int *v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+34h] [ebp-4h]

  v11 = &v3;
  v6 = this;
  if ( sub_403B00(this) < a2 )
    std::vector<IPAddrMask>::_Xlen();
  result = (int *)std::vector<IPAddrMask>::capacity(v6);
  if ( (unsigned int)result < a2 )
  {
    v10 = sub_403E10(a2);
    v12 = 0;
    v5 = (int *)std::vector<CIOSocket::CIOTimer>::end(v6, (int)v8);
    v4 = (int *)std::vector<CSyncPacket::CElement>::begin(v6, v7);
    std::vector<IPAddrMask>::_Ucopy<std::vector<IPAddrMask>::iterator>(v6, *v4, *v5, v10);
    v12 = -1;
    v9 = std::vector<IPAddrMask>::size(v6);
    if ( v6[1] )
    {
      std::vector<IPAddrMask>::_Destroy(v6, v6[1], v6[2]);
      std::allocator<CSyncPacket::CElement>::deallocate(v6[1], (v6[3] - v6[1]) >> 3);
    }
    v6[3] = (int)v10 + 8 * a2;
    result = v6;
    v6[2] = (int)v10 + 8 * v9;
    v6[1] = (int)v10;
  }
  return result;
}

//----- (00403850) --------------------------------------------------------
void *__thiscall std::vector<IPAddrMask>::push_back(void **this, int a2)
{
  unsigned int v2; // esi
  void *result; // eax
  int *v4; // eax
  char v6[4]; // [esp+8h] [ebp-8h] BYREF
  char v7[4]; // [esp+Ch] [ebp-4h] BYREF

  v2 = std::vector<IPAddrMask>::size(this);
  if ( v2 >= std::vector<IPAddrMask>::capacity(this) )
  {
    v4 = (int *)std::vector<CIOSocket::CIOTimer>::end(this, (int)v7);
    result = (void *)std::vector<IPAddrMask>::insert(this, (int)v6, *v4, a2);
  }
  else
  {
    result = (void *)sub_403BD0(this, this[2], 1, a2);
    this[2] = result;
  }
  return result;
}

//----- (004038C0) --------------------------------------------------------
int __thiscall sub_4038C0(void *this)
{
  return sub_403E50(this);
}

//----- (004038E0) --------------------------------------------------------
void *__thiscall std::string::assign(void *this, char *Str)
{
  size_t v2; // eax

  v2 = std::char_traits<char>::length(Str);
  return std::string::assign(this, Str, v2);
}

//----- (00403930) --------------------------------------------------------
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Key(int a1)
{
  int v1; // eax

  v1 = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Myval(a1);
  return unknown_libname_10(v1);
}
// 404010: using guessed type _DWORD __cdecl unknown_libname_10(_DWORD);

//----- (00403950) --------------------------------------------------------
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::lower_bound(_DWORD *this, int a1, int a2)
{
  int v3; // eax

  v3 = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lbound(
         this,
         (_DWORD *)a2);
  sub_403E30((void *)a1, v3);
  return a1;
}

//----- (00403980) --------------------------------------------------------
int __stdcall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Erase(void *a1)
{
  char *i; // eax
  int result; // eax
  void **v3; // eax
  void *v4; // [esp+4h] [ebp-4h]

  v4 = a1;
  for ( i = (char *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil((int)a1);
        ;
        i = (char *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil((int)v4) )
  {
    result = *i;
    if ( result )
      break;
    v3 = (void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v4);
    std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Erase(*v3);
    v4 = *(void **)unknown_libname_10(v4);
    std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node>::destroy(a1);
    std::allocator<CSyncPacket::CElement>::deallocate((int)a1, 1);
    a1 = v4;
  }
  return result;
}
// 404010: using guessed type _DWORD __cdecl unknown_libname_10(_DWORD);

//----- (00403A00) --------------------------------------------------------
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lmost(_DWORD *this)
{
  return unknown_libname_10(this[1]);
}
// 404010: using guessed type _DWORD __cdecl unknown_libname_10(_DWORD);

//----- (00403A20) --------------------------------------------------------
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rmost(_DWORD *this)
{
  return std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(this[1]);
}

//----- (00403A40) --------------------------------------------------------
BOOL __stdcall std::less<int>::operator()(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

//----- (00403A60) --------------------------------------------------------
int __thiscall std::vector<IPAddrMask>::capacity(_DWORD *this)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( this[1] )
    v2 = (this[3] - this[1]) >> 3;
  else
    v2 = 0;
  return v2;
}

//----- (00403AA0) --------------------------------------------------------
int __thiscall std::vector<CIOSocket::CIOTimer>::end(_DWORD *this, int a2)
{
  sub_403E30((void *)a2, this[2]);
  return a2;
}

//----- (00403AC0) --------------------------------------------------------
int __thiscall std::vector<IPAddrMask>::size(_DWORD *this)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( this[1] )
    v2 = (this[2] - this[1]) >> 3;
  else
    v2 = 0;
  return v2;
}

//----- (00403B00) --------------------------------------------------------
int __thiscall sub_403B00(void *this)
{
  return std::allocator<IPAddrMask>::max_size();
}

//----- (00403B20) --------------------------------------------------------
int __thiscall std::vector<IPAddrMask>::insert(_DWORD *this, int a2, int a3, int a4)
{
  void *v4; // eax
  int v6; // [esp-4h] [ebp-18h]
  int v7; // [esp+0h] [ebp-14h]
  char v9[4]; // [esp+8h] [ebp-Ch] BYREF
  char v10[4]; // [esp+Ch] [ebp-8h] BYREF
  int v11; // [esp+10h] [ebp-4h]

  if ( std::vector<IPAddrMask>::size(this) )
  {
    v4 = std::vector<CSyncPacket::CElement>::begin(this, v10);
    v7 = std::vector<IPAddrMask>::iterator::operator-(&a3, (int)v4);
  }
  else
  {
    v7 = 0;
  }
  v11 = v7;
  std::vector<IPAddrMask>::_Insert_n(this, a3, 1u, (int *)a4);
  v6 = v11;
  std::vector<CSyncPacket::CElement>::begin(this, v9);
  std::vector<IPAddrMask>::iterator::operator+((_DWORD *)a2, v6);
  return a2;
}

//----- (00403BA0) --------------------------------------------------------
int __thiscall std::vector<IPAddrMask>::_Destroy(void *this, int a2, int a3)
{
  return std::_Destroy_range<IPAddrMask>(a2, a3);
}

//----- (00403BD0) --------------------------------------------------------
int __thiscall sub_403BD0(void *this, void *a2, int a3, int a4)
{
  std::_Uninitialized_fill_n<IPAddrMask *,unsigned int,IPAddrMask,std::allocator<IPAddrMask>>(a2, a3, a4);
  return (int)a2 + 8 * a3;
}

//----- (00403C00) --------------------------------------------------------
void __noreturn std::vector<IPAddrMask>::_Xlen()
{
  char v0[28]; // [esp+4h] [ebp-50h] BYREF
  char pExceptionObject[48]; // [esp+20h] [ebp-34h] BYREF
  int v2; // [esp+50h] [ebp-4h]

  std::string::string(v0, "vector<T> too long");
  v2 = 0;
  std::length_error::length_error((std::length_error *)pExceptionObject, (const std::length_error *)v0);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);
}

//----- (00403C60) --------------------------------------------------------
void __thiscall std::length_error::length_error(std::length_error *this, const std::length_error *that)
{
  std::logic_error::logic_error(this, that);
  *(_DWORD *)this = &std::length_error::`vftable';
}
// 437960: using guessed type void *std::length_error::`vftable';

//----- (00403C90) --------------------------------------------------------
void __thiscall std::logic_error::logic_error(std::logic_error *this, const std::logic_error *that)
{
  sub_41EED8(this);
  *(_DWORD *)this = &std::logic_error::`vftable';
  std::string::string((char *)this + 12, (int)that);
}
// 437954: using guessed type void *std::logic_error::`vftable';

//----- (00403CF0) --------------------------------------------------------
int __thiscall sub_403CF0(char *this)
{
  return std::string::c_str(this + 12);
}

//----- (00403D10) --------------------------------------------------------
void *__thiscall std::logic_error::`vector deleting destructor'(void *this, char a2)
{
  std::logic_error::~logic_error((std::logic_error *)this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (00403D40) --------------------------------------------------------
void __thiscall std::logic_error::~logic_error(std::logic_error *this)
{
  *(_DWORD *)this = &std::logic_error::`vftable';
  std::string::~string((_DWORD *)this + 3);
  exception::~exception((exception *)this);
}
// 437954: using guessed type void *std::logic_error::`vftable';

//----- (00403DA0) --------------------------------------------------------
void __thiscall std::length_error::~length_error(std::length_error *this)
{
  *(_DWORD *)this = &std::length_error::`vftable';
  std::logic_error::~logic_error(this);
}
// 437960: using guessed type void *std::length_error::`vftable';

//----- (00403DC0) --------------------------------------------------------
_DWORD *__thiscall std::length_error::`vector deleting destructor'(_DWORD *this, char a2)
{
  std::length_error::~length_error((std::length_error *)this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (00403DF0) --------------------------------------------------------
void __stdcall std::allocator<CSyncPacket::CElement>::deallocate(int a1, int a2)
{
  operator delete(a1);
}

//----- (00403E10) --------------------------------------------------------
CMemory **__stdcall sub_403E10(int a1)
{
  return sub_404C20(a1);
}

//----- (00403E30) --------------------------------------------------------
void *__thiscall sub_403E30(void *this, int a2)
{
  unknown_libname_13(a2);
  return this;
}
// 404820: using guessed type _DWORD __stdcall unknown_libname_13(_DWORD);

//----- (00403E50) --------------------------------------------------------
int __thiscall sub_403E50(void *this)
{
  return sub_404840((int *)this);
}

//----- (00403E70) --------------------------------------------------------
_DWORD *__thiscall std::length_error::length_error(_DWORD *this, struct exception *a2)
{
  std::logic_error::logic_error((exception *)this, a2);
  *this = &std::length_error::`vftable';
  return this;
}
// 437960: using guessed type void *std::length_error::`vftable';

//----- (00403EA0) --------------------------------------------------------
exception *__thiscall std::logic_error::logic_error(exception *this, struct exception *a2)
{
  exception::exception(this, a2);
  this->__vftable = (exception_vtbl *)&std::logic_error::`vftable';
  std::string::string(&this[1], (int)&a2[1]);
  return this;
}
// 437954: using guessed type void *std::logic_error::`vftable';

//----- (00403F10) --------------------------------------------------------
_DWORD *__thiscall std::string::string(void *this, char *Str)
{
  void *v3; // [esp-4h] [ebp-Ch] BYREF
  _DWORD *v4; // [esp+0h] [ebp-8h]

  v4 = this;
  v3 = this;
  unknown_libname_9(&v3);
  sub_40D710(v4, (char)v3);
  std::string::_Tidy(v4, 0, 0);
  std::string::assign(v4, Str);
  return v4;
}
// 403F50: using guessed type int __thiscall unknown_libname_9(_DWORD);

//----- (00403F60) --------------------------------------------------------
void *__thiscall std::string::assign(void *this, void *Src, size_t Size)
{
  int v3; // eax
  void *result; // eax
  void *v5; // eax

  if ( std::string::_Inside(this, (unsigned int)Src) )
  {
    v3 = unknown_libname_11(this);
    result = std::string::assign((std::_String_base *)this, (std::_String_base *)this, (unsigned int)Src - v3, Size);
  }
  else
  {
    if ( std::string::_Grow((size_t *)this, Size, 0) )
    {
      v5 = (void *)unknown_libname_11(this);
      std::char_traits<char>::copy(v5, Src, Size);
      std::string::_Eos(this, Size);
    }
    result = this;
  }
  return result;
}
// 404600: using guessed type int __thiscall unknown_libname_11(_DWORD);

//----- (00404000) --------------------------------------------------------
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(int a1)
{
  return a1 + 45;
}

//----- (00404020) --------------------------------------------------------
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(int a1)
{
  return a1 + 4;
}

//----- (00404030) --------------------------------------------------------
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(int a1)
{
  return a1 + 8;
}

//----- (00404040) --------------------------------------------------------
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Myval(int a1)
{
  return a1 + 12;
}

//----- (00404050) --------------------------------------------------------
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lbound(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // eax
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  v5 = *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this);
  v6 = this[1];
  while ( !*(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(v5) )
  {
    v2 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Key(v5);
    if ( std::less<int>::operator()(v2, a2) )
    {
      v5 = *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(v5);
    }
    else
    {
      v6 = v5;
      v5 = *(_DWORD *)unknown_libname_10(v5);
    }
  }
  return v6;
}
// 404010: using guessed type _DWORD __cdecl unknown_libname_10(_DWORD);

//----- (004040E0) --------------------------------------------------------
void *__thiscall std::string::string(void *this, int a2)
{
  char v3; // [esp-4h] [ebp-Ch]

  v3 = (char)this;
  unknown_libname_19(a2);
  sub_40D710(this, v3);
  std::string::_Tidy(this, 0, 0);
  std::string::assign((std::_String_base *)this, (std::_String_base *)a2, 0, std::string::npos);
  return this;
}
// 405580: using guessed type _DWORD __stdcall unknown_libname_19(_DWORD);

//----- (00404130) --------------------------------------------------------
void __stdcall std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node>::destroy(void *a1)
{
  __ExceptionPtrDestroy(a1);
}

//----- (00404150) --------------------------------------------------------
int __thiscall std::string::~string(_DWORD *this)
{
  return std::string::_Tidy(this, 1, 0);
}

//----- (00404170) --------------------------------------------------------
int __thiscall std::string::c_str(void *this)
{
  return unknown_libname_11(this);
}
// 404600: using guessed type int __thiscall unknown_libname_11(_DWORD);

//----- (00404190) --------------------------------------------------------
int *__thiscall std::vector<IPAddrMask>::_Insert_n(int *this, int a2, unsigned int a3, int *a4)
{
  int v4; // edx
  int *result; // eax
  int v6; // esi
  int v7; // eax
  unsigned int v8; // esi
  int v9; // eax
  int v10; // eax
  void *v11; // eax
  int v12; // [esp+0h] [ebp-44h] BYREF
  void *v13; // [esp+Ch] [ebp-38h]
  void *v14; // [esp+10h] [ebp-34h]
  unsigned int v15; // [esp+14h] [ebp-30h]
  int *v16; // [esp+18h] [ebp-2Ch]
  int v17; // [esp+1Ch] [ebp-28h]
  void *v18; // [esp+20h] [ebp-24h]
  void *v19; // [esp+24h] [ebp-20h]
  unsigned int v20; // [esp+28h] [ebp-1Ch]
  int v21[3]; // [esp+2Ch] [ebp-18h] BYREF
  int v22; // [esp+40h] [ebp-4h]
  int v23; // [esp+50h] [ebp+Ch]

  v21[2] = (int)&v12;
  v16 = this;
  v4 = a4[1];
  v21[0] = *a4;
  v21[1] = v4;
  result = (int *)std::vector<IPAddrMask>::capacity(this);
  v20 = (unsigned int)result;
  if ( a3 )
  {
    v6 = std::vector<IPAddrMask>::size(v16);
    if ( sub_403B00(v16) - v6 < a3 )
      std::vector<IPAddrMask>::_Xlen();
    v7 = std::vector<IPAddrMask>::size(v16);
    if ( v20 >= a3 + v7 )
    {
      if ( (v16[2] - a2) >> 3 >= a3 )
      {
        v17 = v16[2];
        v11 = std::vector<IPAddrMask>::_Ucopy<IPAddrMask *>(v16, v17 - 8 * a3, v17, (void *)v16[2]);
        v16[2] = (int)v11;
        std::copy_backward<IPAddrMask *,IPAddrMask *>(a2, v17 - 8 * a3, v17);
        result = std::fill<IPAddrMask *,IPAddrMask>((_DWORD *)a2, (_DWORD *)(a2 + 8 * a3), v21);
      }
      else
      {
        std::vector<IPAddrMask>::_Ucopy<IPAddrMask *>(v16, a2, v16[2], (void *)(a2 + 8 * a3));
        v22 = 2;
        sub_403BD0(v16, (void *)v16[2], a3 - ((v16[2] - a2) >> 3), (int)v21);
        v22 = -1;
        v16[2] += 8 * a3;
        result = std::fill<IPAddrMask *,IPAddrMask>((_DWORD *)a2, (_DWORD *)(v16[2] - 8 * a3), v21);
      }
    }
    else
    {
      v8 = v20 >> 1;
      v9 = sub_403B00(v16);
      if ( v9 - v8 >= v20 )
        v15 = v20 + (v20 >> 1);
      else
        v15 = 0;
      v20 = v15;
      v10 = std::vector<IPAddrMask>::size(v16);
      if ( v20 < a3 + v10 )
        v20 = a3 + std::vector<IPAddrMask>::size(v16);
      v18 = sub_403E10(v20);
      v19 = v18;
      v22 = 0;
      v14 = std::vector<IPAddrMask>::_Ucopy<IPAddrMask *>(v16, v16[1], a2, v18);
      v19 = v14;
      v13 = (void *)sub_403BD0(v16, v14, a3, (int)v21);
      v19 = v13;
      std::vector<IPAddrMask>::_Ucopy<IPAddrMask *>(v16, a2, v16[2], v13);
      v22 = -1;
      v23 = a3 + std::vector<IPAddrMask>::size(v16);
      if ( v16[1] )
      {
        std::vector<IPAddrMask>::_Destroy(v16, v16[1], v16[2]);
        std::allocator<CSyncPacket::CElement>::deallocate(v16[1], (v16[3] - v16[1]) >> 3);
      }
      v16[3] = (int)v18 + 8 * v20;
      v16[2] = (int)v18 + 8 * v23;
      result = v16;
      v16[1] = (int)v18;
    }
  }
  return result;
}

//----- (004044C0) --------------------------------------------------------
std::_String_base *__thiscall std::string::assign(std::_String_base *this, std::_String_base *a2, unsigned int a3, size_t a4)
{
  void *v4; // eax
  void *v6; // [esp-8h] [ebp-10h]
  unsigned int Size; // [esp+4h] [ebp-4h]

  if ( unknown_libname_12(a2) < a3 )
    std::_String_base::_Xran(this);
  Size = unknown_libname_12(a2) - a3;
  if ( a4 < Size )
    Size = a4;
  if ( this == a2 )
  {
    std::string::erase(this, Size + a3, std::string::npos);
    std::string::erase(this, 0, a3);
  }
  else if ( std::string::_Grow((size_t *)this, Size, 0) )
  {
    v6 = (void *)(a3 + unknown_libname_11(a2));
    v4 = (void *)unknown_libname_11(this);
    std::char_traits<char>::copy(v4, v6, Size);
    std::string::_Eos(this, Size);
  }
  return this;
}
// 404600: using guessed type int __thiscall unknown_libname_11(_DWORD);
// 4046E0: using guessed type int __thiscall unknown_libname_12(_DWORD);

//----- (00404580) --------------------------------------------------------
int __thiscall std::string::_Tidy(_DWORD *this, char a2, size_t Size)
{
  void *Src; // [esp+4h] [ebp-4h]

  if ( a2 && this[6] >= 0x10u )
  {
    Src = (void *)this[1];
    if ( Size )
      std::char_traits<char>::copy(this + 1, Src, Size);
    std::allocator<CSyncPacket::CElement>::deallocate((int)Src, this[6] + 1);
  }
  this[6] = 15;
  return std::string::_Eos(this, Size);
}

//----- (00404630) --------------------------------------------------------
std::_String_base *__thiscall std::string::erase(std::_String_base *this, unsigned int a2, unsigned int a3)
{
  int v3; // eax
  void *v5; // [esp-8h] [ebp-10h]
  size_t v6; // [esp-4h] [ebp-Ch]

  if ( *(_DWORD *)&this[20] < a2 )
    std::_String_base::_Xran(this);
  if ( *(_DWORD *)&this[20] - a2 < a3 )
    a3 = *(_DWORD *)&this[20] - a2;
  if ( a3 )
  {
    v6 = *(_DWORD *)&this[20] - a2 - a3;
    v5 = (void *)(a3 + a2 + unknown_libname_11(this));
    v3 = unknown_libname_11(this);
    sub_4046C0((void *)(a2 + v3), v5, v6);
    std::string::_Eos(this, *(_DWORD *)&this[20] - a3);
  }
  return this;
}
// 404600: using guessed type int __thiscall unknown_libname_11(_DWORD);

//----- (004046C0) --------------------------------------------------------
void *__cdecl sub_4046C0(void *a1, void *Src, size_t Size)
{
  return memcpy_0(a1, Src, Size);
}

//----- (00404700) --------------------------------------------------------
int __thiscall std::string::_Eos(_DWORD *this, int a2)
{
  int v2; // eax
  char v4; // [esp+7h] [ebp-1h] BYREF

  v4 = 0;
  this[5] = a2;
  v2 = unknown_libname_11(this);
  return std::char_traits<char>::assign(a2 + v2, &v4);
}
// 404600: using guessed type int __thiscall unknown_libname_11(_DWORD);
// 404740: using guessed type _DWORD __cdecl std::char_traits<char>::assign(_DWORD, _DWORD);

//----- (00404750) --------------------------------------------------------
int std::allocator<IPAddrMask>::max_size()
{
  return 0x1FFFFFFF;
}

//----- (00404780) --------------------------------------------------------
BOOL __thiscall std::string::_Grow(size_t *this, unsigned int a2, char a3)
{
  if ( unknown_libname_24(this) < a2 )
    std::_String_base::_Xlen((std::_String_base *)this);
  if ( this[6] >= a2 )
  {
    if ( a3 && a2 < 0x10 )
    {
      if ( a2 >= this[5] )
        std::string::_Tidy(this, 1, this[5]);
      else
        std::string::_Tidy(this, 1, a2);
    }
    else if ( !a2 )
    {
      std::string::_Eos(this, 0);
    }
  }
  else
  {
    std::string::_Copy(this, a2, this[5]);
  }
  return a2 != 0;
}
// 4048C0: using guessed type int __thiscall unknown_libname_24(_DWORD);

//----- (00404840) --------------------------------------------------------
int __thiscall sub_404840(int *this)
{
  return std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Myval(*this);
}

//----- (00404860) --------------------------------------------------------
_DWORD *__stdcall std::vector<IPAddrMask>::iterator::operator+(_DWORD *a1, int a2)
{
  *a1 = *(_DWORD *)unknown_libname_14(a2);
  return a1;
}
// 404B30: using guessed type _DWORD __stdcall unknown_libname_14(_DWORD);

//----- (00404890) --------------------------------------------------------
int __thiscall std::vector<IPAddrMask>::iterator::operator-(int *this, int a1)
{
  int v3; // [esp+4h] [ebp-4h] BYREF

  v3 = *this;
  return std::vector<IPAddrMask>::const_iterator::operator-(&v3, (_DWORD *)a1);
}

//----- (00404900) --------------------------------------------------------
bool __thiscall std::string::_Inside(_DWORD *this, unsigned int a2)
{
  return a2 >= unknown_libname_11(this) && this[5] + unknown_libname_11(this) > a2;
}
// 404600: using guessed type int __thiscall unknown_libname_11(_DWORD);

//----- (00404940) --------------------------------------------------------
int __thiscall std::string::_Copy(_DWORD *this, int a2, size_t Size)
{
  unsigned int v3; // eax
  int v4; // esi
  int v5; // eax
  void *v6; // eax
  int v8; // [esp+0h] [ebp-30h] BYREF
  CMemory **v9; // [esp+10h] [ebp-20h]
  _DWORD *v10; // [esp+14h] [ebp-1Ch]
  unsigned int v11; // [esp+18h] [ebp-18h]
  void *v12; // [esp+1Ch] [ebp-14h]
  int *v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-4h]

  v13 = &v8;
  v10 = this;
  v11 = a2 | 0xF;
  v3 = unknown_libname_24(this);
  if ( v3 >= v11 )
  {
    if ( v11 / 3 < v10[6] >> 1 )
    {
      v4 = v10[6] >> 1;
      v5 = unknown_libname_24(v10);
      if ( v10[6] <= (unsigned int)(v5 - v4) )
        v11 = v10[6] + (v10[6] >> 1);
    }
  }
  else
  {
    v11 = a2;
  }
  v14 = 0;
  v9 = std::allocator<char>::allocate(v11 + 1);
  v12 = v9;
  v14 = -1;
  if ( Size )
  {
    v6 = (void *)unknown_libname_11(v10);
    std::char_traits<char>::copy(v12, v6, Size);
  }
  std::string::_Tidy(v10, 1, 0);
  v10[1] = v12;
  v10[6] = v11;
  return std::string::_Eos(v10, Size);
}
// 404600: using guessed type int __thiscall unknown_libname_11(_DWORD);
// 4048C0: using guessed type int __thiscall unknown_libname_24(_DWORD);

//----- (00404AA0) --------------------------------------------------------
CMemory **__stdcall std::allocator<char>::allocate(size_t Size)
{
  return sub_404AF0(Size);
}

//----- (00404AF0) --------------------------------------------------------
CMemory **__cdecl sub_404AF0(size_t Size)
{
  return operator new(Size);
}

//----- (00404B10) --------------------------------------------------------
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(int *this)
{
  return std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(this[1]);
}

//----- (00404B50) --------------------------------------------------------
int __thiscall std::vector<IPAddrMask>::const_iterator::operator-(_DWORD *this, _DWORD *a2)
{
  return (*this - *a2) >> 3;
}

//----- (00404B70) --------------------------------------------------------
void *__thiscall std::vector<IPAddrMask>::_Ucopy<std::vector<IPAddrMask>::iterator>(void *this, int a2, int a3, void *a4)
{
  return std::_Uninitialized_copy<std::vector<IPAddrMask>::iterator,IPAddrMask *,std::allocator<IPAddrMask>>(a2, a3, a4);
}

//----- (00404BA0) --------------------------------------------------------
int __cdecl std::_Destroy_range<IPAddrMask>(int a1, int a2)
{
  unknown_libname_15(&a1, &a2);
  return std::_Destroy_range<IPAddrMask>(a1, a2);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (00404BE0) --------------------------------------------------------
void *__cdecl std::_Uninitialized_fill_n<IPAddrMask *,unsigned int,IPAddrMask,std::allocator<IPAddrMask>>(void *a1, int a2, int a3)
{
  unknown_libname_15(&a1, &a1);
  return std::_Uninit_fill_n<IPAddrMask *,unsigned int,IPAddrMask,std::allocator<IPAddrMask>>(a1, a2, a3);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (00404C20) --------------------------------------------------------
CMemory **__cdecl sub_404C20(int a1)
{
  return operator new(8 * a1);
}

//----- (00404C50) --------------------------------------------------------
void *__thiscall std::vector<IPAddrMask>::_Ucopy<IPAddrMask *>(void *this, int a2, int a3, void *a4)
{
  return std::_Uninitialized_copy<IPAddrMask *,IPAddrMask *,std::allocator<IPAddrMask>>(a2, a3, a4);
}

//----- (00404C80) --------------------------------------------------------
_DWORD *__cdecl std::fill<IPAddrMask *,IPAddrMask>(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax
  int v4; // ecx

  while ( a1 != a2 )
  {
    v4 = a3[1];
    *a1 = *a3;
    a1[1] = v4;
    result = a1 + 2;
    a1 += 2;
  }
  return result;
}

//----- (00404CB0) --------------------------------------------------------
_DWORD *__cdecl std::copy_backward<IPAddrMask *,IPAddrMask *>(int a1, int a2, int a3)
{
  unknown_libname_15(&a1, &a3);
  return std::_Copy_backward_opt<IPAddrMask *,IPAddrMask *>((_DWORD *)a1, (_DWORD *)a2, (_DWORD *)a3);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (00404CF0) --------------------------------------------------------
void *__thiscall std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node::`scalar deleting destructor'(void *this, char a2)
{
  std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node::~_Node((char *)this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (00404D20) --------------------------------------------------------
int __thiscall std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node::~_Node(char *this)
{
  return std::pair<int const,std::string>::~pair<int const,std::string>((_DWORD *)this + 3);
}

//----- (00404D40) --------------------------------------------------------
int __thiscall std::pair<int const,std::string>::~pair<int const,std::string>(_DWORD *this)
{
  return std::string::~string(this + 1);
}

//----- (00404D60) --------------------------------------------------------
void *__cdecl std::_Uninitialized_copy<std::vector<IPAddrMask>::iterator,IPAddrMask *,std::allocator<IPAddrMask>>(int a1, int a2, void *a3)
{
  unknown_libname_15(&a1, &a3);
  return std::_Uninit_copy<std::vector<IPAddrMask>::iterator,IPAddrMask *,std::allocator<IPAddrMask>>(a1, a2, a3);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (00404DA0) --------------------------------------------------------
int __cdecl std::_Destroy_range<IPAddrMask>(int a1, int a2)
{
  int result; // eax

  while ( a1 != a2 )
  {
    std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::destroy(a1);
    result = a1 + 8;
    a1 += 8;
  }
  return result;
}

//----- (00404DD0) --------------------------------------------------------
void *__cdecl std::_Uninit_fill_n<IPAddrMask *,unsigned int,IPAddrMask,std::allocator<IPAddrMask>>(void *a1, int a2, int a3)
{
  void *result; // eax
  _DWORD v4[8]; // [esp+0h] [ebp-20h] BYREF

  v4[4] = v4;
  result = a1;
  v4[3] = a1;
  v4[7] = 0;
  while ( a2 )
  {
    result = std::allocator<IPAddrMask>::construct(a1, a3);
    --a2;
    a1 = (char *)a1 + 8;
  }
  return result;
}

//----- (00404E70) --------------------------------------------------------
void *__cdecl std::_Uninitialized_copy<IPAddrMask *,IPAddrMask *,std::allocator<IPAddrMask>>(int a1, int a2, void *a3)
{
  unknown_libname_15(&a1, &a3);
  return std::_Uninit_copy<IPAddrMask *,IPAddrMask *,std::allocator<IPAddrMask>>(a1, a2, a3);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (00404EB0) --------------------------------------------------------
_DWORD *__cdecl std::_Copy_backward_opt<IPAddrMask *,IPAddrMask *>(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // edx

  while ( a1 != a2 )
  {
    a2 -= 2;
    a3 -= 2;
    v3 = a2[1];
    *a3 = *a2;
    a3[1] = v3;
  }
  return a3;
}

//----- (00404EF0) --------------------------------------------------------
_DWORD *__stdcall std::allocator<IPAddrMask>::construct(void *a1, int a2)
{
  return std::_Construct<IPAddrMask,IPAddrMask>(a1, a2);
}

//----- (00404F20) --------------------------------------------------------
void *__cdecl std::_Uninit_copy<std::vector<IPAddrMask>::iterator,IPAddrMask *,std::allocator<IPAddrMask>>(int a1, int a2, void *a3)
{
  int v4; // [esp+0h] [ebp-28h] BYREF
  int v5; // [esp+Ch] [ebp-1Ch]
  void *v7; // [esp+14h] [ebp-14h]
  int *v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+24h] [ebp-4h]

  v8 = &v4;
  v7 = a3;
  v9 = 0;
  while ( std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::operator!=((int)&a2) )
  {
    v5 = std::vector<CSyncPacket::CElement>::iterator::operator*(&a1);
    std::allocator<IPAddrMask>::construct(a3, v5);
    a3 = (char *)a3 + 8;
    unknown_libname_16(&a1);
  }
  return a3;
}
// 4050E0: using guessed type int __thiscall unknown_libname_16(_DWORD);

//----- (00404FE0) --------------------------------------------------------
void *__cdecl std::_Uninit_copy<IPAddrMask *,IPAddrMask *,std::allocator<IPAddrMask>>(int a1, int a2, void *a3)
{
  _DWORD v4[8]; // [esp+0h] [ebp-20h] BYREF

  v4[4] = v4;
  v4[3] = a3;
  v4[7] = 0;
  while ( a1 != a2 )
  {
    std::allocator<IPAddrMask>::construct(a3, a1);
    a3 = (char *)a3 + 8;
    a1 += 8;
  }
  return a3;
}

//----- (00405090) --------------------------------------------------------
_DWORD *__cdecl std::_Construct<IPAddrMask,IPAddrMask>(void *a1, int a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+4h] [ebp-4h]

  result = operator new(8u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)(a2 + 4);
    *v3 = *(_DWORD *)a2;
    v3[1] = result;
  }
  return result;
}

//----- (00405130) --------------------------------------------------------
_DWORD *__thiscall sub_405130(_DWORD *this)
{
  _DWORD *v2; // [esp-4h] [ebp-Ch] BYREF
  _DWORD *v3; // [esp+0h] [ebp-8h]

  v3 = this;
  v2 = this;
  unknown_libname_9(&v2);
  sub_40D710(v3, (char)v2);
  std::string::_Tidy(v3, 0, 0);
  return v3;
}
// 403F50: using guessed type int __thiscall unknown_libname_9(_DWORD);

//----- (00405160) --------------------------------------------------------
_DWORD *__thiscall sub_405160(void *this)
{
  void *v2; // [esp-4h] [ebp-Ch] BYREF
  _DWORD *v3; // [esp+0h] [ebp-8h]

  v3 = this;
  v2 = this;
  unknown_libname_9(&v2);
  sub_40D710(v3, (char)v2);
  sub_405190(v3, 0);
  return v3;
}
// 403F50: using guessed type int __thiscall unknown_libname_9(_DWORD);

//----- (00405190) --------------------------------------------------------
char __thiscall sub_405190(_DWORD *this, unsigned int a2)
{
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  if ( !a2 )
    return 0;
  if ( sub_403B00(this) < a2 )
    std::vector<IPAddrMask>::_Xlen();
  this[1] = sub_403E10(a2);
  this[2] = this[1];
  this[3] = this[1] + 8 * a2;
  return 1;
}

//----- (00405210) --------------------------------------------------------
void *__thiscall sub_405210(void *this)
{
  int v1; // eax
  char v4; // [esp+6h] [ebp-2h] BYREF
  char v5; // [esp+7h] [ebp-1h] BYREF

  v1 = unknown_libname_9(&v5);
  sub_405240(this, (int)&v4, v1);
  return this;
}
// 403F50: using guessed type int __thiscall unknown_libname_9(_DWORD);

//----- (00405240) --------------------------------------------------------
void *__thiscall sub_405240(void *this, int a2, int a3)
{
  char v4; // [esp-4h] [ebp-Ch]

  v4 = (char)this;
  unknown_libname_19(a3);
  sub_4052F0(this, a2, v4);
  sub_405280((int *)this);
  return this;
}
// 405580: using guessed type _DWORD __stdcall unknown_libname_19(_DWORD);

//----- (00405280) --------------------------------------------------------
int *__thiscall sub_405280(int *this)
{
  int *result; // eax

  this[1] = (int)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Buynode(this);
  *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(this[1]) = 1;
  *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this) = this[1];
  *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lmost(this) = this[1];
  *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rmost(this) = this[1];
  result = this;
  this[2] = 0;
  return result;
}

//----- (004052F0) --------------------------------------------------------
void *__thiscall sub_4052F0(void *this, int a2, char a3)
{
  char v4; // [esp-4h] [ebp-Ch]

  v4 = (char)this;
  unknown_libname_19(&a3);
  sub_4054C0(this, a2, v4);
  unknown_libname_19(&a3);
  return this;
}
// 405580: using guessed type _DWORD __stdcall unknown_libname_19(_DWORD);

//----- (00405330) --------------------------------------------------------
CMemory **__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Buynode(void *this)
{
  int v2; // [esp+0h] [ebp-40h] BYREF
  void *v3; // [esp+Ch] [ebp-34h]
  void *v4; // [esp+10h] [ebp-30h]
  void *v5; // [esp+14h] [ebp-2Ch]
  void *v6; // [esp+18h] [ebp-28h]
  int v7; // [esp+1Ch] [ebp-24h] BYREF
  int v8; // [esp+20h] [ebp-20h] BYREF
  int v9; // [esp+24h] [ebp-1Ch] BYREF
  CMemory **v10; // [esp+28h] [ebp-18h]
  int v11; // [esp+2Ch] [ebp-14h]
  int *v12; // [esp+30h] [ebp-10h]
  int v13; // [esp+3Ch] [ebp-4h]

  v12 = &v2;
  v6 = this;
  v10 = std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node>::allocate(1);
  v11 = 0;
  v13 = 0;
  v9 = 0;
  v5 = (void *)unknown_libname_10(v10);
  std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::construct(
    v5,
    (int)&v9);
  ++v11;
  v8 = 0;
  v4 = (void *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v10);
  std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::construct(
    v4,
    (int)&v8);
  ++v11;
  v7 = 0;
  v3 = (void *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v10);
  std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::construct(
    v3,
    (int)&v7);
  v13 = -1;
  *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v10) = 1;
  *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil((int)v10) = 0;
  return v10;
}
// 404010: using guessed type _DWORD __cdecl unknown_libname_10(_DWORD);

//----- (004054A0) --------------------------------------------------------
void __stdcall std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::destroy(int a1)
{
  sub_40D4A0();
}

//----- (004054C0) --------------------------------------------------------
void *__thiscall sub_4054C0(void *this, int a2, char a3)
{
  char v4; // [esp-4h] [ebp-Ch]

  v4 = (char)this;
  unknown_libname_19(&a3);
  sub_405510(this, (_BYTE *)a2, v4);
  unknown_libname_19(&a3);
  return this;
}
// 405580: using guessed type _DWORD __stdcall unknown_libname_19(_DWORD);

//----- (00405500) --------------------------------------------------------
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(int a1)
{
  return a1 + 44;
}

//----- (00405510) --------------------------------------------------------
void *__thiscall sub_405510(void *this, _BYTE *a2, char a3)
{
  void *v4; // [esp+0h] [ebp-4h]

  v4 = this;
  LOBYTE(this) = *a2;
  unknown_libname_19(this);
  unknown_libname_19(&a3);
  return v4;
}
// 405580: using guessed type _DWORD __stdcall unknown_libname_19(_DWORD);

//----- (00405540) --------------------------------------------------------
CMemory **__stdcall std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node>::allocate(int a1)
{
  return sub_405590(a1);
}

//----- (00405560) --------------------------------------------------------
_DWORD *__stdcall std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::construct(void *a1, int a2)
{
  return std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *,std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>(
           a1,
           a2);
}

//----- (00405590) --------------------------------------------------------
CMemory **__cdecl sub_405590(int a1)
{
  return operator new(48 * a1);
}

//----- (004055B0) --------------------------------------------------------
_DWORD *__cdecl std::_Construct<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *,std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>(void *a1, int a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+4h] [ebp-4h]

  result = operator new(4u, a1);
  v3 = result;
  if ( result )
  {
    result = *(_DWORD **)a2;
    *v3 = *(_DWORD *)a2;
  }
  return result;
}

//----- (004055F0) --------------------------------------------------------
int *__thiscall std::vector<IPAddrMask>::~vector<IPAddrMask>(void *this)
{
  return std::vector<IPAddrMask>::_Tidy((int *)this);
}

//----- (00405610) --------------------------------------------------------
int *__thiscall std::vector<IPAddrMask>::_Tidy(int *this)
{
  int *result; // eax

  if ( this[1] )
  {
    std::vector<IPAddrMask>::_Destroy(this, this[1], this[2]);
    std::allocator<CSyncPacket::CElement>::deallocate(this[1], (this[3] - this[1]) >> 3);
  }
  this[1] = 0;
  this[2] = 0;
  result = this;
  this[3] = 0;
  return result;
}

//----- (00405680) --------------------------------------------------------
int __thiscall std::map<int,std::string>::~map<int,std::string>(void *this)
{
  return std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::~_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>(this);
}

//----- (004056A0) --------------------------------------------------------
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::~_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>(void *this)
{
  return std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Tidy((int *)this);
}

//----- (004056C0) --------------------------------------------------------
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Tidy(int *this)
{
  int *v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int result; // eax
  int v6; // [esp-4h] [ebp-14h]
  char v8[4]; // [esp+4h] [ebp-Ch] BYREF
  char v9[4]; // [esp+8h] [ebp-8h] BYREF
  char v10[4]; // [esp+Ch] [ebp-4h] BYREF

  v6 = *(_DWORD *)std::vector<CSyncPacket::CElement>::begin(this, v10);
  v1 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::begin(
                this,
                v9);
  std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::erase(
    this,
    v8,
    *v1,
    v6);
  v2 = unknown_libname_10(this[1]);
  std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::destroy(v2);
  v3 = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(this[1]);
  std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::destroy(v3);
  v4 = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(this[1]);
  std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::destroy(v4);
  std::allocator<CSyncPacket::CElement>::deallocate(this[1], 1);
  this[1] = 0;
  this[2] = 0;
  return result;
}
// 404010: using guessed type _DWORD __cdecl unknown_libname_10(_DWORD);

//----- (00405770) --------------------------------------------------------
void *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::begin(_DWORD *this, void *a2)
{
  int *v2; // eax

  v2 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lmost(this);
  sub_403E30(a2, *v2);
  return a2;
}

//----- (004057A0) --------------------------------------------------------
_DWORD *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::erase(_DWORD *this, _DWORD *a2, int a3, char a4)
{
  void *v4; // eax
  void *v5; // eax
  _DWORD *result; // eax
  int *v7; // eax
  char v9[4]; // [esp+4h] [ebp-10h] BYREF
  char v10[4]; // [esp+8h] [ebp-Ch] BYREF
  char v11[4]; // [esp+Ch] [ebp-8h] BYREF
  char v12[4]; // [esp+10h] [ebp-4h] BYREF

  v4 = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::begin(
         this,
         v12);
  if ( (unsigned __int8)unknown_libname_18(v4)
    && (v5 = std::vector<CSyncPacket::CElement>::begin(this, v11), (unsigned __int8)unknown_libname_18(v5)) )
  {
    std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::clear(this);
    std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::begin(
      this,
      a2);
    result = a2;
  }
  else
  {
    while ( std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::operator!=((int)&a4) )
    {
      v7 = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::iterator::operator++(
             &a3,
             v10,
             0);
      std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::erase(
        this,
        v9,
        *v7);
    }
    *a2 = a3;
    result = a2;
  }
  return result;
}
// 405110: using guessed type _DWORD __stdcall unknown_libname_18(_DWORD);

//----- (00405840) --------------------------------------------------------
_DWORD *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::erase(int *this, _DWORD *a2, int a3)
{
  int v3; // eax
  int *v4; // eax
  int *v5; // eax
  int *v6; // eax
  _DWORD *v7; // esi
  _DWORD *v8; // esi
  int *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  int *v12; // eax
  _DWORD *v13; // esi
  char *v14; // eax
  int *v15; // eax
  int *v16; // eax
  int *v17; // eax
  int *v18; // eax
  _BYTE *v19; // esi
  int *v20; // eax
  int *v21; // eax
  int *v22; // eax
  int *v23; // eax
  int *v24; // eax
  _BYTE *v25; // esi
  int *v26; // eax
  char *v28; // [esp-4h] [ebp-74h]
  int v29; // [esp+4h] [ebp-6Ch]
  int v30; // [esp+8h] [ebp-68h]
  char v32[28]; // [esp+10h] [ebp-60h] BYREF
  char pExceptionObject[40]; // [esp+2Ch] [ebp-44h] BYREF
  void *v34; // [esp+54h] [ebp-1Ch]
  void *v35; // [esp+58h] [ebp-18h]
  void *v36; // [esp+5Ch] [ebp-14h]
  void *v37; // [esp+60h] [ebp-10h]
  int v38; // [esp+6Ch] [ebp-4h]

  v3 = unknown_libname_17(&a3);
  if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(v3) )
  {
    std::string::string(v32, "invalid map/set<T> iterator");
    v38 = 0;
    std::out_of_range::out_of_range((std::out_of_range *)pExceptionObject, (const std::out_of_range *)v32);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_std__);
  }
  v37 = (void *)unknown_libname_17(&a3);
  std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::iterator::operator++(&a3);
  v35 = v37;
  v4 = (int *)unknown_libname_10(v37);
  if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(*v4) )
  {
    v36 = *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v35);
  }
  else
  {
    v5 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v35);
    if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(*v5) )
    {
      v36 = *(void **)unknown_libname_10(v35);
    }
    else
    {
      v35 = (void *)unknown_libname_17(&a3);
      v36 = *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v35);
    }
  }
  if ( v35 == v37 )
  {
    v34 = *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v37);
    if ( !*(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil((int)v36) )
      *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v36) = v34;
    if ( *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this) == v37 )
    {
      *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this) = v36;
    }
    else if ( *(void **)unknown_libname_10(v34) == v37 )
    {
      *(_DWORD *)unknown_libname_10(v34) = v36;
    }
    else
    {
      *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v34) = v36;
    }
    if ( *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lmost(this) == v37 )
    {
      if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil((int)v36) )
        v30 = (int)v34;
      else
        v30 = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Max((int)v36);
      *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lmost(this) = v30;
    }
    if ( *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rmost(this) == v37 )
    {
      if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil((int)v36) )
        v29 = (int)v34;
      else
        v29 = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Min((int)v36);
      *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rmost(this) = v29;
    }
  }
  else
  {
    v6 = (int *)unknown_libname_10(v37);
    *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(*v6) = v35;
    v7 = (_DWORD *)unknown_libname_10(v37);
    *(_DWORD *)unknown_libname_10(v35) = *v7;
    if ( v35 == *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v37) )
    {
      v34 = v35;
    }
    else
    {
      v34 = *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v35);
      if ( !*(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil((int)v36) )
        *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v36) = v34;
      *(_DWORD *)unknown_libname_10(v34) = v36;
      v8 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v37);
      *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v35) = *v8;
      v9 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v37);
      *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(*v9) = v35;
    }
    if ( *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this) == v37 )
    {
      *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this) = v35;
    }
    else
    {
      v10 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v37);
      if ( *(void **)unknown_libname_10(*v10) == v37 )
      {
        v11 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v37);
        *(_DWORD *)unknown_libname_10(*v11) = v35;
      }
      else
      {
        v12 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v37);
        *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(*v12) = v35;
      }
    }
    v13 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v37);
    *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v35) = *v13;
    v28 = (char *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v37);
    v14 = (char *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v35);
    std::swap<char>(v14, v28);
  }
  if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v37) == 1 )
  {
    while ( 1 )
    {
      if ( v36 == *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this)
        || *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v36) != 1 )
      {
LABEL_63:
        *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v36) = 1;
        goto LABEL_64;
      }
      if ( v36 == *(void **)unknown_libname_10(v34) )
        break;
      v35 = *(void **)unknown_libname_10(v34);
      if ( !*(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v35) )
      {
        *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v35) = 1;
        *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v34) = 0;
        std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lrotate(
          this,
          (int)v34);
        v35 = *(void **)unknown_libname_10(v34);
      }
      if ( !*(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil((int)v35) )
      {
        v21 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v35);
        if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(*v21) != 1
          || (v22 = (int *)unknown_libname_10(v35),
              *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(*v22) != 1) )
        {
          v23 = (int *)unknown_libname_10(v35);
          if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(*v23) == 1 )
          {
            v24 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v35);
            *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(*v24) = 1;
            *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v35) = 0;
            std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rrotate(
              this,
              (int)v35);
            v35 = *(void **)unknown_libname_10(v34);
          }
          v25 = (_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v34);
          *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v35) = *v25;
          *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v34) = 1;
          v26 = (int *)unknown_libname_10(v35);
          *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(*v26) = 1;
          std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lrotate(
            this,
            (int)v34);
          goto LABEL_63;
        }
LABEL_50:
        *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v35) = 0;
        v36 = v34;
        goto LABEL_40;
      }
      v36 = v34;
LABEL_40:
      v34 = *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent((int)v36);
    }
    v35 = *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v34);
    if ( !*(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v35) )
    {
      *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v35) = 1;
      *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v34) = 0;
      std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rrotate(
        this,
        (int)v34);
      v35 = *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v34);
    }
    if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil((int)v35) )
    {
      v36 = v34;
      goto LABEL_40;
    }
    v15 = (int *)unknown_libname_10(v35);
    if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(*v15) != 1
      || (v16 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v35),
          *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(*v16) != 1) )
    {
      v17 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v35);
      if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(*v17) == 1 )
      {
        v18 = (int *)unknown_libname_10(v35);
        *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(*v18) = 1;
        *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v35) = 0;
        std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lrotate(
          this,
          (int)v35);
        v35 = *(void **)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v34);
      }
      v19 = (_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v34);
      *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v35) = *v19;
      *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color((int)v34) = 1;
      v20 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right((int)v35);
      *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Color(*v20) = 1;
      std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rrotate(
        this,
        (int)v34);
      goto LABEL_63;
    }
    goto LABEL_50;
  }
LABEL_64:
  std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node>::destroy(v37);
  std::allocator<CSyncPacket::CElement>::deallocate((int)v37, 1);
  if ( this[2] )
    --this[2];
  *a2 = a3;
  return a2;
}
// 404010: using guessed type _DWORD __cdecl unknown_libname_10(_DWORD);
// 405100: using guessed type int __thiscall unknown_libname_17(_DWORD);

//----- (00405FF0) --------------------------------------------------------
void __thiscall std::out_of_range::out_of_range(std::out_of_range *this, const std::out_of_range *that)
{
  std::logic_error::logic_error(this, that);
  *(_DWORD *)this = &std::out_of_range::`vftable';
}
// 43796C: using guessed type void *std::out_of_range::`vftable';

//----- (00406020) --------------------------------------------------------
void __thiscall std::out_of_range::~out_of_range(std::out_of_range *this)
{
  *(_DWORD *)this = &std::out_of_range::`vftable';
  std::logic_error::~logic_error(this);
}
// 43796C: using guessed type void *std::out_of_range::`vftable';

//----- (00406040) --------------------------------------------------------
_DWORD *__thiscall std::out_of_range::`vector deleting destructor'(_DWORD *this, char a2)
{
  std::out_of_range::~out_of_range((std::out_of_range *)this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (00406070) --------------------------------------------------------
_DWORD *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::iterator::operator++(int *this, _DWORD *a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  v4 = *this;
  std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::iterator::operator++(this);
  *a2 = v4;
  return a2;
}

//----- (004060A0) --------------------------------------------------------
exception *__thiscall std::out_of_range::out_of_range(exception *this, struct exception *a2)
{
  std::logic_error::logic_error(this, a2);
  this->__vftable = (exception_vtbl *)&std::out_of_range::`vftable';
  return this;
}
// 43796C: using guessed type void *std::out_of_range::`vftable';

//----- (004060D0) --------------------------------------------------------
int *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Rrotate(int *this, int a2)
{
  _DWORD *v2; // esi
  int *v3; // eax
  int *v4; // eax
  _DWORD *v5; // esi
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  int *v8; // eax
  int *result; // eax
  int v11; // [esp+8h] [ebp-4h]

  v11 = *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(a2);
  v2 = (_DWORD *)unknown_libname_10(v11);
  *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(a2) = *v2;
  v3 = (int *)unknown_libname_10(v11);
  if ( !*(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(*v3) )
  {
    v4 = (int *)unknown_libname_10(v11);
    *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(*v4) = a2;
  }
  v5 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(a2);
  *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(v11) = *v5;
  if ( a2 == *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this) )
  {
    *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this) = v11;
  }
  else
  {
    v6 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(a2);
    if ( a2 == *(_DWORD *)unknown_libname_10(*v6) )
    {
      v7 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(a2);
      *(_DWORD *)unknown_libname_10(*v7) = v11;
    }
    else
    {
      v8 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(a2);
      *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(*v8) = v11;
    }
  }
  *(_DWORD *)unknown_libname_10(v11) = a2;
  result = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(a2);
  *result = v11;
  return result;
}
// 404010: using guessed type _DWORD __cdecl unknown_libname_10(_DWORD);

//----- (00406200) --------------------------------------------------------
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Min(int a1)
{
  int *v1; // eax

  while ( 1 )
  {
    v1 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(a1);
    if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(*v1) )
      break;
    a1 = *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(a1);
  }
  return a1;
}

//----- (00406240) --------------------------------------------------------
int __cdecl std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Max(int a1)
{
  int *v1; // eax

  while ( 1 )
  {
    v1 = (int *)unknown_libname_10(a1);
    if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(*v1) )
      break;
    a1 = *(_DWORD *)unknown_libname_10(a1);
  }
  return a1;
}
// 404010: using guessed type _DWORD __cdecl unknown_libname_10(_DWORD);

//----- (00406280) --------------------------------------------------------
int *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Lrotate(int *this, int a2)
{
  _DWORD *v2; // esi
  int *v3; // eax
  int *v4; // eax
  _DWORD *v5; // esi
  int *v6; // eax
  int *v7; // eax
  _DWORD *v8; // eax
  int *result; // eax
  int v11; // [esp+8h] [ebp-4h]

  v11 = *(_DWORD *)unknown_libname_10(a2);
  v2 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(v11);
  *(_DWORD *)unknown_libname_10(a2) = *v2;
  v3 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(v11);
  if ( !*(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(*v3) )
  {
    v4 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(v11);
    *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(*v4) = a2;
  }
  v5 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(a2);
  *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(v11) = *v5;
  if ( a2 == *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this) )
  {
    *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Root(this) = v11;
  }
  else
  {
    v6 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(a2);
    if ( a2 == *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(*v6) )
    {
      v7 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(a2);
      *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(*v7) = v11;
    }
    else
    {
      v8 = (_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(a2);
      *(_DWORD *)unknown_libname_10(*v8) = v11;
    }
  }
  *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(v11) = a2;
  result = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(a2);
  *result = v11;
  return result;
}
// 404010: using guessed type _DWORD __cdecl unknown_libname_10(_DWORD);

//----- (004063B0) --------------------------------------------------------
void *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::iterator::operator++(void *this)
{
  std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::operator++(this);
  return this;
}

//----- (004063D0) --------------------------------------------------------
void *__thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::operator++(void *this)
{
  std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::_Inc((int *)this);
  return this;
}

//----- (004063F0) --------------------------------------------------------
int __thiscall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::_Inc(int *this)
{
  int result; // eax
  int *v2; // eax
  int *v3; // eax
  int v5; // [esp+4h] [ebp-4h]

  result = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(*this);
  if ( !*(_BYTE *)result )
  {
    v2 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(*this);
    if ( *(_BYTE *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(*v2) )
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Parent(*this);
        result = *(char *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Isnil(v5);
        if ( result )
          break;
        result = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(v5);
        if ( *this != *(_DWORD *)result )
          break;
        *this = v5;
      }
      *this = v5;
    }
    else
    {
      v3 = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Right(*this);
      result = std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Max(*v3);
      *this = result;
    }
  }
  return result;
}

//----- (004064B0) --------------------------------------------------------
char __cdecl std::swap<char>(char *a1, char *a2)
{
  char result; // al
  char v3; // [esp+3h] [ebp-1h]

  v3 = *a1;
  *a1 = *a2;
  result = v3;
  *a2 = v3;
  return result;
}

//----- (004064E0) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  unsigned int ThrdAddr; // [esp+0h] [ebp-24h] BYREF
  struct tagMSG Msg; // [esp+4h] [ebp-20h] BYREF
  HACCEL hAccTable; // [esp+20h] [ebp-4h]

  LoadStringA(hInstance, 0x67u, WindowName, 100);
  LoadStringA(hInstance, 0x6Du, ClassName, 100);
  MyRegisterClass(hInstance);
  CScreen::Open((CScreen *)&CScreen::s_pScreen, 200, 50);
  CScreen::Open(&CStatus::s_screen, 80, 20);
  stru_4441A4 = (CScreen *)&CScreen::s_pScreen;
  if ( !InitInstance(hInstance, nShowCmd) )
    return 0;
  hAccTable = LoadAcceleratorsA(hInstance, (LPCSTR)0x6D);
  hHandle = (HANDLE)_beginthreadex(0, 0, StartThread, 0, 0, &ThrdAddr);
  while ( GetMessageA(&Msg, 0, 0, 0) )
  {
    if ( !TranslateAcceleratorA(Msg.hwnd, hAccTable, &Msg) )
    {
      TranslateMessage(&Msg);
      DispatchMessageA(&Msg);
    }
  }
  return Msg.wParam;
}

//----- (004065D0) --------------------------------------------------------
ATOM __cdecl MyRegisterClass(HINSTANCE hInstance)
{
  WNDCLASSEXA v2; // [esp+0h] [ebp-30h] BYREF

  v2.cbSize = 48;
  v2.style = 3;
  v2.lpfnWndProc = WndProc;
  v2.cbClsExtra = 0;
  v2.cbWndExtra = 0;
  v2.hInstance = hInstance;
  v2.hIcon = LoadIconA(hInstance, (LPCSTR)0x6B);
  v2.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
  v2.hbrBackground = (HBRUSH)6;
  v2.lpszMenuName = (LPCSTR)109;
  v2.lpszClassName = ClassName;
  v2.hIconSm = LoadIconA(hInstance, (LPCSTR)0x6C);
  return RegisterClassExA(&v2);
}

//----- (00406650) --------------------------------------------------------
int __cdecl InitInstance(HINSTANCE__ *hInstance, int nCmdShow)
{
  HWND hWnd; // [esp+0h] [ebp-4h]

  ::hInstance = hInstance;
  hWnd = CreateWindowExA(0x300u, ClassName, WindowName, 0xCF0000u, 0x80000000, 0, 0x80000000, 0, 0, 0, hInstance, 0);
  if ( !hWnd )
    return 0;
  *(&stru_4441A4 + 1) = (CScreen *)hWnd;
  ShowWindow(hWnd, nCmdShow);
  UpdateWindow(hWnd);
  return 1;
}

//----- (004066D0) --------------------------------------------------------
int __stdcall TestException()
{
  int result; // eax

  ELOG("Exception Test\n");
  result = 0;
  MEMORY[0] = 0;
  return result;
}

//----- (00406770) --------------------------------------------------------
LRESULT __stdcall WndProc(HWND__ *hWnd, unsigned int message, unsigned int wParam, int lParam)
{
  int v5; // [esp+Ch] [ebp-18h]
  unsigned int v6; // [esp+10h] [ebp-14h]
  HANDLE hObject; // [esp+14h] [ebp-10h]
  unsigned int ThrdAddr[3]; // [esp+18h] [ebp-Ch] BYREF

  if ( message > 0x10 )
  {
    if ( message == 273 )
    {
      ThrdAddr[2] = (unsigned __int16)wParam;
      ThrdAddr[1] = HIWORD(wParam);
      if ( (unsigned __int16)wParam > 0x800Bu )
      {
        switch ( (unsigned __int16)wParam )
        {
          case 0x800Cu:
            KillTimer(hWnd, 1u);
            stru_4441A4 = (CScreen *)&CScreen::s_pScreen;
            CLog::Flush();
            LOG_INFO("Log Flushed");
            return 0;
          case 0x800Du:
            v6 = CIOSocket::AddIOThread((void *)((unsigned __int16)wParam - 32780));
            if ( v6 )
              ++CDBConfig::s_nNumberOfThreads;
            KillTimer(hWnd, 1u);
            stru_4441A4 = (CScreen *)&CScreen::s_pScreen;
            LOG_ERR("Add thread count(%d) thread id(%x)", CDBConfig::s_nNumberOfThreads, v6);
            return 0;
          case 0x8012u:
            goto LABEL_26;
          case 0x8013u:
            KillTimer(hWnd, 1u);
            stru_4441A4 = &CStatus::s_screen;
            CStatus::Update();
            SetTimer(hWnd, 1u, 0xBB8u, 0);
            return 0;
          default:
            return DefWindowProcA(hWnd, message, wParam, lParam);
        }
      }
      if ( (unsigned __int16)wParam == 32779 )
      {
        KillTimer(hWnd, 1u);
        stru_4441A4 = (CScreen *)&CScreen::s_pScreen;
        LOG_INFO("Stack dump started");
        UpdateWindow(hWnd);
        CIOSocket::DumpStack();
        LOG_INFO("Stack dump completed");
      }
      else if ( (unsigned __int16)wParam > 0x8009u )
      {
        if ( (unsigned __int16)wParam != 32778 )
          return DefWindowProcA(hWnd, message, wParam, lParam);
        KillTimer(hWnd, 1u);
        stru_4441A4 = (CScreen *)&CScreen::s_pScreen;
        LOG_INFO("Exception test started");
        UpdateWindow(hWnd);
        TestException();
        LOG_INFO("Exception test completed");
      }
      else
      {
        switch ( (unsigned __int16)wParam )
        {
          case 0x8009u:
            if ( CIOException::Disable() )
            {
              hObject = (HANDLE)_beginthreadex(0, 0, StopThread, (void *)lParam, 0, ThrdAddr);
              CloseHandle(hObject);
LABEL_26:
              KillTimer(hWnd, 1u);
              stru_4441A4 = (CScreen *)&CScreen::s_pScreen;
              InvalidateRect(hWnd, 0, 1);
            }
            break;
          case 0x68u:
            DialogBoxParamA(hInstance, (LPCSTR)0x67, hWnd, About, 0);
            break;
          case 0x69u:
            PostMessageA(hWnd, 0x10u, 0, 0);
            break;
          default:
            return DefWindowProcA(hWnd, message, wParam, lParam);
        }
      }
    }
    else
    {
      if ( message != 275 )
        return DefWindowProcA(hWnd, message, wParam, lParam);
      if ( wParam == 1 )
        CStatus::Update();
    }
  }
  else
  {
    switch ( message )
    {
      case 0x10u:
        if ( CIOException::IsEnable() )
        {
          v5 = MessageBoxA(hWnd, "Do you shutdown system?", "DBSvr", 3u);
          if ( v5 == 6 )
          {
            PostMessageA(hWnd, 0x111u, 0x8009u, 1);
            return 0;
          }
          if ( v5 == 2 )
            return 0;
        }
        DestroyWindow(hWnd);
        return 0;
      case 1u:
        SetTimer(hWnd, 2u, 0x36EE80u, 0);
        break;
      case 2u:
        PostQuitMessage(0);
        break;
      case 0xFu:
        CScreen::OnPaint(stru_4441A4);
        break;
      default:
        return DefWindowProcA(hWnd, message, wParam, lParam);
    }
  }
  return 0;
}

//----- (00406B20) --------------------------------------------------------
int __stdcall About(HWND__ *hDlg, unsigned int message, unsigned int wParam, int lParam)
{
  if ( message == 272 )
    return 1;
  if ( message != 273 || (unsigned __int16)wParam != 1 && (unsigned __int16)wParam != 2 )
    return 0;
  EndDialog(hDlg, (unsigned __int16)wParam);
  return 1;
}

//----- (00406B90) --------------------------------------------------------
unsigned int __stdcall StartThread(void *formal)
{
  std::_String_base *v1; // eax
  const CHAR *v2; // eax
  unsigned int result; // eax
  const char *v4; // eax
  const char *v5; // eax
  __time32_t v6; // eax
  const char *v7; // [esp-8h] [ebp-210h]
  const char *v8; // [esp-4h] [ebp-20Ch]
  std::_String_base *v9; // [esp+0h] [ebp-208h]
  void *v10; // [esp+8h] [ebp-200h]
  char v11[28]; // [esp+10h] [ebp-1F8h] BYREF
  char v12[28]; // [esp+2Ch] [ebp-1DCh] BYREF
  CDB v13; // [esp+48h] [ebp-1C0h] BYREF
  char v14[4]; // [esp+58h] [ebp-1B0h]
  struct tm *v15; // [esp+5Ch] [ebp-1ACh]
  __time32_t Time; // [esp+60h] [ebp-1A8h] BYREF
  struct WSAData WSAData; // [esp+64h] [ebp-1A4h] BYREF
  int v18; // [esp+204h] [ebp-4h]

  CIOException::Disable();
  v10 = sub_41DD60(v11);
  v18 = 0;
  v9 = (std::_String_base *)std::string::string(v12, "Global\\");
  LOBYTE(v18) = 1;
  v1 = sub_406EB0(v9, (int)v10);
  v2 = (const CHAR *)std::string::c_str(v1);
  CreateMutexA(0, 0, v2);
  LOBYTE(v18) = 0;
  std::string::~string(v12);
  v18 = -1;
  std::string::~string(v11);
  if ( GetLastError() )
  {
    LOG_INFO("Another Server is running");
    result = 0;
  }
  else
  {
    LOG_NORMAL("Server started");
    *(_DWORD *)v14 = WSAStartup(0x202u, &WSAData);
    if ( *(_DWORD *)v14 )
    {
      LOG_ERR("WSAStartup error 0x%x", *(_DWORD *)v14);
      result = 0;
    }
    else if ( CDBConfig::Open() )
    {
      InitRandom();
      v8 = (const char *)std::string::c_str(CDBConfig::s_strMailTo);
      v7 = (const char *)std::string::c_str(CDBConfig::s_strMailFrom);
      v4 = (const char *)std::string::c_str(CDBConfig::s_strMailServer);
      CIOException::Open(v4, v7, v8);
      v5 = (const char *)std::string::c_str(CDBConfig::s_strODBC);
      if ( CDB::Open(v5) )
      {
        CDB::CDB(&v13);
        v18 = 2;
        v6 = time(0);
        CDB::ExecuteNoData(&v13, "DELETE Mail WHERE [Type] = %d AND [TimetE] <= %d", 0, v6);
        v18 = -1;
        CDB::~CDB(&v13);
        CIOSocket::CreateIOThread(CDBConfig::s_nNumberOfThreads);
        sub_410560();
        Time = dword_43D97C + 32400;
        v15 = gmtime(&Time);
        LOG_NORMAL(
          "Server is ready on port %d (time stamp: %02d/%02d/%02d %02d:%02d:%02d (KR))",
          *(_DWORD *)&nPort,
          v15->tm_year % 100,
          v15->tm_mon + 1,
          v15->tm_mday,
          v15->tm_hour,
          v15->tm_min,
          v15->tm_sec);
        CLog::Flush();
        CIOException::Enable();
        CIOSocket::WaitThread(0);
      }
      else
      {
        LOG_ERR("DB Login failed");
      }
      result = 0;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 43D97C: using guessed type int dword_43D97C;

//----- (00406E30) --------------------------------------------------------
unsigned int __stdcall StopThread(void *arglist)
{
  LOG_NORMAL("Shutdown started");
  CServer::Stop();
  CServer::Shutdown();
  do
    Sleep(0x3E8u);
  while ( *(&stru_4441A4 + 5) );
  CIOSocket::CloseIOThread();
  WaitForSingleObject(hHandle, 0xFFFFFFFF);
  CDB::Close();
  CDBConfig::Close();
  LOG_NORMAL("Shutdown completed");
  CLog::Flush();
  if ( arglist )
    PostMessageA((HWND)*(&stru_4441A4 + 1), 0x10u, 0, 0);
  return 0;
}

//----- (00406EB0) --------------------------------------------------------
std::_String_base *__thiscall sub_406EB0(std::_String_base *this, int a1)
{
  return sub_406ED0(this, a1, 0, 0xFFFFFFFF);
}

//----- (00406ED0) --------------------------------------------------------
std::_String_base *__thiscall sub_406ED0(std::_String_base *this, int a2, int a3, size_t Size)
{
  int v4; // eax
  void *v6; // [esp-8h] [ebp-10h]
  unsigned int v8; // [esp+4h] [ebp-4h]
  size_t v9; // [esp+4h] [ebp-4h]

  if ( unknown_libname_12(a2) < (unsigned int)a3 )
    std::_String_base::_Xran(this);
  v8 = unknown_libname_12(a2) - a3;
  if ( v8 < Size )
    Size = v8;
  if ( -1 - *(_DWORD *)&this[20] <= Size )
    std::_String_base::_Xlen(this);
  if ( Size )
  {
    v9 = Size + *(_DWORD *)&this[20];
    if ( std::string::_Grow((size_t *)this, v9, 0) )
    {
      v6 = (void *)(a3 + unknown_libname_11(a2));
      v4 = unknown_libname_11(this);
      std::char_traits<char>::copy((void *)(*(_DWORD *)&this[20] + v4), v6, Size);
      std::string::_Eos(this, v9);
    }
  }
  return this;
}
// 404600: using guessed type int __thiscall unknown_libname_11(_DWORD);
// 4046E0: using guessed type int __thiscall unknown_libname_12(_DWORD);

//----- (00406FB0) --------------------------------------------------------
void __cdecl DesMem(void *buf, int mlen, int isencrypting)
{
  while ( mlen > 0 )
  {
    if ( isencrypting )
      endes((char *)buf, (char *)buf);
    else
      dedes((char *)buf, (char *)buf);
    mlen -= 8;
    buf = (char *)buf + 8;
  }
}

//----- (00407010) --------------------------------------------------------
void __cdecl endes(char *inblock, char *outblock)
{
  char v2[8]; // [esp+0h] [ebp-A4h] BYREF
  char *v3; // [esp+8h] [ebp-9Ch] BYREF
  char outblocka[132]; // [esp+Ch] [ebp-98h] BYREF
  char v5[8]; // [esp+90h] [ebp-14h] BYREF
  char **v6; // [esp+9Ch] [ebp-8h]
  int num; // [esp+A0h] [ebp-4h]

  permute(inblock, iperm, outblocka);
  for ( num = 0; num < 16; ++num )
    iter(num, &outblocka[8 * num], &outblocka[8 * num + 8]);
  v2[0] = v5[0];
  v2[1] = v5[1];
  v2[2] = v5[2];
  v2[3] = v5[3];
  v2[4] = outblocka[128];
  v2[5] = outblocka[129];
  v2[6] = outblocka[130];
  v2[7] = outblocka[131];
  v6 = &v3;
  v3 = v5;
  permute(v2, fperm, outblock);
}

//----- (004071E0) --------------------------------------------------------
void __cdecl permute(char *inblock, char (*perm)[16][8], char *outblock)
{
  int i; // [esp+0h] [ebp-18h]
  char *v4; // [esp+4h] [ebp-14h]
  char *v5; // [esp+8h] [ebp-10h]
  char *v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]
  int j; // [esp+Ch] [ebp-Ch]
  char *v10; // [esp+14h] [ebp-4h]

  v7 = 0;
  v5 = outblock;
  while ( v7 < 8 )
  {
    *v5++ = 0;
    ++v7;
  }
  for ( i = 0; i < 16; i += 2 )
  {
    v6 = outblock;
    v10 = &(*perm)[16 * i][8 * ((*inblock >> 4) & 0xF)];
    v4 = &(*perm)[16 * i + 16][8 * (*inblock & 0xF)];
    for ( j = 0; j < 8; ++j )
      *v6++ |= *v4++ | *v10++;
    ++inblock;
  }
}

//----- (004072E0) --------------------------------------------------------
void __cdecl iter(int num, char *inblock, char *outblock)
{
  char v3[4]; // [esp+4h] [ebp-Ch] BYREF
  char *v4; // [esp+8h] [ebp-8h]
  char *v5; // [esp+Ch] [ebp-4h]

  v4 = inblock + 4;
  f((int)(inblock + 4), num, (int)v3);
  *outblock = *v4++;
  outblock[1] = *v4++;
  outblock[2] = *v4++;
  outblock[3] = *v4;
  v4 = inblock;
  v5 = v3;
  outblock[4] = v3[0] ^ *inblock;
  outblock[5] = *++v5 ^ *++v4;
  outblock[6] = *++v5 ^ *++v4;
  outblock[7] = *++v5 ^ *++v4;
}

//----- (00407450) --------------------------------------------------------
void __cdecl f(int a1, int a2, int a3)
{
  char v3[8]; // [esp+0h] [ebp-24h] BYREF
  char *v4; // [esp+8h] [ebp-1Ch]
  char *v5; // [esp+Ch] [ebp-18h]
  char v6[4]; // [esp+10h] [ebp-14h] BYREF
  char *bigright; // [esp+14h] [ebp-10h]
  char v8[8]; // [esp+18h] [ebp-Ch] BYREF

  v5 = &byte_43DAF0[6 * a2];
  bigright = v8;
  v4 = v3;
  expand((char *)a1, v8);
  *v4++ = *v5++ ^ *bigright;
  *v4++ = *v5 ^ *++bigright;
  *v4++ = *++v5 ^ *++bigright;
  *v4++ = *++v5 ^ *++bigright;
  *v4++ = *++v5 ^ *++bigright;
  *v4++ = *++v5 ^ *++bigright;
  ++v5;
  ++bigright;
  sub_4078C0(v3, v6);
  perm32(v6, (char *)a3);
}

//----- (004075D0) --------------------------------------------------------
void __cdecl perm32(char *inblock, char *outblock)
{
  int i; // [esp+0h] [ebp-10h]
  char *v3; // [esp+4h] [ebp-Ch]

  *outblock = 0;
  outblock[1] = 0;
  outblock[2] = 0;
  outblock[3] = 0;
  for ( i = 0; i < 4; ++i )
  {
    v3 = &byte_43DB50[1024 * i + 4 * (unsigned __int8)*inblock];
    *outblock |= *v3++;
    outblock[1] |= *v3++;
    outblock[2] |= *v3;
    outblock[3] |= v3[1];
    ++inblock;
  }
}

//----- (00407710) --------------------------------------------------------
void __cdecl expand(char *right, char *bigright)
{
  char v2; // [esp+3h] [ebp-11h]
  char v3; // [esp+Bh] [ebp-9h]
  char v4; // [esp+12h] [ebp-2h]
  char v5; // [esp+13h] [ebp-1h]

  v3 = *right;
  v5 = right[1];
  v4 = right[2];
  v2 = right[3];
  *bigright = ((*right & 0x18) >> 3) | ((*right & 0xF8) >> 1) | ((v2 & 1) << 7);
  bigright[1] = ((v5 & 0xE0) >> 5) | (8 * (v3 & 1)) | ((v5 & 0x80) >> 3) | (32 * (v3 & 7));
  bigright[2] = ((v4 & 0x80) >> 7) | (2 * (v5 & 0x1F)) | (8 * (v5 & 0x18));
  bigright[3] = ((v4 & 0x18) >> 3) | ((v4 & 0xF8) >> 1) | ((v5 & 1) << 7);
  bigright[4] = ((v2 & 0xE0) >> 5) | (8 * (v4 & 1)) | ((v2 & 0x80) >> 3) | (32 * (v4 & 7));
  bigright[5] = ((v3 & 0x80) >> 7) | (2 * (v2 & 0x1F)) | (8 * (v2 & 0x18));
}

//----- (004078C0) --------------------------------------------------------
_BYTE *__cdecl sub_4078C0(char *a1, _BYTE *a2)
{
  unsigned __int8 v3; // [esp+0h] [ebp-20h]
  int v4; // [esp+8h] [ebp-18h]
  __int16 v5; // [esp+Ch] [ebp-14h]
  unsigned __int8 v6; // [esp+14h] [ebp-Ch]
  int v7; // [esp+18h] [ebp-8h]

  v7 = a1[1];
  v3 = a1[2];
  v5 = a1[3];
  v4 = a1[4];
  v6 = a1[5];
  *a2 = byte_43EB50[((v7 >> 4) & 0xF | (unsigned __int16)(16 * *a1)) & 0xFFF];
  a2[1] = byte_43FB50[(v3 | (unsigned __int16)((_WORD)v7 << 8)) & 0xFFF];
  a2[2] = byte_440B50[((v4 >> 4) & 0xF | (unsigned __int16)(16 * v5)) & 0xFFF];
  a2[3] = byte_441B50[(v6 | (unsigned __int16)((_WORD)v4 << 8)) & 0xFFF];
  return a2 + 4;
}

//----- (004079F0) --------------------------------------------------------
void __cdecl dedes(char *inblock, char *outblock)
{
  char v2[8]; // [esp+0h] [ebp-A4h] BYREF
  char *v3; // [esp+8h] [ebp-9Ch] BYREF
  char outblocka[132]; // [esp+Ch] [ebp-98h] BYREF
  char v5[8]; // [esp+90h] [ebp-14h] BYREF
  char **v6; // [esp+9Ch] [ebp-8h]
  int i; // [esp+A0h] [ebp-4h]

  permute(inblock, iperm, outblocka);
  for ( i = 0; i < 16; ++i )
    iter(15 - i, &outblocka[8 * i], &outblocka[8 * i + 8]);
  v2[0] = v5[0];
  v2[1] = v5[1];
  v2[2] = v5[2];
  v2[3] = v5[3];
  v2[4] = outblocka[128];
  v2[5] = outblocka[129];
  v2[6] = outblocka[130];
  v2[7] = outblocka[131];
  v6 = &v3;
  v3 = v5;
  permute(v2, fperm, outblock);
}

//----- (00407BF0) --------------------------------------------------------
void __cdecl DesKeyInit(char *password)
{
  char key64bit[8]; // [esp+0h] [ebp-14h] BYREF
  char *v2; // [esp+Ch] [ebp-8h]
  int i; // [esp+10h] [ebp-4h]

  memset(key64bit, 0, sizeof(key64bit));
  v2 = key64bit;
  for ( i = 0; *password && i < 40; ++i )
    v2[i % 8] ^= *password++;
  perminit(iperm, p);
  perminit(fperm, fp);
  kinit(key64bit);
  sinit();
  p32init();
}

//----- (00407CC0) --------------------------------------------------------
void __stdcall sinit()
{
  char v0; // bl
  int j; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 4096; ++j )
    {
      v0 = 16 * getcomp(2 * i, j >> 6);
      byte_43EB50[4096 * i + j] = getcomp(2 * i + 1, j & 0x3F) & 0xF | v0;
    }
  }
}

//----- (00407D50) --------------------------------------------------------
int __cdecl getcomp(int k, int v)
{
  return byte_43C218[64 * k + 16 * (v & 1 | ((v & 0x20) >> 4)) + ((v & 0x1F) >> 1)];
}

//----- (00407D90) --------------------------------------------------------
void __cdecl kinit(char *key64bit)
{
  int v1; // [esp+0h] [ebp-14h]
  int i; // [esp+4h] [ebp-10h]
  int k; // [esp+4h] [ebp-10h]
  int m; // [esp+4h] [ebp-10h]
  int n; // [esp+4h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-8h]
  int j; // [esp+10h] [ebp-4h]
  int l; // [esp+10h] [ebp-4h]

  for ( i = 0; i < 56; ++i )
    pc1m[i] = (bytebit[(byte_43C1A0[i] - 1) & 7] & key64bit[(byte_43C1A0[i] - 1) >> 3]) != 0;
  for ( j = 0; j < 16; ++j )
  {
    for ( k = 0; k < 6; ++k )
      byte_43DAF0[6 * j + k] = 0;
  }
  for ( l = 0; l < 16; ++l )
  {
    for ( m = 0; m < 56; ++m )
    {
      v6 = m + totrot[l];
      if ( v6 >= (m >= 28 ? 56 : 28) )
        v1 = v6 - 28;
      else
        v1 = m + totrot[l];
      pcr[m] = pc1m[v1];
    }
    for ( n = 0; n < 48; ++n )
    {
      if ( byte_443B4F[pc2[n]] )
        byte_43DAF0[6 * l + (n >> 3)] |= LOBYTE(bytebit[n & 7]);
    }
  }
}

//----- (00407F30) --------------------------------------------------------
int __stdcall p32init()
{
  int result; // eax
  int j; // [esp+4h] [ebp-14h]
  int m; // [esp+4h] [ebp-14h]
  int v3; // [esp+Ch] [ebp-Ch]
  int k; // [esp+10h] [ebp-8h]
  int n; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int l; // [esp+14h] [ebp-4h]

  for ( i = 0; i < 4; ++i )
  {
    for ( j = 0; j < 256; ++j )
    {
      for ( k = 0; k < 4; ++k )
        byte_43DB50[1024 * i + 4 * j + k] = 0;
    }
    result = i + 1;
  }
  for ( l = 0; l < 4; ++l )
  {
    for ( m = 0; m < 256; ++m )
    {
      for ( n = 0; n < 32; ++n )
      {
        v3 = byte_43C418[n] - 1;
        if ( v3 >> 3 == l && (bytebit[v3 & 7] & m) != 0 )
          byte_43DB50[1024 * l + 4 * m + (n >> 3)] |= LOBYTE(bytebit[n & 7]);
      }
      result = m + 1;
    }
  }
  return result;
}

//----- (00408080) --------------------------------------------------------
void __cdecl perminit(char (*perm)[16][8], char *p)
{
  int j; // [esp+4h] [ebp-14h]
  int m; // [esp+4h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-Ch]
  int k; // [esp+10h] [ebp-8h]
  int n; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int l; // [esp+14h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
  {
    for ( j = 0; j < 16; ++j )
    {
      for ( k = 0; k < 8; ++k )
        (*perm)[16 * i][8 * j + k] = 0;
    }
  }
  for ( l = 0; l < 16; ++l )
  {
    for ( m = 0; m < 16; ++m )
    {
      for ( n = 0; n < 64; ++n )
      {
        v4 = p[n] - 1;
        if ( v4 >> 2 == l && (nibblebit[v4 & 3] & m) != 0 )
          (*perm)[16 * l][8 * m + (n >> 3)] |= LOBYTE(bytebit[n & 7]);
      }
    }
  }
}

//----- (004081C0) --------------------------------------------------------
void __cdecl ExclusiveOr(char *dest, char *src)
{
  int v2; // eax
  int v3; // [esp+0h] [ebp-4h]

  v3 = 8;
  while ( 1 )
  {
    v2 = v3--;
    if ( v2 <= 0 )
      break;
    *dest++ ^= *src++;
  }
}

//----- (00408210) --------------------------------------------------------
int __cdecl DesWriteBlockEx(void *buf, int len)
{
  int v2; // eax
  char v4; // [esp+3h] [ebp-9h]
  char *src; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  src = (char *)buf;
  v4 = 8 - (len & 7);
  memset((char *)buf + len, v4, v4);
  v6 = ((len + v4) >> 3) - 1;
  endes(src, src);
  while ( 1 )
  {
    v2 = v6--;
    if ( v2 <= 0 )
      break;
    ExclusiveOr(src + 8, src);
    src += 8;
    endes(src, src);
  }
  return len + v4;
}

//----- (004082B0) --------------------------------------------------------
int __cdecl DesReadBlockEx(void *buf, int len)
{
  int v3; // eax
  char *dest; // [esp+0h] [ebp-8h]
  int v5; // [esp+4h] [ebp-4h]

  v5 = (len >> 3) - 1;
  if ( v5 < 0 )
    return 0;
  dest = (char *)buf + 8 * v5;
  dedes(dest, dest);
  while ( 1 )
  {
    v3 = v5--;
    if ( v3 <= 0 )
      break;
    ExclusiveOr(dest, dest - 8);
    dest -= 8;
    dedes(dest, dest);
  }
  return len - *((char *)buf + len - 1);
}

//----- (00408340) --------------------------------------------------------
unsigned int __usercall SnapCurrentProcessMiniDump@<eax>(DWORD a1@<eax>, DWORD a2@<edx>, DWORD a3@<ecx>, DWORD a4@<ebx>, DWORD a5@<edi>, DWORD a6@<esi>, _CONTEXT *lpContext)
{
  HANDLE v7; // eax
  DWORD vars0; // [esp+2ECh] [ebp+0h]
  DWORD retaddr; // [esp+2F0h] [ebp+4h]

  memset(lpContext, 0, sizeof(_CONTEXT));
  lpContext->ContextFlags = 65599;
  v7 = GetCurrentThread();
  if ( !GetThreadContext(v7, lpContext) )
    return 0;
  lpContext->Eax = a1;
  lpContext->Ebx = a4;
  lpContext->Ecx = a3;
  lpContext->Edx = a2;
  lpContext->Edi = a5;
  lpContext->Esi = a6;
  lpContext->SegGs = (unsigned __int16)__GS__;
  lpContext->SegFs = (unsigned __int16)__FS__;
  lpContext->SegEs = (unsigned __int16)__ES__;
  lpContext->SegDs = (unsigned __int16)__DS__;
  lpContext->SegCs = (unsigned __int16)__CS__;
  lpContext->SegSs = (unsigned __int16)__SS__;
  lpContext->Ebp = vars0;
  lpContext->Eip = retaddr;
  return 1;
}
// 4084B0: variable 'vars0' is possibly undefined

//----- (00408500) --------------------------------------------------------
void __thiscall CIOException::CInit::CInit(CIOException::CInit *this)
{
  char *v1; // eax
  char *lpString1; // [esp+4h] [ebp-4h]

  InitializeCriticalSection(&CriticalSection);
  GetModuleFileNameA(0, body, 0x104u);
  v1 = GetFilePart(body);
  lstrcpyA(v1, "Exception.txt");
  GetModuleFileNameA(0, g_szDumpPath, 0x104u);
  lpString1 = GetFilePart(g_szDumpPath);
  lstrcpyA(lpString1, "Exception.dmp");
  Time = time(0);
  lpTopLevelExceptionFilter = SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)RecordExceptionInfo);
  _set_security_error_handler((int)SecurityHandler);
}

//----- (004085B0) --------------------------------------------------------
char *__cdecl GetFilePart(char *source)
{
  char *v2; // [esp+0h] [ebp-4h]
  char *v3; // [esp+0h] [ebp-4h]

  v2 = strrchr(source, 92);
  if ( v2 )
    v3 = v2 + 1;
  else
    v3 = source;
  return v3;
}

//----- (004085F0) --------------------------------------------------------
void __cdecl __noreturn SecurityHandler()
{
  DWORD v0; // ebx
  DWORD v1; // edi
  DWORD v2; // esi

  ELOG("Buffer Overrun\n");
  if ( g_nEnable )
  {
    cleanup();
    GenerateExceptionReport(v0, v1, v2, 0);
    sendMail();
    cleanup_0();
  }
  ExitProcess(1u);
}
// 408610: variable 'v0' is possibly undefined
// 408610: variable 'v1' is possibly undefined
// 408610: variable 'v2' is possibly undefined
// 40AA60: using guessed type int cleanup(void);
// 40AA70: using guessed type int cleanup_0(void);

//----- (00408630) --------------------------------------------------------
BOOL __stdcall sendMail()
{
  __time32_t Time; // [esp+0h] [ebp-118h] BYREF
  LPSTR v2; // [esp+4h] [ebp-114h]
  CHAR NewFileName[264]; // [esp+8h] [ebp-110h] BYREF
  struct tm *v4; // [esp+114h] [ebp-4h]

  if ( host )
    sendMail_0(host, g_szMailFrom, g_szMailTo, body);
  strcpy(NewFileName, body);
  v2 = GetFilePart(NewFileName);
  time(&Time);
  v4 = localtime(&Time);
  wsprintfA(
    v2,
    "Exception\\%02d%02d%02d.%02d%02d%02d.dbg.txt",
    v4->tm_year % 100,
    v4->tm_mon + 1,
    v4->tm_mday,
    v4->tm_hour,
    v4->tm_min,
    v4->tm_sec);
  MoveFileExA(body, NewFileName, 1u);
  wsprintfA(
    v2,
    "Exception\\%02d%02d%02d.%02d%02d%02d.dbg.dmp",
    v4->tm_year % 100,
    v4->tm_mon + 1,
    v4->tm_mday,
    v4->tm_hour,
    v4->tm_min,
    v4->tm_sec);
  MoveFileExA(g_szDumpPath, NewFileName, 1u);
  DeleteFileA(body);
  return DeleteFileA(g_szDumpPath);
}

//----- (004087A0) --------------------------------------------------------
int __cdecl sendMail_0(const char *host, const char *from, const char *to, const char *body)
{
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int namelen; // [esp+0h] [ebp-9D8h] BYREF
  size_t v14; // [esp+4h] [ebp-9D4h]
  struct hostent *v15; // [esp+8h] [ebp-9D0h]
  char *Str; // [esp+Ch] [ebp-9CCh]
  char optval[4]; // [esp+10h] [ebp-9C8h] BYREF
  struct sockaddr name; // [esp+14h] [ebp-9C4h] BYREF
  int v19; // [esp+24h] [ebp-9B4h]
  SOCKET s; // [esp+28h] [ebp-9B0h]
  int v21; // [esp+2Ch] [ebp-9ACh]
  char buf[2048]; // [esp+30h] [ebp-9A8h] BYREF
  struct WSAData WSAData; // [esp+830h] [ebp-1A8h] BYREF
  struct sockaddr v24; // [esp+9C4h] [ebp-14h] BYREF

  v21 = 0;
  if ( WSAStartup(0x202u, &WSAData) )
    return 0;
  s = socket(2, 1, 0);
  if ( s == -1 )
  {
    WSACleanup();
    return 0;
  }
  *(_DWORD *)optval = 5000;
  v19 = setsockopt(s, 0xFFFF, 4102, optval, 4);
  if ( v19 != -1 )
  {
    *(_DWORD *)optval = 5000;
    v19 = setsockopt(s, 0xFFFF, 4101, optval, 4);
    if ( v19 != -1 )
    {
      name.sa_family = 2;
      *(_DWORD *)&name.sa_data[2] = 0;
      *(_WORD *)name.sa_data = 0;
      if ( bind(s, &name, 16) != -1 )
      {
        name.sa_family = 2;
        *(_DWORD *)&name.sa_data[2] = inet_addr(host);
        if ( *(_DWORD *)&name.sa_data[2] != -1 )
        {
LABEL_11:
          *(_WORD *)name.sa_data = htons(0x19u);
          if ( connect(s, &name, 16) != -1 )
          {
            recv(s, buf, 2048, 0);
            Str = "HELO www.inixsoft.com\r\n";
            v5 = strlen("HELO www.inixsoft.com\r\n");
            if ( send(s, "HELO www.inixsoft.com\r\n", v5, 0) > 0 )
            {
              recv(s, buf, 2048, 0);
              sprintf(buf, "MAIL From: <%s>\r\n", from);
              v6 = strlen(buf);
              if ( send(s, buf, v6, 0) > 0 )
              {
                recv(s, buf, 2048, 0);
                for ( Str = (char *)to; ; Str += v14 )
                {
                  Str += strspn(Str, " ,");
                  if ( !*Str )
                    break;
                  v14 = strcspn(Str, ",");
                  sprintf(buf, "RCPT To: <%.*s>\r\n", v14, Str);
                  v7 = strlen(buf);
                  if ( send(s, buf, v7, 0) <= 0 )
                    goto exit;
                  recv(s, buf, 2048, 0);
                }
                Str = "DATA\r\n";
                v8 = strlen("DATA\r\n");
                if ( send(s, "DATA\r\n", v8, 0) > 0 )
                {
                  recv(s, buf, 2048, 0);
                  memset(&v24, 0, sizeof(v24));
                  namelen = 16;
                  getsockname(s, &v24, &namelen);
                  sprintf(buf, "From: <%s>\r\n", from);
                  v9 = strlen(buf);
                  if ( send(s, buf, v9, 0) > 0 )
                  {
                    sprintf(
                      buf,
                      "Subject: Exception (%d.%d.%d.%d)\r\n\r\n\r\n",
                      (unsigned __int8)v24.sa_data[2],
                      (unsigned __int8)v24.sa_data[3],
                      (unsigned __int8)v24.sa_data[4],
                      (unsigned __int8)v24.sa_data[5]);
                    v10 = strlen(buf);
                    if ( send(s, buf, v10, 0) > 0 )
                    {
                      if ( sendFile(s, body) )
                      {
                        Str = "\r\n.\r\n";
                        v11 = strlen("\r\n.\r\n");
                        if ( send(s, Str, v11, 0) > 0 )
                        {
                          recv(s, buf, 2048, 0);
                          Str = "QUIT\r\n";
                          v12 = strlen("QUIT\r\n");
                          if ( send(s, Str, v12, 0) > 0 )
                          {
                            recv(s, buf, 2048, 0);
                            v21 = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          goto exit;
        }
        v15 = gethostbyname(host);
        if ( v15 )
        {
          memcpy(&name.sa_data[2], *(const void **)v15->h_addr_list, v15->h_length);
          goto LABEL_11;
        }
      }
    }
  }
exit:
  closesocket(s);
  WSACleanup();
  return v21;
}

//----- (00408D10) --------------------------------------------------------
int __cdecl sendFile(unsigned int sock, const char *name)
{
  DWORD NumberOfBytesRead; // [esp+0h] [ebp-40Ch] BYREF
  char Buffer[1024]; // [esp+4h] [ebp-408h] BYREF
  HANDLE hFile; // [esp+408h] [ebp-4h]

  hFile = CreateFileA(name, 0x80000000, 1u, 0, 3u, 0, 0);
  if ( hFile == (HANDLE)-1 )
    return 1;
  do
  {
    if ( !ReadFile(hFile, Buffer, 0x400u, &NumberOfBytesRead, 0) || !NumberOfBytesRead )
    {
      CloseHandle(hFile);
      return 1;
    }
  }
  while ( send(sock, Buffer, NumberOfBytesRead, 0) > 0 );
  return 0;
}

//----- (00408DC0) --------------------------------------------------------
void __usercall GenerateExceptionReport(DWORD a1@<ebx>, DWORD a2@<edi>, DWORD a3@<esi>, _EXCEPTION_POINTERS *data)
{
  DWORD v4; // eax
  DWORD v5; // eax
  DWORD v6; // ecx
  const char *v7; // eax
  HANDLE v8; // eax
  HANDLE v9; // eax
  int v10; // [esp-1Ch] [ebp-B8Ch]
  int v11; // [esp-18h] [ebp-B88h]
  int v12; // [esp-14h] [ebp-B84h]
  int v13; // [esp-10h] [ebp-B80h]
  int v14; // [esp-Ch] [ebp-B7Ch]
  const char *v15; // [esp-Ch] [ebp-B7Ch]
  int v16; // [esp-8h] [ebp-B78h]
  DWORD v17; // [esp-8h] [ebp-B78h]
  DWORD v18; // [esp-4h] [ebp-B74h]
  const char *v19; // [esp+Ch] [ebp-B64h]
  DWORD v20; // [esp+10h] [ebp-B60h]
  int i; // [esp+14h] [ebp-B5Ch]
  CHAR v22[1004]; // [esp+18h] [ebp-B58h] BYREF
  const char *v23; // [esp+404h] [ebp-76Ch]
  CONTEXT Context; // [esp+408h] [ebp-768h] BYREF
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+6D8h] [ebp-498h] BYREF
  char *v26; // [esp+6F4h] [ebp-47Ch]
  _CONTEXT ContextRecord; // [esp+6F8h] [ebp-478h] BYREF
  struct tm *v28; // [esp+9CCh] [ebp-1A4h]
  struct _SYSTEMTIME SystemTime; // [esp+9D0h] [ebp-1A0h] BYREF
  int v30[21]; // [esp+9E0h] [ebp-190h] BYREF
  DWORD v31; // [esp+A34h] [ebp-13Ch]
  int v32[2]; // [esp+A38h] [ebp-138h] BYREF
  _EXCEPTION_RECORD *v33; // [esp+A40h] [ebp-130h]
  HANDLE hFile; // [esp+A44h] [ebp-12Ch]
  CHAR Filename[268]; // [esp+A48h] [ebp-128h] BYREF
  CPPEH_RECORD ms_exc; // [esp+B58h] [ebp-18h]

  hFile = CreateFileA(body, 0x40000000u, 1u, 0, 4u, 0x80000080, 0);
  if ( hFile == (HANDLE)-1 )
  {
    OutputDebugStringA("Error creating exception report");
  }
  else
  {
    SetFilePointer(hFile, 0, 0, 2u);
    SystemTime.wYear = 0;
    *(_DWORD *)&SystemTime.wMonth = 0;
    *(_DWORD *)&SystemTime.wDay = 0;
    *(_DWORD *)&SystemTime.wMinute = 0;
    SystemTime.wMilliseconds = 0;
    GetLocalTime(&SystemTime);
    if ( Target )
      v19 = "first excpetion";
    else
      v19 = (const char *)&unk_42AFCC;
    v16 = SystemTime.wSecond;
    v14 = SystemTime.wMinute;
    v13 = SystemTime.wHour;
    v12 = SystemTime.wDay;
    v11 = SystemTime.wMonth;
    v10 = SystemTime.wYear;
    v4 = GetCurrentThreadId();
    v5 = hprintf(
           hFile,
           "[%x %04d/%02d/%02d %02d:%02d:%02d]: ======================= %s\r\n",
           v4,
           v10,
           v11,
           v12,
           v13,
           v14,
           v16,
           v19);
    v26 = "Unknown";
    if ( !data )
    {
      SnapCurrentProcessMiniDump(v5, (DWORD)&Context, v6, a1, a2, a3, &Context);
      memset(v30, 0, 0x50u);
      v30[3] = Context.Eip;
      v32[1] = (int)&Context;
      v32[0] = (int)v30;
      data = (_EXCEPTION_POINTERS *)v32;
    }
    qmemcpy(&ContextRecord, data->ContextRecord, sizeof(ContextRecord));
    if ( VirtualQuery((LPCVOID)ContextRecord.Eip, &Buffer, 0x1Cu)
      && GetModuleFileNameA((HMODULE)Buffer.AllocationBase, Filename, 0x104u) )
    {
      v26 = GetFilePart(Filename);
    }
    v28 = localtime(&Time);
    hprintf(
      hFile,
      "start at %02d/%02d/%02d %02d:%02d:%02d\r\n",
      v28->tm_year % 100,
      v28->tm_mon + 1,
      v28->tm_mday,
      v28->tm_hour,
      v28->tm_min,
      v28->tm_sec);
    RecordSystemInformation(hFile);
    v33 = data->ExceptionRecord;
    v18 = ContextRecord.Eip;
    v17 = ContextRecord.SegCs;
    v15 = v26;
    v7 = GetExceptionDescription(v33->ExceptionCode);
    hprintf(hFile, "%s in module %s at %04x:%08x.\r\n", v7, v15, v17, v18);
    if ( v33->ExceptionCode == -1073741819 && v33->NumberParameters >= 2 )
    {
      v23 = "Read from";
      if ( v33->ExceptionInformation[0] )
        v23 = "Write to";
      wsprintfA(v22, "%s location %08x caused an access violation.\r\n", v23, v33->ExceptionInformation[1]);
      hprintf(hFile, "%s", v22);
    }
    hprintf(hFile, "\r\n");
    hprintf(hFile, "Registers:\r\n");
    hprintf(
      hFile,
      "EAX=%08x CS=%04x EIP=%08x EFLGS=%08x\r\n",
      ContextRecord.Eax,
      ContextRecord.SegCs,
      ContextRecord.Eip,
      ContextRecord.EFlags);
    hprintf(
      hFile,
      "EBX=%08x SS=%04x ESP=%08x EBP=%08x\r\n",
      ContextRecord.Ebx,
      ContextRecord.SegSs,
      ContextRecord.Esp,
      ContextRecord.Ebp);
    hprintf(
      hFile,
      "ECX=%08x DS=%04x ESI=%08x FS=%04x\r\n",
      ContextRecord.Ecx,
      ContextRecord.SegDs,
      ContextRecord.Esi,
      ContextRecord.SegFs);
    hprintf(
      hFile,
      "EDX=%08x ES=%04x EDI=%08x GS=%04x\r\n",
      ContextRecord.Edx,
      ContextRecord.SegEs,
      ContextRecord.Edi,
      ContextRecord.SegGs);
    hprintf(hFile, "\r\nBytes at CS:EIP:\r\n");
    v31 = ContextRecord.Eip;
    for ( i = 0; i < 16; ++i )
    {
      ms_exc.registration.TryLevel = 0;
      hprintf(hFile, "%02x ", *(unsigned __int8 *)(i + v31));
      ms_exc.registration.TryLevel = -1;
    }
    hprintf(hFile, "\r\n\r\nStack dump:\r\n");
    g_dwStack = ContextRecord.Esp & 0xFFFFFFE0;
    g_dwStackTop = (int)NtCurrentTeb()->NtTib.StackBase & 0xFFFFFFE0;
    PrintStack(hFile, ContextRecord.Esp & 0xFFFFFFE0, (ContextRecord.Esp & 0xFFFFFFE0) + 160);
    hprintf(hFile, "\r\n");
    v8 = GetCurrentProcess();
    if ( SymInitialize(v8, 0, 1) )
    {
      v20 = SymGetOptions();
      if ( (v20 & 0x16) != 20 )
        SymSetOptions(v20 & 0xFFFFFFFD | 0x14);
      ImageHelpStackWalk(hFile, &ContextRecord);
      v9 = GetCurrentProcess();
      SymCleanup(v9);
    }
    else
    {
      IntelStackWalk(hFile, &ContextRecord);
    }
    RecordModuleList(hFile);
    CloseHandle(hFile);
    CreateMiniDump(data);
  }
}
// 408EF9: variable 'v6' is possibly undefined

//----- (004093B0) --------------------------------------------------------
BOOL hprintf(HANDLE hFile, LPCSTR a2, ...)
{
  int v2; // eax
  CHAR String[2004]; // [esp+0h] [ebp-7E0h] BYREF
  DWORD NumberOfBytesWritten; // [esp+7D8h] [ebp-8h] BYREF
  va_list arglist; // [esp+7DCh] [ebp-4h]
  va_list va; // [esp+7F0h] [ebp+10h] BYREF

  va_start(va, a2);
  va_copy(arglist, va);
  wvsprintfA(String, a2, va);
  arglist = 0;
  v2 = lstrlenA(String);
  return WriteFile(hFile, String, v2, &NumberOfBytesWritten, 0);
}

//----- (00409420) --------------------------------------------------------
void __cdecl CreateMiniDump(_EXCEPTION_POINTERS *pException)
{
  HANDLE v1; // eax
  HANDLE v2; // eax
  HANDLE v3; // eax
  DWORD v4; // [esp-18h] [ebp-2Ch]
  _MINIDUMP_EXCEPTION_INFORMATION *ExceptionParam; // [esp+0h] [ebp-14h]
  HANDLE hFile; // [esp+4h] [ebp-10h]
  int v7[3]; // [esp+8h] [ebp-Ch] BYREF

  hFile = CreateFileA(g_szDumpPath, 0x40000000u, 1u, 0, 2u, 0x80000080, 0);
  if ( hFile != (HANDLE)-1 )
  {
    v1 = GetCurrentThread();
    SetThreadPriority(v1, 2);
    if ( pException )
    {
      v7[0] = GetCurrentThreadId();
      v7[2] = 1;
      v7[1] = (int)pException;
      ExceptionParam = (_MINIDUMP_EXCEPTION_INFORMATION *)v7;
    }
    else
    {
      ExceptionParam = 0;
    }
    v4 = GetCurrentProcessId();
    v2 = GetCurrentProcess();
    MiniDumpWriteDump(v2, v4, hFile, MiniDumpNormal, ExceptionParam, 0, 0);
    v3 = GetCurrentThread();
    SetThreadPriority(v3, 0);
    CloseHandle(hFile);
  }
}

//----- (004094D0) --------------------------------------------------------
void __cdecl RecordModuleList(void *LogFile)
{
  hprintf(LogFile, "Module list:\r\n");
  GetModuleHandleA(0);
  _getdrive();
}

//----- (00409770) --------------------------------------------------------
const char *__cdecl GetExceptionDescription(unsigned int ExceptionCode)
{
  unsigned int i; // [esp+0h] [ebp-C4h]
  int v3; // [esp+4h] [ebp-C0h]
  int v4[47]; // [esp+8h] [ebp-BCh]

  v3 = 1073807365;
  v4[0] = (int)"a Control-C";
  v4[1] = 1073807368;
  v4[2] = (int)"a Control-Break";
  v4[3] = -2147483646;
  v4[4] = (int)"a Datatype Misalignment";
  v4[5] = -2147483645;
  v4[6] = (int)"a Breakpoint";
  v4[7] = -1073741819;
  v4[8] = (int)"an Access Violation";
  v4[9] = -1073741818;
  v4[10] = (int)"an In Page Error";
  v4[11] = -1073741801;
  v4[12] = (int)"a No Memory";
  v4[13] = -1073741795;
  v4[14] = (int)"an Illegal Instruction";
  v4[15] = -1073741787;
  v4[16] = (int)"a Noncontinuable Exception";
  v4[17] = -1073741786;
  v4[18] = (int)"an Invalid Disposition";
  v4[19] = -1073741684;
  v4[20] = (int)"a Array Bounds Exceeded";
  v4[21] = -1073741683;
  v4[22] = (int)"a Float Denormal Operand";
  v4[23] = -1073741682;
  v4[24] = (int)"a Float Divide by Zero";
  v4[25] = -1073741681;
  v4[26] = (int)"a Float Inexact Result";
  v4[27] = -1073741680;
  v4[28] = (int)"a Float Invalid Operation";
  v4[29] = -1073741679;
  v4[30] = (int)"a Float Overflow";
  v4[31] = -1073741678;
  v4[32] = (int)"a Float Stack Check";
  v4[33] = -1073741677;
  v4[34] = (int)"a Float Underflow";
  v4[35] = -1073741676;
  v4[36] = (int)"an Integer Divide by Zero";
  v4[37] = -1073741675;
  v4[38] = (int)"an Integer Overflow";
  v4[39] = -1073741674;
  v4[40] = (int)"a Privileged Instruction";
  v4[41] = -1073741571;
  v4[42] = (int)"a Stack Overflow";
  v4[43] = -1073741502;
  v4[44] = (int)"a DLL Initialization Failed";
  v4[45] = -529697949;
  v4[46] = (int)"a Microsoft C++ Exception";
  for ( i = 0; i < 0x18; ++i )
  {
    if ( ExceptionCode == *(&v3 + 2 * i) )
      return (const char *)v4[2 * i];
  }
  return "Unknown exception type";
}

//----- (00409950) --------------------------------------------------------
void __cdecl PrintStack(void *LogFile, unsigned int begin, unsigned int end)
{
  int v3; // eax
  int v4; // eax
  char v5; // [esp+Ch] [ebp-80h] BYREF
  char v6[88]; // [esp+Dh] [ebp-7Fh] BYREF
  __int16 v7; // [esp+65h] [ebp-27h]
  char v8; // [esp+67h] [ebp-25h]
  LPSTR v9; // [esp+70h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+74h] [ebp-18h]
  unsigned int enda; // [esp+9Ch] [ebp+10h]

  if ( g_dwStack < begin )
    g_dwStack = begin & 0xFFFFFFE0;
  if ( end <= g_dwStackTop )
    enda = (end + 31) & 0xFFFFFFE0;
  else
    enda = g_dwStackTop;
  ms_exc.registration.TryLevel = 0;
  v5 = 0;
  memset(v6, 0, sizeof(v6));
  v7 = 0;
  v8 = 0;
  v9 = &v5;
  while ( g_dwStack < enda )
  {
    if ( (g_dwStack & 0x1F) == 0 )
    {
      v3 = wsprintfA(v9, "%08x:", g_dwStack);
      v9 += v3;
    }
    v4 = wsprintfA(v9, " %08x", *(_DWORD *)g_dwStack);
    v9 += v4;
    g_dwStack += 4;
    if ( (g_dwStack & 0x1F) == 0 )
    {
      hprintf(LogFile, "%s\r\n", &v5);
      v5 = 0;
      v9 = &v5;
    }
  }
}

//----- (00409AD0) --------------------------------------------------------
void __cdecl ImageHelpStackWalk(void *LogFile, _CONTEXT *ptrContext)
{
  HANDLE v2; // eax
  HANDLE v3; // eax
  HANDLE v4; // eax
  HANDLE v5; // [esp-1Ch] [ebp-678h]
  DWORD64 v6; // [esp-10h] [ebp-66Ch]
  DWORD64 v7; // [esp-10h] [ebp-66Ch]
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+0h] [ebp-65Ch] BYREF
  CHAR Filename[268]; // [esp+1Ch] [ebp-640h] BYREF
  DWORD pdwDisplacement; // [esp+128h] [ebp-534h] BYREF
  struct _IMAGEHLP_LINE64 Line64; // [esp+12Ch] [ebp-530h] BYREF
  PSYMBOL_INFO Symbol; // [esp+148h] [ebp-514h]
  CHAR outputString[512]; // [esp+14Ch] [ebp-510h] BYREF
  struct _SYMBOL_INFO v14; // [esp+34Ch] [ebp-310h] BYREF
  unsigned __int64 Displacement; // [esp+5ACh] [ebp-B0h] BYREF
  struct _tagSTACKFRAME StackFrame; // [esp+5B4h] [ebp-A8h] BYREF

  hprintf(LogFile, "Call Stack Information:\r\n");
  memset(&StackFrame, 0, sizeof(StackFrame));
  StackFrame.AddrPC.Offset = ptrContext->Eip;
  StackFrame.AddrPC.Mode = 3;
  StackFrame.AddrStack.Offset = ptrContext->Esp;
  StackFrame.AddrStack.Mode = 3;
  StackFrame.AddrFrame.Offset = ptrContext->Ebp;
  StackFrame.AddrFrame.Mode = 3;
  while ( 1 )
  {
    v5 = GetCurrentThread();
    v2 = GetCurrentProcess();
    if ( !StackWalk(0x14Cu, v2, v5, &StackFrame, ptrContext, 0, SymFunctionTableAccess, SymGetModuleBase, 0)
      || !StackFrame.AddrFrame.Offset )
    {
      break;
    }
    PrintStack(LogFile, StackFrame.AddrFrame.Offset - 32, StackFrame.AddrFrame.Offset + 12);
    hprintf(LogFile, "\r\n%08x  %08x ", StackFrame.AddrFrame.Offset, StackFrame.AddrPC.Offset);
    Symbol = &v14;
    v14.SizeOfStruct = 600;
    v14.MaxNameLen = 512;
    Displacement = 0i64;
    outputString[0] = 0;
    v6 = StackFrame.AddrPC.Offset;
    v3 = GetCurrentProcess();
    if ( SymFromAddr(v3, v6, &Displacement, &v14)
      && (hprintf(LogFile, "%s +%x\r\n", Symbol->Name, (_DWORD)Displacement),
          UnDecorateSymbolName(Symbol->Name, outputString, 0x200u, 0),
          pdwDisplacement = 0,
          Line64.SizeOfStruct = 24,
          v7 = StackFrame.AddrPC.Offset,
          v4 = GetCurrentProcess(),
          SymGetLineFromAddr64(v4, v7, &pdwDisplacement, &Line64)) )
    {
      hprintf(LogFile, "%s %d %s\r\n", Line64.FileName, Line64.LineNumber, outputString);
    }
    else
    {
      Filename[0] = 0;
      if ( VirtualQuery((LPCVOID)StackFrame.AddrPC.Offset, &Buffer, 0x1Cu) )
        GetModuleFileNameA((HMODULE)Buffer.AllocationBase, Filename, 0x104u);
      hprintf(LogFile, "%s %s\r\n", Filename, outputString);
    }
    hprintf(
      LogFile,
      "Params:   %08x %08x %08x %08x\r\n",
      StackFrame.Params[0],
      StackFrame.Params[1],
      StackFrame.Params[2],
      StackFrame.Params[3]);
  }
  hprintf(LogFile, "\r\n");
}

//----- (00409DB0) --------------------------------------------------------
void __cdecl IntelStackWalk(void *LogFile, _CONTEXT *ptrContext)
{
  int i; // [esp+Ch] [ebp-154h]
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+10h] [ebp-150h] BYREF
  unsigned __int8 *v4; // [esp+2Ch] [ebp-134h]
  CHAR Filename[264]; // [esp+30h] [ebp-130h] BYREF
  LPCVOID lpAddress; // [esp+13Ch] [ebp-24h]
  LPVOID lp; // [esp+140h] [ebp-20h]
  LPVOID v8; // [esp+144h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+148h] [ebp-18h]

  hprintf(LogFile, "Intel Call Stack Information:\r\n");
  lpAddress = (LPCVOID)ptrContext->Eip;
  lp = (LPVOID)ptrContext->Ebp;
  do
  {
    PrintStack(LogFile, (unsigned int)lp - 32, (unsigned int)lp + 12);
    Filename[0] = 0;
    if ( VirtualQuery(lpAddress, &Buffer, 0x1Cu) )
      GetModuleFileNameA((HMODULE)Buffer.AllocationBase, Filename, 0x104u);
    hprintf(LogFile, "\r\n%08x  %08x  %s\r\n", lp, lpAddress, Filename);
    hprintf(LogFile, "Bytes at CS:EIP: ");
    v4 = (unsigned __int8 *)lpAddress;
    for ( i = 0; i < 16; ++i )
    {
      ms_exc.registration.TryLevel = 0;
      hprintf(LogFile, "%02x ", v4[i]);
      ms_exc.registration.TryLevel = -1;
    }
    hprintf(LogFile, "\r\n");
    lpAddress = (LPCVOID)*((_DWORD *)lp + 1);
    v8 = lp;
    lp = *(LPVOID *)lp;
  }
  while ( ((unsigned __int8)lp & 3) == 0 && lp > v8 && !IsBadWritePtr(lp, 8u) );
}

//----- (00409F80) --------------------------------------------------------
int __userpurge RecordExceptionInfo@<eax>(DWORD a1@<ebx>, DWORD a2@<edi>, DWORD a3@<esi>, _EXCEPTION_POINTERS *data)
{
  int result; // eax

  if ( g_nEnable && data->ExceptionRecord->ExceptionCode != -536870911 )
  {
    cleanup();
    if ( !BeenHere )
    {
      BeenHere = 1;
      GenerateExceptionReport(a1, a2, a3, data);
      sendMail();
    }
    cleanup_0();
  }
  if ( lpTopLevelExceptionFilter )
    result = lpTopLevelExceptionFilter(data);
  else
    result = 0;
  return result;
}
// 40AA60: using guessed type int cleanup(void);
// 40AA70: using guessed type int cleanup_0(void);

//----- (00409FF0) --------------------------------------------------------
void __thiscall CIOException::CInit::~CInit(CIOException::CInit *this)
{
  if ( lpTopLevelExceptionFilter )
    SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
  DeleteCriticalSection(&CriticalSection);
}

//----- (0040A020) --------------------------------------------------------
void ELOG(const char *lpszFormat, ...)
{
  DWORD v1; // eax
  int v2; // [esp-18h] [ebp-448h]
  int v3; // [esp-14h] [ebp-444h]
  int v4; // [esp-10h] [ebp-440h]
  int v5; // [esp-Ch] [ebp-43Ch]
  int v6; // [esp-8h] [ebp-438h]
  int v7; // [esp-4h] [ebp-434h]
  _BYTE *Src; // [esp+0h] [ebp-430h]
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-42Ch] BYREF
  int i; // [esp+8h] [ebp-428h]
  struct _SYSTEMTIME SystemTime; // [esp+Ch] [ebp-424h] BYREF
  HANDLE hFile; // [esp+1Ch] [ebp-414h]
  char Buffer[1028]; // [esp+20h] [ebp-410h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+428h] [ebp-8h]
  va_list ArgList; // [esp+42Ch] [ebp-4h]
  va_list va; // [esp+43Ch] [ebp+Ch] BYREF

  va_start(va, lpszFormat);
  if ( g_nEnable )
  {
    cleanup();
    va_copy(ArgList, va);
    SystemTime.wYear = 0;
    *(_DWORD *)&SystemTime.wMonth = 0;
    *(_DWORD *)&SystemTime.wDay = 0;
    *(_DWORD *)&SystemTime.wMinute = 0;
    SystemTime.wMilliseconds = 0;
    GetLocalTime(&SystemTime);
    hFile = CreateFileA(body, 0xC0000000, 1u, 0, 4u, 0x80u, 0);
    if ( hFile != (HANDLE)-1 )
    {
      SetFilePointer(hFile, 0, 0, 2u);
      v7 = SystemTime.wSecond;
      v6 = SystemTime.wMinute;
      v5 = SystemTime.wHour;
      v4 = SystemTime.wDay;
      v3 = SystemTime.wMonth;
      v2 = SystemTime.wYear;
      v1 = GetCurrentThreadId();
      nNumberOfBytesToWrite = _snprintf(
                                Buffer,
                                0x400u,
                                "[%x %04d/%02d/%02d %02d:%02d:%02d]: ",
                                v1,
                                v2,
                                v3,
                                v4,
                                v5,
                                v6,
                                v7);
      if ( (nNumberOfBytesToWrite & 0x80000000) == 0 )
      {
        WriteFile(hFile, Buffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
        nNumberOfBytesToWrite = _vsnprintf(Buffer, 0x400u, lpszFormat, ArgList);
        if ( (nNumberOfBytesToWrite & 0x80000000) == 0 )
        {
          for ( i = 0; i < (int)nNumberOfBytesToWrite; i += 2 )
          {
            Src = memchr(&Buffer[i], 10, nNumberOfBytesToWrite - i);
            if ( !Src )
              break;
            if ( nNumberOfBytesToWrite < 0x400 )
              ++nNumberOfBytesToWrite;
            i = Src - Buffer;
            memcpy_0(Src + 1, Src, nNumberOfBytesToWrite - (Src - Buffer) - 1);
            *Src = 13;
          }
          WriteFile(hFile, Buffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
        }
      }
      ArgList = 0;
      CloseHandle(hFile);
      cleanup_0();
    }
  }
}
// 40AA60: using guessed type int cleanup(void);
// 40AA70: using guessed type int cleanup_0(void);

//----- (0040A270) --------------------------------------------------------
void __stdcall __spoils<edx,ecx> EBREAK()
{
  DWORD v0; // ebx
  DWORD v1; // edi
  DWORD v2; // esi

  if ( g_nEnable && InterlockedExchange(&Target, 0) )
  {
    if ( g_nEnable )
      EBreak(v0, v1, v2);
  }
}
// 40A29B: variable 'v0' is possibly undefined
// 40A29B: variable 'v1' is possibly undefined
// 40A29B: variable 'v2' is possibly undefined

//----- (0040A2B0) --------------------------------------------------------
int __usercall EBreak@<eax>(DWORD a1@<ebx>, DWORD a2@<edi>, DWORD a3@<esi>)
{
  ELOG("EASSERT\n");
  cleanup();
  GenerateExceptionReport(a1, a2, a3, 0);
  sendMail();
  return cleanup_0();
}
// 40AA60: using guessed type int cleanup(void);
// 40AA70: using guessed type int cleanup_0(void);

//----- (0040A2E0) --------------------------------------------------------
int __usercall CIOException::Filter@<eax>(DWORD a1@<ebx>, DWORD a2@<edi>, DWORD a3@<esi>, _EXCEPTION_POINTERS *pExp)
{
  if ( g_nEnable && pExp->ExceptionRecord->ExceptionCode != -536870911 )
  {
    cleanup();
    GenerateExceptionReport(a1, a2, a3, pExp);
    cleanup_0();
  }
  return 1;
}
// 40AA60: using guessed type int cleanup(void);
// 40AA70: using guessed type int cleanup_0(void);

//----- (0040A320) --------------------------------------------------------
void __cdecl CIOException::Open(const char *szMailServer, const char *szMailFrom, const char *szMailTo)
{
  HANDLE hObject; // [esp+0h] [ebp-4h]

  if ( szMailServer && *szMailServer )
  {
    host = (char *)szMailServer;
    g_szMailFrom = szMailFrom;
    g_szMailTo = szMailTo;
  }
  else
  {
    host = 0;
    g_szMailFrom = 0;
    g_szMailTo = 0;
  }
  hObject = CreateFileA(body, 0x80000000, 1u, 0, 3u, 0, 0);
  if ( hObject != (HANDLE)-1 )
  {
    CloseHandle(hObject);
    CIOException::SendMail();
  }
}

//----- (0040A3B0) --------------------------------------------------------
BOOL CIOException::Enable()
{
  return InterlockedExchange(&g_nEnable, 1) == 0;
}

//----- (0040A3D0) --------------------------------------------------------
LONG CIOException::Disable()
{
  return InterlockedExchange(&g_nEnable, 0);
}

//----- (0040A3F0) --------------------------------------------------------
LONG CIOException::IsEnable()
{
  return g_nEnable;
}

//----- (0040A400) --------------------------------------------------------
int __stdcall CIOException::SendMail()
{
  cleanup();
  sendMail();
  return cleanup_0();
}
// 40AA60: using guessed type int cleanup(void);
// 40AA70: using guessed type int cleanup_0(void);

//----- (0040A440) --------------------------------------------------------
void __cdecl CIOException::DumpStack(int nThread, void **hThread, unsigned int *nThreadId)
{
  HANDLE v3; // eax
  DWORD v4; // eax
  HANDLE v5; // eax
  HANDLE v6; // eax
  HANDLE v7; // eax
  int v8; // [esp-18h] [ebp-38h]
  int v9; // [esp-14h] [ebp-34h]
  int v10; // [esp-10h] [ebp-30h]
  int v11; // [esp-Ch] [ebp-2Ch]
  int v12; // [esp-8h] [ebp-28h]
  int v13; // [esp-4h] [ebp-24h]
  int i; // [esp+0h] [ebp-20h]
  DWORD v15; // [esp+4h] [ebp-1Ch]
  struct tm *v16; // [esp+8h] [ebp-18h]
  struct _SYSTEMTIME SystemTime; // [esp+Ch] [ebp-14h] BYREF
  HANDLE hFile; // [esp+1Ch] [ebp-4h]

  v3 = GetCurrentThread();
  SetThreadPriority(v3, 2);
  cleanup();
  hFile = CreateFileA(body, 0x40000000u, 1u, 0, 4u, 0x80000080, 0);
  if ( hFile == (HANDLE)-1 )
  {
    cleanup_0();
  }
  else
  {
    SetFilePointer(hFile, 0, 0, 2u);
    SystemTime.wYear = 0;
    *(_DWORD *)&SystemTime.wMonth = 0;
    *(_DWORD *)&SystemTime.wDay = 0;
    *(_DWORD *)&SystemTime.wMinute = 0;
    SystemTime.wMilliseconds = 0;
    GetLocalTime(&SystemTime);
    v13 = SystemTime.wSecond;
    v12 = SystemTime.wMinute;
    v11 = SystemTime.wHour;
    v10 = SystemTime.wDay;
    v9 = SystemTime.wMonth;
    v8 = SystemTime.wYear;
    v4 = GetCurrentThreadId();
    hprintf(
      hFile,
      "[%x %04d/%02d/%02d %02d:%02d:%02d]: Dump Stack =======================\r\n",
      v4,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13);
    v16 = localtime(&Time);
    hprintf(
      hFile,
      "start at %02d/%02d/%02d %02d:%02d:%02d\r\n",
      v16->tm_year % 100,
      v16->tm_mon + 1,
      v16->tm_mday,
      v16->tm_hour,
      v16->tm_min,
      v16->tm_sec);
    v5 = GetCurrentProcess();
    if ( SymInitialize(v5, 0, 1) )
    {
      v15 = SymGetOptions();
      if ( (v15 & 0x16) != 20 )
        SymSetOptions(v15 & 0xFFFFFFFD | 0x14);
      for ( i = 0; i < nThread; ++i )
      {
        hprintf(hFile, "Call Stack Information %d (%x):\r\n", i, nThreadId[i]);
        ImageHelpStackWalk_0(hFile, hThread[i]);
      }
      RecordModuleList(hFile);
      v6 = GetCurrentProcess();
      SymCleanup(v6);
    }
    CloseHandle(hFile);
    cleanup_0();
    CreateMiniDump(0);
    v7 = GetCurrentThread();
    SetThreadPriority(v7, 0);
  }
}
// 40AA60: using guessed type int cleanup(void);
// 40AA70: using guessed type int cleanup_0(void);

//----- (0040A620) --------------------------------------------------------
void __cdecl ImageHelpStackWalk_0(void *LogFile, void *hThread)
{
  HANDLE v2; // eax
  HANDLE v3; // eax
  HANDLE v4; // eax
  DWORD64 v5; // [esp-10h] [ebp-93Ch]
  DWORD64 v6; // [esp-10h] [ebp-93Ch]
  struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+0h] [ebp-92Ch] BYREF
  CHAR Filename[268]; // [esp+1Ch] [ebp-910h] BYREF
  DWORD pdwDisplacement; // [esp+128h] [ebp-804h] BYREF
  struct _IMAGEHLP_LINE64 Line64; // [esp+12Ch] [ebp-800h] BYREF
  PSYMBOL_INFO Symbol; // [esp+148h] [ebp-7E4h]
  CHAR outputString[512]; // [esp+14Ch] [ebp-7E0h] BYREF
  struct _SYMBOL_INFO v13; // [esp+34Ch] [ebp-5E0h] BYREF
  unsigned __int64 Displacement; // [esp+5A4h] [ebp-388h] BYREF
  CONTEXT Context; // [esp+5ACh] [ebp-380h] BYREF
  struct _tagSTACKFRAME StackFrame; // [esp+884h] [ebp-A8h] BYREF

  SuspendThread(hThread);
  memset(&Context, 0, sizeof(Context));
  Context.ContextFlags = 65543;
  GetThreadContext(hThread, &Context);
  hprintf(LogFile, "\r\nRegisters:\r\n");
  hprintf(LogFile, "EAX=%08x CS=%04x EIP=%08x EFLGS=%08x\r\n", Context.Eax, Context.SegCs, Context.Eip, Context.EFlags);
  hprintf(LogFile, "EBX=%08x SS=%04x ESP=%08x EBP=%08x\r\n", Context.Ebx, Context.SegSs, Context.Esp, Context.Ebp);
  hprintf(LogFile, "ECX=%08x DS=%04x ESI=%08x FS=%04x\r\n", Context.Ecx, Context.SegDs, Context.Esi, Context.SegFs);
  hprintf(LogFile, "EDX=%08x ES=%04x EDI=%08x GS=%04x\r\n", Context.Edx, Context.SegEs, Context.Edi, Context.SegGs);
  hprintf(LogFile, "\r\nStack dump:\r\n");
  g_dwStack = Context.Esp & 0xFFFFFFE0;
  g_dwStackTop = 0x80000000;
  PrintStack(LogFile, Context.Esp & 0xFFFFFFE0, (Context.Esp & 0xFFFFFFE0) + 160);
  hprintf(LogFile, "\r\nCall Stack:\r\n");
  memset(&StackFrame, 0, sizeof(StackFrame));
  StackFrame.AddrPC.Offset = Context.Eip;
  StackFrame.AddrPC.Mode = 3;
  StackFrame.AddrStack.Offset = Context.Esp;
  StackFrame.AddrStack.Mode = 3;
  StackFrame.AddrFrame.Offset = Context.Ebp;
  StackFrame.AddrFrame.Mode = 3;
  while ( 1 )
  {
    v2 = GetCurrentProcess();
    if ( !StackWalk(0x14Cu, v2, hThread, &StackFrame, &Context, 0, SymFunctionTableAccess, SymGetModuleBase, 0)
      || !StackFrame.AddrFrame.Offset )
    {
      break;
    }
    PrintStack(LogFile, StackFrame.AddrFrame.Offset - 16, StackFrame.AddrFrame.Offset + 12);
    hprintf(LogFile, "\r\n%08x  %08x ", StackFrame.AddrFrame.Offset, StackFrame.AddrPC.Offset);
    Symbol = &v13;
    v13.SizeOfStruct = 600;
    v13.MaxNameLen = 512;
    outputString[0] = 0;
    Displacement = 0i64;
    v5 = StackFrame.AddrPC.Offset;
    v3 = GetCurrentProcess();
    if ( SymFromAddr(v3, v5, &Displacement, &v13)
      && (hprintf(LogFile, "%s +%x\r\n", Symbol->Name, (_DWORD)Displacement),
          UnDecorateSymbolName(Symbol->Name, outputString, 0x200u, 0),
          pdwDisplacement = 0,
          Line64.SizeOfStruct = 24,
          v6 = StackFrame.AddrPC.Offset,
          v4 = GetCurrentProcess(),
          SymGetLineFromAddr64(v4, v6, &pdwDisplacement, &Line64)) )
    {
      hprintf(LogFile, "%s %d %s\r\n", Line64.FileName, Line64.LineNumber, outputString);
    }
    else
    {
      Filename[0] = 0;
      if ( VirtualQuery((LPCVOID)StackFrame.AddrPC.Offset, &Buffer, 0x1Cu) )
        GetModuleFileNameA((HMODULE)Buffer.AllocationBase, Filename, 0x104u);
      hprintf(LogFile, "%s %s\r\n", Filename, outputString);
    }
    hprintf(
      LogFile,
      "Params:   %08x %08x %08x %08x\r\n",
      StackFrame.Params[0],
      StackFrame.Params[1],
      StackFrame.Params[2],
      StackFrame.Params[3]);
  }
  hprintf(LogFile, "\r\n");
  ResumeThread(hThread);
}

//----- (0040AA80) --------------------------------------------------------
void __thiscall CIOSpinLock::Wait(CIOSpinLock *this)
{
  int v2; // [esp+4h] [ebp-4h]
  int v3; // [esp+4h] [ebp-4h]

  v2 = 4000;
  while ( --v2 >= 0 )
  {
    if ( !InterlockedCompareExchange(&this->lock, 1, 0) )
      return;
    _mm_pause();
  }
  v3 = 4000;
  while ( --v3 >= 0 )
  {
    SwitchToThread();
    if ( !InterlockedCompareExchange(&this->lock, 1, 0) )
      return;
  }
  do
    Sleep(0x3E8u);
  while ( InterlockedCompareExchange(&this->lock, 1, 0) );
}

//----- (0040AB10) --------------------------------------------------------
struct _RTL_CRITICAL_SECTION *__thiscall CIOCriticalSection::CIOCriticalSection(struct _RTL_CRITICAL_SECTION *this)
{
  InitializeCriticalSection(this);
  this[1].LockCount = 0;
  this[1].DebugInfo = 0;
  return this;
}

//----- (0040AB80) --------------------------------------------------------
void __thiscall CIOCriticalSection::~CIOCriticalSection(CIOCriticalSection *this)
{
  if ( this->m_dwEIP[0] )
    EBREAK();
  DeleteCriticalSection(&this->m_critical_section);
}

//----- (0040ABB0) --------------------------------------------------------
void __thiscall CIOCriticalSection::Enter(CIOCriticalSection *this)
{
  unsigned int v2; // [esp+8h] [ebp-4h]
  int vars0; // [esp+Ch] [ebp+0h]
  unsigned int retaddr; // [esp+10h] [ebp+4h]

  if ( !TryEnterCriticalSection(&this->m_critical_section) )
    EnterCriticalSection(&this->m_critical_section);
  if ( this->m_dwEIP[0] )
  {
    ELOG("CIOCriticalSection::Enter EIP(%p %p)\n", (const void *)this->m_dwEIP[0], (const void *)this->m_dwEIP[1]);
    EBREAK();
  }
  v2 = *(_DWORD *)(vars0 + 4);
  this->m_dwEIP[0] = retaddr;
  this->m_dwEIP[1] = v2;
}
// 40AC15: variable 'vars0' is possibly undefined

//----- (0040ACA0) --------------------------------------------------------
void __thiscall CIOCriticalSection::Leave(CIOCriticalSection *this)
{
  if ( !this->m_dwEIP[0] )
    EBREAK();
  this->m_dwEIP[1] = 0;
  this->m_dwEIP[0] = 0;
  LeaveCriticalSection(&this->m_critical_section);
}

//----- (0040ACE0) --------------------------------------------------------
int __thiscall sub_40ACE0(void *this)
{
  sub_40AEF0();
  return CIOBuffer::FreeAll();
}

//----- (0040AD00) --------------------------------------------------------
int __cdecl CIOSocket::CreateIOThread(int nThread)
{
  HANDLE v1; // eax
  int result; // eax
  int ArgList; // [esp+0h] [ebp-4h]

  v1 = GetCurrentProcess();
  SetProcessPriorityBoost(v1, 1);
  g_nTerminating = 0;
  hEvent = CreateEventA(0, 0, 0, 0);
  CompletionPort = CreateIoCompletionPort((HANDLE)0xFFFFFFFF, 0, 0, 0);
  CIOSocket::CIOTimerInstance::OnTimerCallback(&g_instance, 0);
  CIOObject::AddRef(&g_instance, &g_instance.m_nTimerRef);
  if ( CIOObject::RegisterWait(&g_instance, hEvent) )
  {
    g_hThread = (void **)CMemory::_malloc(4 * nThread);
    g_nThreadId = CMemory::_malloc(4 * nThread);
    ::nThread = (void *)nThread;
    for ( ArgList = 0; ArgList < nThread; ++ArgList )
      g_hThread[ArgList] = (void *)_beginthreadex(
                                     0,
                                     0,
                                     (_beginthreadex_proc_type)CIOSocket::IOThread,
                                     (void *)ArgList,
                                     0,
                                     (unsigned int *)g_nThreadId + ArgList);
    result = 1;
  }
  else
  {
    LOG_ERR("RegisterWait error for timer");
    result = 0;
  }
  return result;
}

//----- (0040AE10) --------------------------------------------------------
unsigned int __thiscall CIOSocket::AddIOThread(void *this)
{
  unsigned int ThrdAddr; // [esp+0h] [ebp-4h] BYREF

  ThrdAddr = (unsigned int)this;
  if ( !CompletionPort )
    return 0;
  g_hThread = (void **)CMemory::_realloc(g_hThread, 4 * (_DWORD)nThread + 4);
  g_nThreadId = CMemory::_realloc(g_nThreadId, 4 * (_DWORD)nThread + 4);
  g_hThread[(_DWORD)nThread] = (void *)_beginthreadex(
                                         0,
                                         0,
                                         (_beginthreadex_proc_type)CIOSocket::IOThread,
                                         nThread,
                                         0,
                                         &ThrdAddr);
  *((_DWORD *)g_nThreadId + (_DWORD)nThread) = ThrdAddr;
  nThread = (char *)nThread + 1;
  return ThrdAddr;
}

//----- (0040AEC0) --------------------------------------------------------
int __cdecl CIOSocket::CloseIOThread()
{
  if ( InterlockedExchange(&g_nTerminating, 1) )
    return 0;
  SetEvent(hEvent);
  return 1;
}

//----- (0040AEF0) --------------------------------------------------------
void sub_40AEF0()
{
  CMemory::_free(g_hThread);
  CMemory::_free(g_nThreadId);
  g_hThread = 0;
  g_nThreadId = 0;
}

//----- (0040AF30) --------------------------------------------------------
_DWORD *__thiscall CIOObject::~CIOObject(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_42B5BC;
  return result;
}
// 42B5BC: using guessed type int (__stdcall *off_42B5BC)(int);

//----- (0040AF50) --------------------------------------------------------
void __thiscall CIOObject::AddRef(CIOObject *this, volatile int *pRef)
{
  if ( InterlockedIncrement(&this->m_nRef) == 1 )
  {
    EBREAK();
    this->m_nRef = 100;
  }
  InterlockedIncrement(pRef);
}

//----- (0040AF90) --------------------------------------------------------
void __thiscall CIOObject::Release(CIOObject *this, volatile int *pRef)
{
  LONG v3; // [esp+4h] [ebp-8h]
  LONG v4; // [esp+8h] [ebp-4h]

  v3 = InterlockedDecrement(pRef);
  if ( v3 >= 0 )
  {
    v4 = InterlockedDecrement(&this->m_nRef);
    if ( v4 <= 0 )
    {
      if ( v4 >= 0 )
      {
        if ( *pRef )
        {
          ELOG("CIOObject::Release %p %p %x %d\n", this, this->__vftable, (char *)pRef - (char *)this, *pRef);
          EBREAK();
          *pRef = 100;
          this->m_nRef = 100;
        }
        else
        {
          this->OnFree(this);
        }
      }
      else
      {
        ELOG("CIOObject::Release %p %p %d\n", this, this->__vftable, v4);
        EBREAK();
        this->m_nRef = 100;
      }
    }
  }
  else
  {
    ELOG("CIOObject::Release %p %p %x %d\n", this, this->__vftable, (char *)pRef - (char *)this, v3);
    EBREAK();
    *pRef = 100;
    this->m_nRef = 100;
  }
}

//----- (0040B090) --------------------------------------------------------
int __thiscall CIOObject::RegisterWait(void *this, void *a2)
{
  int result; // eax

  CIOCriticalSection::Enter(&stru_444038);
  if ( (int)nCount < 64 )
  {
    Handles[nCount] = a2;
    dword_443E20[nCount++] = (int)this;
    SetEvent(hEvent);
    CIOCriticalSection::Leave(&stru_444038);
    result = 1;
  }
  else
  {
    CIOCriticalSection::Leave(&stru_444038);
    result = 0;
  }
  return result;
}

//----- (0040B1A0) --------------------------------------------------------
void __thiscall CIOObject::OnTimerCallback(CIOObject *this, int nId)
{
  if ( !PostQueuedCompletionStatus(CompletionPort, nId, (ULONG_PTR)this, 0) )
  {
    EBREAK();
    CIOObject::Release((volatile LONG *)this);
  }
}

//----- (0040B1E0) --------------------------------------------------------
void __thiscall CIOObject::OnIOCallback(CIOObject *this, int bSucess, unsigned int dwTransferred, _OVERLAPPED *lpOverlapped)
{
  if ( lpOverlapped )
    EBREAK();
  this->OnTimer(this, dwTransferred);
  CIOObject::Release(this, &this->m_nTimerRef);
}

//----- (0040B220) --------------------------------------------------------
int *__thiscall CIOSocket::CIOTimerInstance::OnTimerCallback(void *this, int a2)
{
  DWORD v2; // eax
  int v3; // eax
  int *result; // eax
  CIOSocket::CIOTimer v6; // [esp+4h] [ebp-Ch] BYREF

  v2 = GetTickCount();
  CIOSocket::CIOTimer::CIOTimer(&v6, (CIOObject *)this, v2 + 86400000, a2);
  sub_40C5D0((int)&unk_44405C, v3);
  result = (int *)sub_40C5B0(&unk_44405C);
  dword_444020 = *result;
  return result;
}
// 40B24B: variable 'v3' is possibly undefined
// 444020: using guessed type int dword_444020;

//----- (0040B270) --------------------------------------------------------
void __thiscall CIOSocket::CIOTimerInstance::OnIOCallback(CIOSocket::CIOTimerInstance *this, int bSucess, unsigned int dwTransferred, _OVERLAPPED *lpOverlapped)
{
  HANDLE v4; // eax

  if ( dwTransferred )
    CIOObject::PostObject(&g_instance, dwTransferred - 1);
  else
    SetEvent(hEvent);
  v4 = GetCurrentThread();
  SuspendThread(v4);
}

//----- (0040B2B0) --------------------------------------------------------
int __stdcall CIOSocket::WaitThread(int a1)
{
  int *v4; // eax
  int v5; // eax
  int *v7; // [esp+4h] [ebp-18h]
  int v8; // [esp+8h] [ebp-14h]
  int i; // [esp+Ch] [ebp-10h]
  int dwMilliseconds; // [esp+10h] [ebp-Ch]
  DWORD v11; // [esp+14h] [ebp-8h]
  DWORD v12; // [esp+18h] [ebp-4h]

  while ( 1 )
  {
    v11 = GetTickCount();
    dwMilliseconds = dword_444020 - v11;
    if ( (int)(dword_444020 - v11) <= 0 )
    {
      CIOCriticalSection::Enter(&stru_444038);
      v7 = (int *)sub_40C5B0(&unk_44405C);
      v8 = v7[1];
      for ( i = v7[2]; ; i = v7[2] )
      {
        sub_40C620((int)&unk_44405C);
        (*(void (__thiscall **)(int, int))(*(_DWORD *)v8 + 12))(v8, i);
        v4 = (int *)sub_40C5B0(&unk_44405C);
        *v7 = *v4;
        v7[1] = v4[1];
        v7[2] = v4[2];
        dwMilliseconds = *v7 - v11;
        if ( dwMilliseconds > 0 )
          break;
        v8 = v7[1];
      }
      dword_444020 = *v7;
      CIOCriticalSection::Leave(&stru_444038);
    }
    v12 = WaitForMultipleObjects(nCount, Handles, 0, dwMilliseconds);
    if ( g_nTerminating )
      break;
    if ( v12 < nCount )
      (*(void (__thiscall **)(int))(*(_DWORD *)dword_443E20[v12] + 16))(dword_443E20[v12]);
  }
  CIOCriticalSection::Enter(&stru_444038);
  while ( !sub_40C590(&unk_44405C) )
  {
    v5 = sub_40C5B0(&unk_44405C);
    CIOObject::Release(*(CIOObject **)(v5 + 4), (volatile int *)(*(_DWORD *)(v5 + 4) + 8));
    sub_40C620((int)&unk_44405C);
  }
  CIOCriticalSection::Leave(&stru_444038);
  CIOObject::PostObject(&g_instance, (DWORD)nThread - 1);
  WaitForSingleObject(hEvent, 0xFFFFFFFF);
  CloseHandle(hEvent);
  return 0;
}
// 444020: using guessed type int dword_444020;

//----- (0040B460) --------------------------------------------------------
void __stdcall __noreturn CIOSocket::IOThread(void *arglist)
{
  HANDLE v1; // eax
  unsigned int CompletionKey; // [esp+0h] [ebp-10h] BYREF
  BOOL v3; // [esp+4h] [ebp-Ch]
  DWORD NumberOfBytesTransferred; // [esp+8h] [ebp-8h] BYREF
  LPOVERLAPPED Overlapped; // [esp+Ch] [ebp-4h] BYREF

  v1 = GetCurrentThread();
  SetThreadIdealProcessor(v1, 0x20u);
  while ( 1 )
  {
    v3 = GetQueuedCompletionStatus(CompletionPort, &NumberOfBytesTransferred, &CompletionKey, &Overlapped, 0xFFFFFFFF);
    InterlockedIncrement(&CIOSocket::s_nRunningThread);
    (*(void (__thiscall **)(unsigned int, BOOL, DWORD, LPOVERLAPPED))(*(_DWORD *)CompletionKey + 20))(
      CompletionKey,
      v3,
      NumberOfBytesTransferred,
      Overlapped);
    InterlockedDecrement(&CIOSocket::s_nRunningThread);
  }
}

//----- (0040B4D0) --------------------------------------------------------
int CIOSocket::DumpStack()
{
  CIOException::DumpStack((int)nThread, g_hThread, (unsigned int *)g_nThreadId);
  return CIOException::SendMail();
}

//----- (0040B500) --------------------------------------------------------
CIOBuffer *__cdecl CIOBuffer::Alloc()
{
  char v0; // al
  CIOBuffer *v2; // [esp+4h] [ebp-8h]
  int v3; // [esp+8h] [ebp-4h]

  v0 = InterlockedIncrement(&g_nAllocBuffer);
  v3 = 8 * (v0 & 0xF) + 4472960;
  CIOSpinLock::Enter((volatile LONG *)(8 * (v0 & 0xF) + 4472964));
  v2 = *(CIOBuffer **)v3;
  if ( *(_DWORD *)v3 )
  {
    *(_DWORD *)v3 = v2->m_pNext;
    CIOSpinLock::Leave((volatile LONG *)(v3 + 4));
  }
  else
  {
    CIOSpinLock::Leave((volatile LONG *)(v3 + 4));
    v2 = (CIOBuffer *)operator new(0x1F4Cu);
  }
  v2->m_dwSize = 0;
  v2->m_nRef = 1;
  v2->m_pNext = 0;
  return v2;
}

//----- (0040B5B0) --------------------------------------------------------
LONG __thiscall CIOBuffer::Free(_DWORD *this)
{
  char v1; // al
  int v4; // [esp+4h] [ebp-4h]

  v1 = InterlockedDecrement(&dword_444034);
  v4 = 8 * (v1 & 0xF) + 4472960;
  CIOSpinLock::Enter((volatile LONG *)(8 * (v1 & 0xF) + 4472964));
  this[2002] = *(_DWORD *)v4;
  *(_DWORD *)v4 = this;
  return CIOSpinLock::Leave((volatile LONG *)(v4 + 4));
}

//----- (0040B610) --------------------------------------------------------
int __stdcall CIOBuffer::FreeAll()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; i < 16; ++i )
  {
    CIOSpinLock::Enter((volatile LONG *)(8 * i + 4472964));
    while ( 1 )
    {
      v1 = dword_444080[2 * i];
      if ( !v1 )
        break;
      dword_444080[2 * i] = *(_DWORD *)(v1 + 8008);
      operator delete(v1);
    }
    CIOSpinLock::Leave((volatile LONG *)(8 * i + 4472964));
    result = i + 1;
  }
  return result;
}

//----- (0040B690) --------------------------------------------------------
void __thiscall CIOSocket::CIOSocket(CIOSocket *this, unsigned int s)
{
  CIOObject::CIOObject(this);
  this->__vftable = (CIOSocket_vtbl *)&off_42B5D4;
  CIOCriticalSection::CIOCriticalSection(&this->m_lock.m_critical_section);
  this->m_hSocket = s;
  if ( this->m_hSocket != -1 )
    CIOObject::AddRef((volatile LONG *)this);
  memset(&this->m_overlappedRead, 0, sizeof(this->m_overlappedRead));
  memset(&this->m_overlappedWrite, 0, sizeof(this->m_overlappedWrite));
  this->m_pReadBuf = CIOBuffer::Alloc();
  this->m_nPendingWrite = 0;
  this->m_pLastBuf = 0;
  this->m_pFirstBuf = 0;
}
// 42B5D4: using guessed type int (__stdcall *off_42B5D4)(int);

//----- (0040B760) --------------------------------------------------------
void __thiscall CIOSocket::~CIOSocket(CIOSocket *this)
{
  CIOBuffer *v2; // [esp+4h] [ebp-10h]

  this->__vftable = (CIOSocket_vtbl *)&off_42B5D4;
  CIOBuffer::Release(this->m_pReadBuf);
  while ( this->m_pFirstBuf )
  {
    v2 = this->m_pFirstBuf;
    this->m_pFirstBuf = v2->m_pNext;
    CIOBuffer::Free(v2);
  }
  CIOCriticalSection::~CIOCriticalSection(&this->m_lock);
  CIOObject::~CIOObject(this);
}
// 42B5D4: using guessed type int (__stdcall *off_42B5D4)(int);

//----- (0040B810) --------------------------------------------------------
void __thiscall CIOSocket::Close(char *this)
{
  char optval[2]; // [esp+4h] [ebp-8h] BYREF
  __int16 v6; // [esp+6h] [ebp-6h]
  SOCKET s; // [esp+8h] [ebp-4h]

  CIOCriticalSection::Enter((CIOCriticalSection *)(this + 20));
  s = InterlockedExchange((volatile LONG *)this + 4, -1);
  CIOCriticalSection::Leave((CIOCriticalSection *)(this + 20));
  if ( s != -1 )
  {
    (*(void (__thiscall **)(char *))(*(_DWORD *)this + 28))(this);
    *(_WORD *)optval = 1;
    v6 = 0;
    setsockopt(s, 0xFFFF, 128, optval, 4);
    closesocket(s);
    CIOObject::Release((volatile LONG *)this);
  }
}

//----- (0040B8F0) --------------------------------------------------------
void __thiscall CIOSocket::OnIOCallback(CIOSocket *this, int bSuccess, unsigned int dwTransferred, _OVERLAPPED *lpOverlapped)
{
  if ( bSuccess )
  {
    if ( lpOverlapped == &this->m_overlappedWrite )
    {
      CIOSocket::WriteCallback(this, dwTransferred);
      CIOObject::Release((volatile LONG *)this);
    }
    else if ( lpOverlapped == &this->m_overlappedRead )
    {
      CIOSocket::ReadCallback(this, dwTransferred);
      CIOObject::Release((volatile LONG *)this);
    }
    else
    {
      this->OnTimer(this, dwTransferred);
      CIOObject::Release(this, &this->m_nTimerRef);
    }
  }
  else
  {
    if ( lpOverlapped == &this->m_overlappedRead )
      CIOSocket::Close((char *)this);
    CIOObject::Release((volatile LONG *)this);
  }
}

//----- (0040B980) --------------------------------------------------------
void __thiscall CIOSocket::OnCreate(CIOSocket *this)
{
  CIOSocket::Read(this, 0);
}

//----- (0040B9A0) --------------------------------------------------------
void __thiscall CIOSocket::ReadCallback(CIOSocket *this, unsigned int dwTransferred)
{
  if ( dwTransferred )
  {
    this->m_pReadBuf->m_dwSize += dwTransferred;
    this->OnRead(this);
  }
  else
  {
    CIOSocket::Close((char *)this);
  }
}

//----- (0040B9F0) --------------------------------------------------------
void __thiscall CIOSocket::Read(CIOSocket *this, unsigned int dwLeft)
{
  DWORD v3; // [esp+4h] [ebp-18h]
  CIOBuffer *v4; // [esp+8h] [ebp-14h]
  DWORD NumberOfBytesRecvd; // [esp+Ch] [ebp-10h] BYREF
  struct _WSABUF Buffers; // [esp+10h] [ebp-Ch] BYREF
  DWORD Flags; // [esp+18h] [ebp-4h] BYREF

  this->m_pReadBuf->m_dwSize -= dwLeft;
  if ( this->m_pReadBuf->m_nRef == 1 )
  {
    memcpy_0(this->m_pReadBuf, &this->m_pReadBuf->m_buffer[this->m_pReadBuf->m_dwSize], dwLeft);
  }
  else
  {
    v4 = CIOBuffer::Alloc();
    memcpy(v4, &this->m_pReadBuf->m_buffer[this->m_pReadBuf->m_dwSize], dwLeft);
    CIOBuffer::Release(this->m_pReadBuf);
    this->m_pReadBuf = v4;
  }
  this->m_pReadBuf->m_dwSize = dwLeft;
  CIOObject::AddRef((volatile LONG *)this);
  Buffers.len = 8000 - this->m_pReadBuf->m_dwSize;
  Buffers.buf = &this->m_pReadBuf->m_buffer[this->m_pReadBuf->m_dwSize];
  Flags = 0;
  CIOCriticalSection::Enter(&this->m_lock);
  if ( !WSARecv(this->m_hSocket, &Buffers, 1u, &NumberOfBytesRecvd, &Flags, &this->m_overlappedRead, 0)
    || GetLastError() == 997 )
  {
    CIOCriticalSection::Leave(&this->m_lock);
  }
  else
  {
    v3 = GetLastError();
    CIOCriticalSection::Leave(&this->m_lock);
    if ( v3 != 10038 && v3 != 10054 && v3 != 10053 && v3 != 10058 )
      LOG_ERR("CIOSocket::Read %x(%x) err = %d", this->m_hSocket, this, v3);
    CIOSocket::Close((char *)this);
    CIOObject::Release((volatile LONG *)this);
  }
}

//----- (0040BB90) --------------------------------------------------------
void __thiscall CIOSocket::WriteCallback(CIOSocket *this, unsigned int dwTransferred)
{
  DWORD v3; // [esp+4h] [ebp-14h]
  struct _WSABUF Buffers; // [esp+8h] [ebp-10h] BYREF
  DWORD NumberOfBytesSent; // [esp+10h] [ebp-8h] BYREF
  CIOBuffer *v6; // [esp+14h] [ebp-4h]

  CIOCriticalSection::Enter(&this->m_lock);
  if ( dwTransferred == this->m_pFirstBuf->m_dwSize )
  {
    this->m_nPendingWrite -= this->m_pFirstBuf->m_dwSize;
    v6 = this->m_pFirstBuf;
    this->m_pFirstBuf = this->m_pFirstBuf->m_pNext;
    if ( this->m_pFirstBuf )
    {
      CIOObject::AddRef((volatile LONG *)this);
      Buffers.len = this->m_pFirstBuf->m_dwSize;
      Buffers.buf = this->m_pFirstBuf->m_buffer;
      if ( !WSASend(this->m_hSocket, &Buffers, 1u, &NumberOfBytesSent, 0, &this->m_overlappedWrite, 0)
        || GetLastError() == 997 )
      {
        CIOCriticalSection::Leave(&this->m_lock);
      }
      else
      {
        v3 = GetLastError();
        CIOCriticalSection::Leave(&this->m_lock);
        if ( v3 != 10038 && v3 != 10054 && v3 != 10053 && v3 != 10058 )
          LOG_ERR("CIOSocket::WriteCallback %x(%x) err=%d", this->m_hSocket, this, v3);
        CIOObject::Release((volatile LONG *)this);
      }
    }
    else
    {
      this->m_pLastBuf = 0;
      CIOCriticalSection::Leave(&this->m_lock);
    }
    CIOBuffer::Free(v6);
  }
  else
  {
    LOG_ERR("different write count %x(%x) %d != %d", this->m_hSocket, this, dwTransferred, this->m_pFirstBuf->m_dwSize);
    CIOCriticalSection::Leave(&this->m_lock);
  }
}

//----- (0040BD10) --------------------------------------------------------
void __thiscall CIOSocket::Write(CIOSocket *this, CIOBuffer *pBuffer)
{
  DWORD v3; // [esp+4h] [ebp-10h]
  struct _WSABUF Buffers; // [esp+8h] [ebp-Ch] BYREF
  DWORD NumberOfBytesSent; // [esp+10h] [ebp-4h] BYREF

  if ( pBuffer->m_dwSize )
  {
    if ( pBuffer->m_dwSize > 0x1F40 )
      EBREAK();
    CIOCriticalSection::Enter(&this->m_lock);
    this->m_nPendingWrite += pBuffer->m_dwSize;
    if ( this->m_pLastBuf )
    {
      if ( this->m_pFirstBuf == this->m_pLastBuf || pBuffer->m_dwSize + this->m_pLastBuf->m_dwSize > 0x1F40 )
      {
        this->m_pLastBuf->m_pNext = pBuffer;
        this->m_pLastBuf = pBuffer;
        CIOCriticalSection::Leave(&this->m_lock);
      }
      else
      {
        memcpy(&this->m_pLastBuf->m_buffer[this->m_pLastBuf->m_dwSize], pBuffer, pBuffer->m_dwSize);
        this->m_pLastBuf->m_dwSize += pBuffer->m_dwSize;
        CIOCriticalSection::Leave(&this->m_lock);
        CIOBuffer::Free(pBuffer);
      }
    }
    else
    {
      this->m_pLastBuf = pBuffer;
      this->m_pFirstBuf = pBuffer;
      CIOObject::AddRef((volatile LONG *)this);
      Buffers.len = pBuffer->m_dwSize;
      Buffers.buf = (CHAR *)pBuffer;
      if ( !WSASend(this->m_hSocket, &Buffers, 1u, &NumberOfBytesSent, 0, &this->m_overlappedWrite, 0)
        || GetLastError() == 997 )
      {
        CIOCriticalSection::Leave(&this->m_lock);
      }
      else
      {
        v3 = GetLastError();
        CIOCriticalSection::Leave(&this->m_lock);
        if ( v3 != 10038 && v3 != 10054 && v3 != 10053 && v3 != 10058 )
          LOG_ERR("CIOSocket::Write %x(%x) err=%d", this->m_hSocket, this, v3);
        CIOObject::Release((volatile LONG *)this);
      }
    }
  }
  else
  {
    CIOBuffer::Free(pBuffer);
  }
}

//----- (0040BF80) --------------------------------------------------------
_DWORD *__thiscall sub_40BF80(_DWORD *this)
{
  CIOObject::CIOObject((CIOObject *)this);
  *this = &off_42B5F8;
  this[4] = -1;
  this[5] = 0;
  return this;
}
// 42B5F8: using guessed type int (__stdcall *off_42B5F8)(int);

//----- (0040BFC0) --------------------------------------------------------
void __thiscall CIOServer::~CIOServer(CIOServer *this)
{
  this->__vftable = (CIOServer_vtbl *)&off_42B5F8;
  CIOServer::Close(this);
  CIOObject::~CIOObject(this);
}
// 42B5F8: using guessed type int (__stdcall *off_42B5F8)(int);

//----- (0040C020) --------------------------------------------------------
void __thiscall CIOServer::Close(CIOServer *this)
{
  if ( this->m_hSocket != -1 )
  {
    closesocket(this->m_hSocket);
    this->m_hSocket = -1;
  }
  if ( this->m_hAcceptEvent )
  {
    WSACloseEvent(this->m_hAcceptEvent);
    this->m_hAcceptEvent = 0;
  }
}

//----- (0040C070) --------------------------------------------------------
int __thiscall CIOServer::Start(CIOServer *this, int nPort)
{
  int v2; // eax
  int v4; // eax
  int v5; // eax
  struct sockaddr name; // [esp+4h] [ebp-14h] BYREF

  this->m_hSocket = socket(2, 1, 0);
  if ( this->m_hSocket == -1 )
  {
    v2 = WSAGetLastError();
    LOG_ERR("socket error %d", v2);
    return 0;
  }
  name.sa_family = 2;
  *(_DWORD *)&name.sa_data[2] = htonl(0);
  *(_WORD *)name.sa_data = htons(nPort);
  if ( bind(this->m_hSocket, &name, 16) )
  {
    v4 = WSAGetLastError();
    LOG_ERR("bind error %d", v4);
  }
  else if ( listen(this->m_hSocket, 5) )
  {
    v5 = WSAGetLastError();
    LOG_ERR("listen error %d", v5);
  }
  else
  {
    this->m_hAcceptEvent = WSACreateEvent();
    WSAEventSelect(this->m_hSocket, this->m_hAcceptEvent, 8);
    if ( CIOObject::RegisterWait(this, this->m_hAcceptEvent) )
      return 1;
    LOG_ERR("RegisterWait error on port %d", nPort);
  }
  CIOServer::Close(this);
  return 0;
}

//----- (0040C1A0) --------------------------------------------------------
BOOL __thiscall sub_40C1A0(HANDLE *this)
{
  WSAResetEvent(this[5]);
  return PostQueuedCompletionStatus(CompletionPort, 0, (ULONG_PTR)this, 0);
}

//----- (0040C1D0) --------------------------------------------------------
int __thiscall sub_40C1D0(_DWORD *this)
{
  SOCKET s; // [esp+4h] [ebp-4h]

  s = this[4];
  this[4] = -1;
  return closesocket(s);
}

//----- (0040C200) --------------------------------------------------------
void __thiscall CIOServer::OnIOCallback(CIOServer *this, int bSuccess, unsigned int dwTransferred, _OVERLAPPED *lpOverlapped)
{
  int v4; // eax
  struct sockaddr addr; // [esp+4h] [ebp-20h] BYREF
  CIOSocket *v7; // [esp+18h] [ebp-Ch]
  int addrlen; // [esp+1Ch] [ebp-8h] BYREF
  SOCKET s; // [esp+20h] [ebp-4h]

  addrlen = 16;
  s = accept(this->m_hSocket, &addr, &addrlen);
  if ( s == -1 )
  {
    if ( WSAGetLastError() != 10035 && this->m_hSocket != -1 )
    {
      v4 = WSAGetLastError();
      LOG_ERR("accept error: %d", v4);
    }
  }
  else
  {
    v7 = this->CreateSocket(this, s, &addr);
    if ( v7 )
    {
      CIOSocket::Initialize(v7);
      CIOObject::Release((volatile LONG *)v7);
    }
    else
    {
      closesocket(s);
    }
  }
}

//----- (0040C2B0) --------------------------------------------------------
void __thiscall CIOSocket::Initialize(CIOSocket *this)
{
  DWORD v1; // eax
  unsigned int v2; // [esp-8h] [ebp-10h]
  HANDLE v3; // [esp-4h] [ebp-Ch]
  char optval[4]; // [esp+4h] [ebp-4h] BYREF

  if ( CreateIoCompletionPort((HANDLE)this->m_hSocket, CompletionPort, (ULONG_PTR)this, 0) )
  {
    *(_DWORD *)optval = 0;
    setsockopt(this->m_hSocket, 0xFFFF, 4098, optval, 4);
    *(_DWORD *)optval = 0;
    setsockopt(this->m_hSocket, 0xFFFF, 4097, optval, 4);
    this->OnCreate(this);
  }
  else
  {
    v3 = CompletionPort;
    v2 = this->m_hSocket;
    v1 = GetLastError();
    ELOG("CreateIoCompletionPort: %d %x %x\n", v1, v2, v3);
    CIOSocket::Close((char *)this);
  }
}

//----- (0040C360) --------------------------------------------------------
void __thiscall CIOObject::OnFree(CIOObject *this)
{
  if ( this )
    ((void (__thiscall *)(CIOObject *, int))this->~CIOObject)(this, 1);
}

//----- (0040C3C0) --------------------------------------------------------
_DWORD *__thiscall CIOObject::`vector deleting destructor'(_DWORD *this, char a2)
{
  CIOObject::~CIOObject(this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (0040C3F0) --------------------------------------------------------
void __thiscall CIOSocket::CIOTimer::CIOTimer(CIOSocket::CIOTimer *this, CIOObject *pObject, unsigned int dwTime, int nId)
{
  this->m_dwTime = dwTime;
  this->m_pObject = pObject;
  this->m_nId = nId;
}

//----- (0040C420) --------------------------------------------------------
void __thiscall CIOObject::Release(volatile LONG *this)
{
  CIOObject::Release((CIOObject *)this, this + 3);
}

//----- (0040C440) --------------------------------------------------------
BOOL __thiscall CIOObject::PostObject(void *this, DWORD dwNumberOfBytesTransferred)
{
  return PostQueuedCompletionStatus(CompletionPort, dwNumberOfBytesTransferred, (ULONG_PTR)this, 0);
}

//----- (0040C4A0) --------------------------------------------------------
CIOObject *__thiscall CIOObject::CIOObject(CIOObject *this)
{
  this->__vftable = (CIOObject_vtbl *)&off_42B5BC;
  this->m_nRef = 1;
  this->m_nTimerRef = 0;
  this->m_nGeneralRef = 1;
  return this;
}
// 42B5BC: using guessed type int (__stdcall *off_42B5BC)(int);

//----- (0040C4E0) --------------------------------------------------------
void __thiscall CIOObject::AddRef(volatile LONG *this)
{
  CIOObject::AddRef((CIOObject *)this, this + 3);
}

//----- (0040C500) --------------------------------------------------------
void *__thiscall CIOSocket::`vftable'(void *this, char a2)
{
  CIOSocket::~CIOSocket((CIOSocket *)this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (0040C530) --------------------------------------------------------
void __thiscall CIOBuffer::Release(CIOBuffer *this)
{
  if ( !InterlockedDecrement(&this->m_nRef) )
    CIOBuffer::Free(this);
}

//----- (0040C560) --------------------------------------------------------
_DWORD *__thiscall CIOServer::`vftable'(_DWORD *this, char a2)
{
  CIOServer::~CIOServer((CIOServer *)this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (0040C590) --------------------------------------------------------
BOOL __thiscall sub_40C590(void *this)
{
  return std::vector<CIOSocket::CIOTimer>::empty(this);
}

//----- (0040C5B0) --------------------------------------------------------
int __thiscall sub_40C5B0(void *this)
{
  return sub_40C690((int *)this);
}

//----- (0040C5D0) --------------------------------------------------------
int *__thiscall sub_40C5D0(int this, int a2)
{
  int *v2; // eax
  int v4; // [esp-8h] [ebp-14h]
  char v6[4]; // [esp+4h] [ebp-8h] BYREF
  char v7[4]; // [esp+8h] [ebp-4h] BYREF

  std::vector<CIOSocket::CIOTimer>::push_back(this, a2);
  v4 = *(_DWORD *)std::vector<CIOSocket::CIOTimer>::end((_DWORD *)this, (int)v7);
  v2 = (int *)std::vector<CSyncPacket::CElement>::begin((int *)this, v6);
  return std::push_heap<std::vector<CIOSocket::CIOTimer>::iterator,std::less<CIOSocket::CIOTimer>>(*v2, v4);
}

//----- (0040C620) --------------------------------------------------------
int __thiscall sub_40C620(int this)
{
  int *v1; // eax
  int v3; // [esp-8h] [ebp-14h]
  char v4; // [esp-4h] [ebp-10h]
  char v6[4]; // [esp+4h] [ebp-8h] BYREF
  char v7[4]; // [esp+8h] [ebp-4h] BYREF

  v4 = *(_BYTE *)(this + 16);
  v3 = *(_DWORD *)std::vector<CIOSocket::CIOTimer>::end((_DWORD *)this, (int)v7);
  v1 = (int *)std::vector<CSyncPacket::CElement>::begin((int *)this, v6);
  std::pop_heap<std::vector<CIOSocket::CIOTimer>::iterator,std::less<CIOSocket::CIOTimer>>(*v1, v3, v4);
  return std::vector<CIOSocket::CIOTimer>::pop_back((_DWORD *)this);
}

//----- (0040C670) --------------------------------------------------------
BOOL __thiscall std::vector<CIOSocket::CIOTimer>::empty(void *this)
{
  return std::vector<CIOSocket::CIOTimer>::size(this) == 0;
}

//----- (0040C690) --------------------------------------------------------
int __thiscall sub_40C690(int *this)
{
  void *v1; // eax
  char v3[4]; // [esp+4h] [ebp-4h] BYREF

  v1 = std::vector<CSyncPacket::CElement>::begin(this, v3);
  return std::vector<CSyncPacket::CElement>::iterator::operator*(v1);
}

//----- (0040C6B0) --------------------------------------------------------
int __thiscall std::vector<CIOSocket::CIOTimer>::push_back(int this, int a2)
{
  unsigned int v2; // esi
  int result; // eax
  int *v4; // eax
  char v6[4]; // [esp+8h] [ebp-8h] BYREF
  char v7[4]; // [esp+Ch] [ebp-4h] BYREF

  v2 = std::vector<CIOSocket::CIOTimer>::size((_DWORD *)this);
  if ( v2 >= std::vector<CIOSocket::CIOTimer>::capacity((_DWORD *)this) )
  {
    v4 = (int *)std::vector<CIOSocket::CIOTimer>::end((_DWORD *)this, (int)v7);
    result = std::vector<CIOSocket::CIOTimer>::insert((_DWORD *)this, (int)v6, *v4, a2);
  }
  else
  {
    result = std::vector<CIOSocket::CIOTimer>::_Ufill((void *)this, *(void **)(this + 8), 1, a2);
    *(_DWORD *)(this + 8) = result;
  }
  return result;
}

//----- (0040C720) --------------------------------------------------------
int __thiscall std::vector<CIOSocket::CIOTimer>::pop_back(_DWORD *this)
{
  int result; // eax

  result = std::vector<CIOSocket::CIOTimer>::empty(this);
  if ( !(_BYTE)result )
  {
    std::vector<CIOSocket::CIOTimer>::_Destroy(this, this[2] - 12, this[2]);
    result = this[2] - 12;
    this[2] = result;
  }
  return result;
}

//----- (0040C770) --------------------------------------------------------
int __thiscall std::vector<CIOSocket::CIOTimer>::capacity(_DWORD *this)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( this[1] )
    v2 = (this[3] - this[1]) / 12;
  else
    v2 = 0;
  return v2;
}

//----- (0040C7B0) --------------------------------------------------------
int __thiscall std::vector<CIOSocket::CIOTimer>::size(_DWORD *this)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( this[1] )
    v2 = (this[2] - this[1]) / 12;
  else
    v2 = 0;
  return v2;
}

//----- (0040C7F0) --------------------------------------------------------
int __thiscall std::vector<CIOSocket::CIOTimer>::insert(_DWORD *this, int a2, int a3, int a4)
{
  void *v4; // eax
  int *v5; // eax
  int v7; // [esp-4h] [ebp-18h]
  int v8; // [esp+0h] [ebp-14h]
  char v10[4]; // [esp+8h] [ebp-Ch] BYREF
  char v11[4]; // [esp+Ch] [ebp-8h] BYREF
  int v12; // [esp+10h] [ebp-4h]

  if ( std::vector<CIOSocket::CIOTimer>::size(this) )
  {
    v4 = std::vector<CSyncPacket::CElement>::begin(this, v11);
    v8 = std::vector<CIOSocket::CIOTimer>::iterator::operator-(&a3, (int)v4);
  }
  else
  {
    v8 = 0;
  }
  v12 = v8;
  std::vector<CIOSocket::CIOTimer>::_Insert_n(this, a3, 1u, (int *)a4);
  v7 = v12;
  v5 = (int *)std::vector<CSyncPacket::CElement>::begin(this, v10);
  std::vector<CIOSocket::CIOTimer>::iterator::operator+(v5, (_DWORD *)a2, v7);
  return a2;
}

//----- (0040C870) --------------------------------------------------------
int __thiscall std::vector<CIOSocket::CIOTimer>::_Destroy(void *this, int a2, int a3)
{
  return std::_Destroy_range<CIOSocket::CIOTimer>(a2, a3);
}

//----- (0040C8A0) --------------------------------------------------------
int __thiscall std::vector<CIOSocket::CIOTimer>::_Ufill(void *this, void *a2, int a3, int a4)
{
  sub_40CE50(a2, a3, a4);
  return (int)a2 + 12 * a3;
}

//----- (0040C8D0) --------------------------------------------------------
void *__thiscall std::vector<CIOSocket::CIOTimer>::_Insert_n(_DWORD *this, int a2, unsigned int a3, int *a4)
{
  void *result; // eax
  int v5; // esi
  int v6; // eax
  unsigned int v7; // esi
  int v8; // eax
  int v9; // eax
  void *v10; // eax
  int v11; // [esp+0h] [ebp-48h] BYREF
  void *v12; // [esp+Ch] [ebp-3Ch]
  void *v13; // [esp+10h] [ebp-38h]
  unsigned int v14; // [esp+14h] [ebp-34h]
  int *v15; // [esp+18h] [ebp-30h]
  int v16; // [esp+1Ch] [ebp-2Ch]
  void *v17; // [esp+20h] [ebp-28h]
  void *v18; // [esp+24h] [ebp-24h]
  unsigned int v19; // [esp+28h] [ebp-20h]
  int v20[4]; // [esp+2Ch] [ebp-1Ch] BYREF
  int v21; // [esp+44h] [ebp-4h]
  int v22; // [esp+54h] [ebp+Ch]

  v20[3] = (int)&v11;
  v15 = this;
  v20[0] = *a4;
  v20[1] = a4[1];
  v20[2] = a4[2];
  result = (void *)std::vector<CIOSocket::CIOTimer>::capacity(this);
  v19 = (unsigned int)result;
  if ( a3 )
  {
    v5 = std::vector<CIOSocket::CIOTimer>::size(v15);
    if ( std::priority_queue<CIOSocket::CIOTimer>::empty(v15) - v5 < a3 )
      std::vector<CIOSocket::CIOTimer>::_Xlen();
    v6 = std::vector<CIOSocket::CIOTimer>::size(v15);
    if ( v19 >= a3 + v6 )
    {
      if ( (v15[2] - a2) / 12 >= a3 )
      {
        v16 = v15[2];
        v10 = sub_40CE90(v15, v16 - 12 * a3, v16, (void *)v15[2]);
        v15[2] = (int)v10;
        sub_40CEF0(a2, v16 - 12 * a3, v16);
        result = std::fill<CIOSocket::CIOTimer *,CIOSocket::CIOTimer>((_DWORD *)a2, (_DWORD *)(a2 + 12 * a3), v20);
      }
      else
      {
        sub_40CE90(v15, a2, v15[2], (void *)(a2 + 12 * a3));
        v21 = 2;
        std::vector<CIOSocket::CIOTimer>::_Ufill(v15, (void *)v15[2], a3 - (v15[2] - a2) / 12, (int)v20);
        v21 = -1;
        v15[2] += 12 * a3;
        result = std::fill<CIOSocket::CIOTimer *,CIOSocket::CIOTimer>((_DWORD *)a2, (_DWORD *)(v15[2] - 12 * a3), v20);
      }
    }
    else
    {
      v7 = v19 >> 1;
      v8 = std::priority_queue<CIOSocket::CIOTimer>::empty(v15);
      if ( v8 - v7 >= v19 )
        v14 = v19 + (v19 >> 1);
      else
        v14 = 0;
      v19 = v14;
      v9 = std::vector<CIOSocket::CIOTimer>::size(v15);
      if ( v19 < a3 + v9 )
        v19 = a3 + std::vector<CIOSocket::CIOTimer>::size(v15);
      v17 = std::allocator<CIOSocket::CIOTimer>::allocate(v19);
      v18 = v17;
      v21 = 0;
      v13 = sub_40CE90(v15, v15[1], a2, v17);
      v18 = v13;
      v12 = (void *)std::vector<CIOSocket::CIOTimer>::_Ufill(v15, v13, a3, (int)v20);
      v18 = v12;
      sub_40CE90(v15, a2, v15[2], v12);
      v21 = -1;
      v22 = a3 + std::vector<CIOSocket::CIOTimer>::size(v15);
      if ( v15[1] )
      {
        std::vector<CIOSocket::CIOTimer>::_Destroy(v15, v15[1], v15[2]);
        std::allocator<CSyncPacket::CElement>::deallocate(v15[1], (v15[3] - v15[1]) / 12);
      }
      v15[3] = (int)v17 + 12 * v19;
      v15[2] = (int)v17 + 12 * v22;
      result = v17;
      v15[1] = (int)v17;
    }
  }
  return result;
}

//----- (0040CC10) --------------------------------------------------------
int __thiscall std::priority_queue<CIOSocket::CIOTimer>::empty(void *this)
{
  return std::allocator<CIOSocket::CIOTimer>::max_size();
}

//----- (0040CC30) --------------------------------------------------------
void __noreturn std::vector<CIOSocket::CIOTimer>::_Xlen()
{
  char v0[28]; // [esp+4h] [ebp-50h] BYREF
  char pExceptionObject[48]; // [esp+20h] [ebp-34h] BYREF
  int v2; // [esp+50h] [ebp-4h]

  std::string::string(v0, "vector<T> too long");
  v2 = 0;
  std::length_error::length_error((std::length_error *)pExceptionObject, (const std::length_error *)v0);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);
}

//----- (0040CC90) --------------------------------------------------------
CMemory **__stdcall std::allocator<CIOSocket::CIOTimer>::allocate(int a1)
{
  return std::_Allocate<CIOSocket::CIOTimer>(a1);
}

//----- (0040CCB0) --------------------------------------------------------
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator+(int *this, _DWORD *a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h] BYREF

  v4 = *this;
  *a1 = *std::vector<CIOSocket::CIOTimer>::iterator::operator+=(&v4, a2);
  return a1;
}

//----- (0040CCE0) --------------------------------------------------------
int __thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator-(int *this, int a1)
{
  int v3; // [esp+4h] [ebp-4h] BYREF

  v3 = *this;
  return std::vector<CIOSocket::CIOTimer>::const_iterator::operator-(&v3, (_DWORD *)a1);
}

//----- (0040CD10) --------------------------------------------------------
int std::allocator<CIOSocket::CIOTimer>::max_size()
{
  return 357913941;
}

//----- (0040CD40) --------------------------------------------------------
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator+=(_DWORD *this, int a2)
{
  *this += 12 * a2;
  return this;
}

//----- (0040CD60) --------------------------------------------------------
int __thiscall std::vector<CIOSocket::CIOTimer>::const_iterator::operator-(_DWORD *this, _DWORD *a2)
{
  return (*this - *a2) / 12;
}

//----- (0040CD80) --------------------------------------------------------
int *__cdecl std::push_heap<std::vector<CIOSocket::CIOTimer>::iterator,std::less<CIOSocket::CIOTimer>>(int a1, int a2)
{
  int *result; // eax
  int *v3; // eax

  result = (int *)std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::operator!=((int)&a2);
  if ( (_BYTE)result )
  {
    std::_Dist_type<std::vector<CIOSocket::CIOTimer>::iterator>();
    std::_Dist_type<std::vector<CIOSocket::CIOTimer>::iterator>();
    v3 = std::vector<CIOSocket::CIOTimer>::iterator::operator--(&a2);
    result = std::_Push_heap_0<std::vector<CIOSocket::CIOTimer>::iterator,int,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(
               a1,
               *v3);
  }
  return result;
}

//----- (0040CDD0) --------------------------------------------------------
int __cdecl std::pop_heap<std::vector<CIOSocket::CIOTimer>::iterator,std::less<CIOSocket::CIOTimer>>(int a1, int a2, char a3)
{
  int result; // eax
  int v4; // eax
  int v5; // edx

  result = std::vector<CIOSocket::CIOTimer>::iterator::operator-(&a2, (int)&a1);
  if ( result > 1 )
  {
    v4 = std::_Dist_type<std::vector<CIOSocket::CIOTimer>::iterator>();
    LOBYTE(v5) = a3;
    result = (int)std::_Pop_heap_0<std::vector<CIOSocket::CIOTimer>::iterator,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(
                    a1,
                    a2,
                    v5,
                    v4);
  }
  return result;
}
// 40CDFD: variable 'v5' is possibly undefined

//----- (0040CE10) --------------------------------------------------------
int __cdecl std::_Destroy_range<CIOSocket::CIOTimer>(int a1, int a2)
{
  unknown_libname_15(&a1, &a2);
  return std::_Destroy_range<CIOSocket::CIOTimer>(a1, a2);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (0040CE50) --------------------------------------------------------
void *__cdecl sub_40CE50(void *a1, int a2, int a3)
{
  unknown_libname_15(&a1, &a1);
  return std::_Uninit_fill_n<CIOSocket::CIOTimer *,unsigned int,CIOSocket::CIOTimer,std::allocator<CIOSocket::CIOTimer>>(
           a1,
           a2,
           a3);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (0040CE90) --------------------------------------------------------
void *__thiscall sub_40CE90(void *this, int a2, int a3, void *a4)
{
  return sub_40D180(a2, a3, a4);
}

//----- (0040CEC0) --------------------------------------------------------
_DWORD *__cdecl std::fill<CIOSocket::CIOTimer *,CIOSocket::CIOTimer>(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  while ( a1 != a2 )
  {
    *a1 = *a3;
    a1[1] = a3[1];
    a1[2] = a3[2];
    result = a1 + 3;
    a1 += 3;
  }
  return result;
}

//----- (0040CEF0) --------------------------------------------------------
_DWORD *__cdecl sub_40CEF0(int a1, int a2, int a3)
{
  unknown_libname_15(&a1, &a3);
  return std::_Copy_backward_opt<CIOSocket::CIOTimer *,CIOSocket::CIOTimer *>((_DWORD *)a1, (_DWORD *)a2, (_DWORD *)a3);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (0040CF30) --------------------------------------------------------
CMemory **__cdecl std::_Allocate<CIOSocket::CIOTimer>(int a1)
{
  return operator new(12 * a1);
}

//----- (0040CF50) --------------------------------------------------------
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator--(_DWORD *this)
{
  *this -= 12;
  return this;
}

//----- (0040CF70) --------------------------------------------------------
BOOL __stdcall std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::operator!=(int a1)
{
  return (unsigned __int8)unknown_libname_18(a1) == 0;
}
// 405110: using guessed type _DWORD __stdcall unknown_libname_18(_DWORD);

//----- (0040CFA0) --------------------------------------------------------
int std::_Dist_type<std::vector<CIOSocket::CIOTimer>::iterator>()
{
  return 0;
}

//----- (0040CFB0) --------------------------------------------------------
int *__cdecl std::_Push_heap_0<std::vector<CIOSocket::CIOTimer>::iterator,int,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(int a1, int a2)
{
  int *result; // eax
  int *v3; // eax
  int *v4; // [esp+Ch] [ebp-4h]

  result = (int *)std::vector<CIOSocket::CIOTimer>::iterator::operator-(&a2, (int)&a1);
  v4 = result;
  if ( (int)result > 0 )
  {
    v3 = (int *)std::vector<CSyncPacket::CElement>::iterator::operator*(&a2);
    result = std::_Push_heap<std::vector<CIOSocket::CIOTimer>::iterator,int,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(
               a1,
               (int)v4,
               0,
               *v3,
               v3[1],
               v3[2]);
  }
  return result;
}

//----- (0040D020) --------------------------------------------------------
int *std::_Pop_heap_0<std::vector<CIOSocket::CIOTimer>::iterator,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(int a1, int a2, ...)
{
  _DWORD *v2; // eax
  int *v3; // eax
  int *v4; // eax
  int v6; // [esp-18h] [ebp-30h]
  int v7; // [esp-14h] [ebp-2Ch]
  int v8; // [esp-10h] [ebp-28h]
  int v9; // [esp-Ch] [ebp-24h]
  char v10[4]; // [esp+0h] [ebp-18h] BYREF
  char v11[4]; // [esp+4h] [ebp-14h] BYREF
  char v12[4]; // [esp+8h] [ebp-10h] BYREF
  int v13; // [esp+Ch] [ebp-Ch]
  int v14; // [esp+10h] [ebp-8h]
  int v15; // [esp+14h] [ebp-4h]

  v2 = std::vector<CIOSocket::CIOTimer>::iterator::operator-(&a2, v12, 1);
  v3 = (int *)std::vector<CSyncPacket::CElement>::iterator::operator*(v2);
  v13 = *v3;
  v14 = v3[1];
  v15 = v3[2];
  std::_Dist_type<std::vector<CIOSocket::CIOTimer>::iterator>();
  v7 = v13;
  v8 = v14;
  v9 = v15;
  v6 = *std::vector<CIOSocket::CIOTimer>::iterator::operator-(&a2, v11, 1);
  v4 = std::vector<CIOSocket::CIOTimer>::iterator::operator-(&a2, v10, 1);
  return sub_40D340(a1, *v4, v6, v7, v8, v9);
}

//----- (0040D0B0) --------------------------------------------------------
int __cdecl std::_Destroy_range<CIOSocket::CIOTimer>(int a1, int a2)
{
  int result; // eax

  while ( a1 != a2 )
  {
    std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::destroy(a1);
    result = a1 + 12;
    a1 += 12;
  }
  return result;
}

//----- (0040D0E0) --------------------------------------------------------
void *__cdecl std::_Uninit_fill_n<CIOSocket::CIOTimer *,unsigned int,CIOSocket::CIOTimer,std::allocator<CIOSocket::CIOTimer>>(void *a1, int a2, int a3)
{
  void *result; // eax
  _DWORD v4[8]; // [esp+0h] [ebp-20h] BYREF

  v4[4] = v4;
  result = a1;
  v4[3] = a1;
  v4[7] = 0;
  while ( a2 )
  {
    result = std::allocator<CIOSocket::CIOTimer>::construct(a1, a3);
    --a2;
    a1 = (char *)a1 + 12;
  }
  return result;
}

//----- (0040D180) --------------------------------------------------------
void *__cdecl sub_40D180(int a1, int a2, void *a3)
{
  unknown_libname_15(&a1, &a3);
  return std::_Uninit_copy<CIOSocket::CIOTimer *,CIOSocket::CIOTimer *,std::allocator<CIOSocket::CIOTimer>>(a1, a2, a3);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (0040D1C0) --------------------------------------------------------
_DWORD *__cdecl std::_Copy_backward_opt<CIOSocket::CIOTimer *,CIOSocket::CIOTimer *>(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  while ( a1 != a2 )
  {
    a2 -= 3;
    a3 -= 3;
    *a3 = *a2;
    a3[1] = a2[1];
    a3[2] = a2[2];
  }
  return a3;
}

//----- (0040D200) --------------------------------------------------------
_DWORD *__stdcall std::allocator<CIOSocket::CIOTimer>::construct(void *a1, int a2)
{
  return std::_Construct<CIOSocket::CIOTimer,CIOSocket::CIOTimer>(a1, a2);
}

//----- (0040D220) --------------------------------------------------------
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator-(int *this, _DWORD *a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h] BYREF

  v4 = *this;
  *a1 = *std::vector<CIOSocket::CIOTimer>::iterator::operator-=(&v4, a2);
  return a1;
}

//----- (0040D250) --------------------------------------------------------
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::iterator::operator-=(_DWORD *this, int a2)
{
  return std::vector<CIOSocket::CIOTimer>::iterator::operator+=(this, -a2);
}

//----- (0040D270) --------------------------------------------------------
int *__cdecl std::_Push_heap<std::vector<CIOSocket::CIOTimer>::iterator,int,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // eax
  int v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  int *result; // eax
  int v14; // [esp+4h] [ebp-14h] BYREF
  int v15; // [esp+8h] [ebp-10h] BYREF
  int v16; // [esp+Ch] [ebp-Ch] BYREF
  int v17; // [esp+10h] [ebp-8h] BYREF
  int i; // [esp+14h] [ebp-4h]

  for ( i = (a2 - 1) / 2; a3 < a2; i = (i - 1) / 2 )
  {
    v6 = std::vector<CIOSocket::CIOTimer>::iterator::operator+(&a1, &v17, i);
    v7 = std::vector<CSyncPacket::CElement>::iterator::operator*(v6);
    if ( !std::less<CIOSocket::CIOTimer>::operator()(v7, (int)&a4) )
      break;
    v8 = std::vector<CIOSocket::CIOTimer>::iterator::operator+(&a1, &v15, i);
    v9 = (_DWORD *)std::vector<CSyncPacket::CElement>::iterator::operator*(v8);
    v10 = std::vector<CIOSocket::CIOTimer>::iterator::operator+(&a1, &v16, a2);
    v11 = (_DWORD *)std::vector<CSyncPacket::CElement>::iterator::operator*(v10);
    *v11 = *v9;
    v11[1] = v9[1];
    v11[2] = v9[2];
    a2 = i;
  }
  v12 = std::vector<CIOSocket::CIOTimer>::iterator::operator+(&a1, &v14, a2);
  result = (int *)std::vector<CSyncPacket::CElement>::iterator::operator*(v12);
  *result = a4;
  result[1] = a5;
  result[2] = a6;
  return result;
}

//----- (0040D340) --------------------------------------------------------
int *__cdecl sub_40D340(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // esi
  _DWORD *v7; // eax
  int v8; // eax
  int v10; // [esp-10h] [ebp-14h]
  int v11; // [esp-Ch] [ebp-10h]
  int v12; // [esp-8h] [ebp-Ch]

  v6 = (_DWORD *)std::vector<CSyncPacket::CElement>::iterator::operator*(&a1);
  v7 = (_DWORD *)std::vector<CSyncPacket::CElement>::iterator::operator*(&a3);
  *v7 = *v6;
  v7[1] = v6[1];
  v7[2] = v6[2];
  v10 = a4;
  v11 = a5;
  v12 = a6;
  v8 = std::vector<CIOSocket::CIOTimer>::iterator::operator-(&a2, (int)&a1);
  return std::_Adjust_heap<std::vector<CIOSocket::CIOTimer>::iterator,int,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(
           a1,
           0,
           v8,
           v10,
           v11,
           v12);
}

//----- (0040D3A0) --------------------------------------------------------
void *__cdecl std::_Uninit_copy<CIOSocket::CIOTimer *,CIOSocket::CIOTimer *,std::allocator<CIOSocket::CIOTimer>>(int a1, int a2, void *a3)
{
  _DWORD v4[8]; // [esp+0h] [ebp-20h] BYREF

  v4[4] = v4;
  v4[3] = a3;
  v4[7] = 0;
  while ( a1 != a2 )
  {
    std::allocator<CIOSocket::CIOTimer>::construct(a3, a1);
    a3 = (char *)a3 + 12;
    a1 += 12;
  }
  return a3;
}

//----- (0040D450) --------------------------------------------------------
_DWORD *__cdecl std::_Construct<CIOSocket::CIOTimer,CIOSocket::CIOTimer>(void *a1, int a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+4h] [ebp-4h]

  result = operator new(0xCu, a1);
  v3 = result;
  if ( result )
  {
    *result = *(_DWORD *)a2;
    result = *(_DWORD **)(a2 + 4);
    v3[1] = result;
    v3[2] = *(_DWORD *)(a2 + 8);
  }
  return result;
}

//----- (0040D4A0) --------------------------------------------------------
void sub_40D4A0()
{
  ;
}

//----- (0040D4B0) --------------------------------------------------------
BOOL __stdcall std::less<CIOSocket::CIOTimer>::operator()(int a1, int a2)
{
  return CIOSocket::CIOTimer::operator<((_DWORD *)a1, (_DWORD *)a2);
}

//----- (0040D4D0) --------------------------------------------------------
BOOL __thiscall CIOSocket::CIOTimer::operator<(_DWORD *this, _DWORD *a2)
{
  return *this - *a2 > 0;
}

//----- (0040D4F0) --------------------------------------------------------
int *__cdecl std::_Adjust_heap<std::vector<CIOSocket::CIOTimer>::iterator,int,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  int v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // esi
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // esi
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  int v18; // [esp-4h] [ebp-28h]
  int v19; // [esp+4h] [ebp-20h] BYREF
  int v20; // [esp+8h] [ebp-1Ch] BYREF
  int v21; // [esp+Ch] [ebp-18h] BYREF
  int v22; // [esp+10h] [ebp-14h] BYREF
  int v23; // [esp+14h] [ebp-10h] BYREF
  int v24; // [esp+18h] [ebp-Ch] BYREF
  int i; // [esp+1Ch] [ebp-8h]
  int v26; // [esp+20h] [ebp-4h]

  v26 = a2;
  for ( i = 2 * a2 + 2; i < a3; i = 2 * i + 2 )
  {
    v6 = std::vector<CIOSocket::CIOTimer>::iterator::operator+(&a1, &v24, i - 1);
    v18 = std::vector<CSyncPacket::CElement>::iterator::operator*(v6);
    v7 = std::vector<CIOSocket::CIOTimer>::iterator::operator+(&a1, &v23, i);
    v8 = std::vector<CSyncPacket::CElement>::iterator::operator*(v7);
    if ( std::less<CIOSocket::CIOTimer>::operator()(v8, v18) )
      --i;
    v9 = std::vector<CIOSocket::CIOTimer>::iterator::operator+(&a1, &v21, i);
    v10 = (_DWORD *)std::vector<CSyncPacket::CElement>::iterator::operator*(v9);
    v11 = std::vector<CIOSocket::CIOTimer>::iterator::operator+(&a1, &v22, a2);
    v12 = (_DWORD *)std::vector<CSyncPacket::CElement>::iterator::operator*(v11);
    *v12 = *v10;
    v12[1] = v10[1];
    v12[2] = v10[2];
    a2 = i;
  }
  if ( i == a3 )
  {
    v13 = std::vector<CIOSocket::CIOTimer>::iterator::operator+(&a1, &v19, a3 - 1);
    v14 = (_DWORD *)std::vector<CSyncPacket::CElement>::iterator::operator*(v13);
    v15 = std::vector<CIOSocket::CIOTimer>::iterator::operator+(&a1, &v20, a2);
    v16 = (_DWORD *)std::vector<CSyncPacket::CElement>::iterator::operator*(v15);
    *v16 = *v14;
    v16[1] = v14[1];
    v16[2] = v14[2];
    a2 = a3 - 1;
  }
  return std::_Push_heap<std::vector<CIOSocket::CIOTimer>::iterator,int,CIOSocket::CIOTimer,std::less<CIOSocket::CIOTimer>>(
           a1,
           a2,
           v26,
           a4,
           a5,
           a6);
}

//----- (0040D640) --------------------------------------------------------
void *__thiscall std::priority_queue<CIOSocket::CIOTimer>::priority_queue<CIOSocket::CIOTimer,std::vector<CIOSocket::CIOTimer>,std::less<CIOSocket::CIOTimer>>(void *this)
{
  std::vector<CIOSocket::CIOTimer>::vector<CIOSocket::CIOTimer>(this);
  return this;
}

//----- (0040D660) --------------------------------------------------------
_DWORD *__thiscall std::vector<CIOSocket::CIOTimer>::vector<CIOSocket::CIOTimer>(void *this)
{
  void *v2; // [esp-4h] [ebp-Ch] BYREF
  _DWORD *v3; // [esp+0h] [ebp-8h]

  v3 = this;
  v2 = this;
  unknown_libname_9(&v2);
  sub_40D710(v3, (char)v2);
  sub_40D690(v3, 0);
  return v3;
}
// 403F50: using guessed type int __thiscall unknown_libname_9(_DWORD);

//----- (0040D690) --------------------------------------------------------
char __thiscall sub_40D690(_DWORD *this, unsigned int a2)
{
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  if ( !a2 )
    return 0;
  if ( std::priority_queue<CIOSocket::CIOTimer>::empty(this) < a2 )
    std::vector<CIOSocket::CIOTimer>::_Xlen();
  this[1] = std::allocator<CIOSocket::CIOTimer>::allocate(a2);
  this[2] = this[1];
  this[3] = this[1] + 12 * a2;
  return 1;
}

//----- (0040D710) --------------------------------------------------------
void *__thiscall sub_40D710(void *this, char a2)
{
  unknown_libname_19(&a2);
  return this;
}
// 405580: using guessed type _DWORD __stdcall unknown_libname_19(_DWORD);

//----- (0040D730) --------------------------------------------------------
_DWORD *__thiscall sub_40D730(_DWORD *this)
{
  CIOObject::CIOObject((CIOObject *)this);
  *this = &off_42B614;
  return this;
}
// 42B614: using guessed type int (__stdcall *off_42B614)(int);

//----- (0040D750) --------------------------------------------------------
void *__thiscall CServer::`vector deleting destructor'(void *this, char a2)
{
  sub_41B660(this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (0040D7B0) --------------------------------------------------------
int *__thiscall std::priority_queue<CIOSocket::CIOTimer>::~priority_queue<CIOSocket::CIOTimer,std::vector<CIOSocket::CIOTimer>,std::less<CIOSocket::CIOTimer>>(void *this)
{
  return std::vector<CIOSocket::CIOTimer>::~vector<CIOSocket::CIOTimer>(this);
}

//----- (0040D7D0) --------------------------------------------------------
int *__thiscall std::vector<CIOSocket::CIOTimer>::~vector<CIOSocket::CIOTimer>(void *this)
{
  return std::vector<CIOSocket::CIOTimer>::_Tidy((int *)this);
}

//----- (0040D7F0) --------------------------------------------------------
int *__thiscall std::vector<CIOSocket::CIOTimer>::_Tidy(int *this)
{
  int *result; // eax

  if ( this[1] )
  {
    std::vector<CIOSocket::CIOTimer>::_Destroy(this, this[1], this[2]);
    std::allocator<CSyncPacket::CElement>::deallocate(this[1], (this[3] - this[1]) / 12);
  }
  this[1] = 0;
  this[2] = 0;
  result = this;
  this[3] = 0;
  return result;
}

//----- (0040D860) --------------------------------------------------------
_DWORD *__thiscall lisp::var::operator=(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  if ( this != (_DWORD *)&lisp::nil )
  {
    result = this;
    *this = a2;
  }
  return result;
}

//----- (0040D880) --------------------------------------------------------
int __thiscall lisp::_string::GetInteger(lisp::_string *this)
{
  return strtol(this->m_pString, 0, 0);
}

//----- (0040D8A0) --------------------------------------------------------
unsigned int __thiscall lisp::_string::GetUnsigned(lisp::_string *this)
{
  return strtoul(this->m_pString, 0, 0);
}

//----- (0040D8C0) --------------------------------------------------------
int __thiscall lisp::_cons::length(lisp::_cons *this)
{
  int v2; // eax
  int v3; // ecx
  int v4; // [esp-4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-8h]
  lisp::var v6; // [esp+Ch] [ebp-4h] BYREF

  v5 = 0;
  std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(&this->m_cdr);
  while ( 1 )
  {
    ++v5;
    if ( !(unsigned __int8)lisp::var::consp(&v6) )
      break;
    v2 = lisp::var::integerp(&v6);
    v4 = v3;
    std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(v2);
    lisp::var::operator=(&v6, v4);
  }
  return v5;
}
// 40D904: variable 'v3' is possibly undefined
// 401F90: using guessed type _DWORD __stdcall std::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>::_Callable_base<bool (__cdecl *)(enum Concurrency::agent_status const &),0>(_DWORD);

//----- (0040D920) --------------------------------------------------------
_DWORD *__thiscall sub_40D920(_DWORD *this)
{
  sub_4020E0(this);
  *this = off_42B62C;
  return this;
}
// 42B62C: using guessed type int (*off_42B62C[10])();

//----- (0040D940) --------------------------------------------------------
void __thiscall CLog::CInit::~CInit(CLog::CInit *this)
{
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 3; ++i )
  {
    if ( *(&stream + i) )
      fclose(*(&stream + i));
  }
}

//----- (0040D990) --------------------------------------------------------
void __cdecl CLog::AddV(int nType, char *format, char *va)
{
  char v3[36]; // [esp+8h] [ebp-93Ch] BYREF
  char Buffer[260]; // [esp+2Ch] [ebp-918h] BYREF
  __time32_t Time; // [esp+130h] [ebp-814h] BYREF
  struct tm *Tm; // [esp+134h] [ebp-810h]
  size_t ElementCount; // [esp+138h] [ebp-80Ch]
  char Source[1024]; // [esp+13Ch] [ebp-808h] BYREF
  char buffer[1028]; // [esp+53Ch] [ebp-408h] BYREF

  vsprintf(Source, format, va);
  Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(&CScreen::s_pScreen);
  CScreen::AddString((CScreen *)&CScreen::s_pScreen, color[nType], Source);
  if ( nType >= 1 )
  {
    time(&Time);
    Tm = localtime(&Time);
    if ( Time >= g_nNext[nType] )
    {
      if ( *(&stream + nType) )
        fclose(*(&stream + nType));
      if ( nType == 1 )
        sprintf(Buffer, "Log\\%02d%02d%02d.log", Tm->tm_year % 100, Tm->tm_mon + 1, Tm->tm_mday);
      else
        sprintf(Buffer, "Log\\%02d%02d%02d.err.log", Tm->tm_year % 100, Tm->tm_mon + 1, Tm->tm_mday);
      qmemcpy(v3, Tm, sizeof(v3));
      Tm->tm_sec = 0;
      Tm->tm_min = 0;
      Tm->tm_hour = 0;
      g_nNext[nType] = mktime(Tm) + 86400;
      *(&stream + nType) = fopen(Buffer, "ab");
      qmemcpy(Tm, v3, sizeof(struct tm));
    }
    ElementCount = sprintf(
                     buffer,
                     "%02d/%02d/%02d %02d:%02d:%02d %s\r\n",
                     Tm->tm_year % 100,
                     Tm->tm_mon + 1,
                     Tm->tm_mday,
                     Tm->tm_hour,
                     Tm->tm_min,
                     Tm->tm_sec,
                     Source);
    if ( *(&stream + nType) )
      fwrite_0(buffer, 1u, ElementCount, *(&stream + nType));
  }
  Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(&CScreen::s_pScreen);
  if ( stru_4441A4 == (CScreen *)&CScreen::s_pScreen )
    InvalidateRect((HWND)*(&stru_4441A4 + 1), 0, 1);
}
// 40DE00: using guessed type int __thiscall Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(_DWORD);
// 40DE20: using guessed type int __thiscall Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(_DWORD);

//----- (0040DC20) --------------------------------------------------------
void __stdcall CLog::Flush()
{
  unsigned int i; // [esp+0h] [ebp-4h]

  Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(&CScreen::s_pScreen);
  for ( i = 0; i < 3; ++i )
  {
    if ( *(&stream + i) )
      fflush(*(&stream + i));
  }
  Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(&CScreen::s_pScreen);
}
// 40DE00: using guessed type int __thiscall Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(_DWORD);
// 40DE20: using guessed type int __thiscall Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(_DWORD);

//----- (0040DC80) --------------------------------------------------------
void LOG_INFO(char *format, ...)
{
  va_list va; // [esp+10h] [ebp+Ch] BYREF

  va_start(va, format);
  CLog::AddV(0, format, va);
}

//----- (0040DCB0) --------------------------------------------------------
void LOG_NORMAL(char *format, ...)
{
  va_list va; // [esp+10h] [ebp+Ch] BYREF

  va_start(va, format);
  CLog::AddV(1, format, va);
}

//----- (0040DCE0) --------------------------------------------------------
void LOG_ERR(char *format, ...)
{
  va_list va; // [esp+10h] [ebp+Ch] BYREF

  va_start(va, format);
  CLog::AddV(2, format, va);
}

//----- (0040DD10) --------------------------------------------------------
void __cdecl LOG_DB(int nMainType, int nType, int nID1, int nID2, int nIID, int nVal1, int nVal2, int nVal3, int nVal4)
{
  CDB v9; // [esp+0h] [ebp-1Ch] BYREF
  int v10; // [esp+18h] [ebp-4h]

  CDB::CDB(&v9);
  v10 = 0;
  CDB::Execute(
    &v9,
    "INSERT INTO Log VALUES ( GETDATE(), %d, %d, %d, %d, %d, %d, %d, %d, %d)",
    nMainType,
    nType,
    nID1,
    nID2,
    nIID,
    nVal1,
    nVal2,
    nVal3,
    nVal4);
  v10 = -1;
  CDB::~CDB(&v9);
}

//----- (0040DD90) --------------------------------------------------------
void __cdecl LOG_PAY(int nLogType, int nID, int nPayType, int nValue)
{
  CDB v4; // [esp+0h] [ebp-1Ch] BYREF
  int v5; // [esp+18h] [ebp-4h]

  CDB::CDB(&v4);
  v5 = 0;
  CDB::Execute(&v4, "INSERT INTO PayLog VALUES ( GETDATE(), %d, %d, %d, %d)", nLogType, nID, nPayType, nValue);
  v5 = -1;
  CDB::~CDB(&v4);
}

//----- (0040DE40) --------------------------------------------------------
void __thiscall CMemory::CInit::CInit(CMemory::CInit *this)
{
  CMemory *v1; // [esp+0h] [ebp-20h]
  CMemory *Block; // [esp+8h] [ebp-18h]
  int i; // [esp+10h] [ebp-10h]

  for ( i = 0; i < 16; ++i )
  {
    Block = (CMemory *)CNoMemoryObject::operator new(0x38u);
    if ( Block )
      v1 = CMemory::CMemory(Block);
    else
      v1 = 0;
    g_pMemory[i] = v1;
  }
}

//----- (0040DEE0) --------------------------------------------------------
CMemory *__thiscall CMemory::CMemory(CMemory *this)
{
  InitializeCriticalSection(&this->_lock);
  this->__sbh_indGroupDefer = 0;
  CMemory::_heap_init(this);
  return this;
}

//----- (0040DF30) --------------------------------------------------------
int __thiscall CMemory::_heap_init(CMemory *this)
{
  this->_crtheap = HeapCreate(1u, 0x10000u, 0);
  if ( !this->_crtheap )
    return 0;
  if ( CMemory::__sbh_heap_init(this, 0x3F8u) )
    return 1;
  HeapDestroy(this->_crtheap);
  this->_crtheap = 0;
  return 0;
}

//----- (0040DF90) --------------------------------------------------------
void __thiscall CMemory::_heap_term(CMemory *this)
{
  CMemory::tagHeader *v2; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  if ( this->_crtheap )
  {
    v2 = this->__sbh_pHeaderList;
    for ( i = 0; i < this->__sbh_cntHeaderList; ++i )
    {
      VirtualFree(v2->pHeapData, 0x1000000u, 0x4000u);
      VirtualFree(v2->pHeapData, 0, 0x8000u);
      HeapFree(this->_crtheap, 0, v2->pRegion);
      ++v2;
    }
    HeapFree(this->_crtheap, 0, this->__sbh_pHeaderList);
    HeapDestroy(this->_crtheap);
  }
}

//----- (0040E040) --------------------------------------------------------
int __thiscall CMemory::__sbh_heap_init(CMemory *this, unsigned int threshold)
{
  this->__sbh_pHeaderList = (CMemory::tagHeader *)HeapAlloc(this->_crtheap, 0, 0x140u);
  if ( !this->__sbh_pHeaderList )
    return 0;
  this->__sbh_threshold = threshold;
  this->__sbh_pHeaderScan = this->__sbh_pHeaderList;
  this->__sbh_pHeaderDefer = 0;
  this->__sbh_cntHeaderList = 0;
  this->__sbh_sizeHeaderList = 16;
  return 1;
}

//----- (0040E0B0) --------------------------------------------------------
CMemory **__cdecl CMemory::_malloc(size_t Size)
{
  CMemory *v2; // [esp+0h] [ebp-8h]
  CMemory **v3; // [esp+4h] [ebp-4h]

  v2 = g_pMemory[InterlockedIncrement(&dword_444158) & 0xF];
  v3 = (CMemory **)CMemory::_heap_alloc_base(v2, Size + 4);
  if ( v3 )
  {
    *v3++ = v2;
    memset(v3, 252, Size);
  }
  return v3;
}

//----- (0040E120) --------------------------------------------------------
void *__thiscall CMemory::_heap_alloc_base(CMemory *this, unsigned int size)
{
  CMemory::tagEntry **v4; // [esp+4h] [ebp-4h]
  void *v5; // [esp+4h] [ebp-4h]

  if ( size <= this->__sbh_threshold )
  {
    CMemory::_mlock((int)this);
    v4 = CMemory::__sbh_alloc_block(this, size);
    CMemory::_munlock((int)this);
    if ( v4 )
      return v4;
  }
  CMemory::_mlock((int)this);
  v5 = HeapAlloc(this->_crtheap, 0, (size + 15) & 0xFFFFFFF0);
  CMemory::_munlock((int)this);
  return v5;
}

//----- (0040E1A0) --------------------------------------------------------
CMemory::tagEntry **__thiscall CMemory::__sbh_alloc_block(CMemory *this, int intSize)
{
  int v5; // eax
  signed int v7; // [esp+8h] [ebp-38h]
  int v8; // [esp+Ch] [ebp-34h]
  int v9; // [esp+Ch] [ebp-34h]
  unsigned int v10; // [esp+10h] [ebp-30h]
  int v11; // [esp+14h] [ebp-2Ch]
  CMemory::tagRegion *v12; // [esp+18h] [ebp-28h]
  CMemory::tagGroup *v13; // [esp+1Ch] [ebp-24h]
  int *v14; // [esp+20h] [ebp-20h]
  CMemory::tagHeader *pHeader; // [esp+24h] [ebp-1Ch]
  unsigned int v16; // [esp+28h] [ebp-18h]
  int i; // [esp+2Ch] [ebp-14h]
  int v18; // [esp+30h] [ebp-10h]
  CMemory::tagHeader *v19; // [esp+34h] [ebp-Ch]
  int *v20; // [esp+38h] [ebp-8h]
  char *v21; // [esp+38h] [ebp-8h]
  int v22; // [esp+3Ch] [ebp-4h]

  v19 = &this->__sbh_pHeaderList[this->__sbh_cntHeaderList];
  v7 = (intSize + 23) & 0xFFFFFFF0;
  v8 = (v7 >> 4) - 1;
  if ( v8 >= 32 )
  {
    v16 = 0;
    v10 = 0xFFFFFFFF >> ((v7 >> 4) - 33);
  }
  else
  {
    v16 = 0xFFFFFFFF >> v8;
    v10 = -1;
  }
  for ( pHeader = this->__sbh_pHeaderScan;
        pHeader < v19 && !(pHeader->bitvEntryLo & v10 | pHeader->bitvEntryHi & v16);
        ++pHeader )
  {
    ;
  }
  if ( pHeader != v19 )
    goto LABEL_27;
  for ( pHeader = this->__sbh_pHeaderList;
        pHeader < this->__sbh_pHeaderScan && !(pHeader->bitvEntryLo & v10 | pHeader->bitvEntryHi & v16);
        ++pHeader )
  {
    ;
  }
  if ( pHeader != this->__sbh_pHeaderScan )
    goto LABEL_27;
  while ( pHeader < v19 && !pHeader->bitvCommit )
    ++pHeader;
  if ( pHeader == v19 )
  {
    for ( pHeader = this->__sbh_pHeaderList; pHeader < this->__sbh_pHeaderScan && !pHeader->bitvCommit; ++pHeader )
      ;
    if ( pHeader == this->__sbh_pHeaderScan )
    {
      pHeader = CMemory::__sbh_alloc_new_region(this);
      if ( !pHeader )
        return 0;
    }
  }
  pHeader->pRegion->indGroupUse = CMemory::__sbh_alloc_new_group(this, pHeader);
  if ( pHeader->pRegion->indGroupUse == -1 )
    return 0;
LABEL_27:
  this->__sbh_pHeaderScan = pHeader;
  v12 = pHeader->pRegion;
  i = v12->indGroupUse;
  if ( v12->indGroupUse == -1 || !(v12->bitvGroupLo[i] & v10 | v12->bitvGroupHi[i] & v16) )
  {
    for ( i = 0; !(v12->bitvGroupLo[i] & v10 | v12->bitvGroupHi[i] & v16); ++i )
      ;
  }
  v13 = &v12->grpHeadList[i];
  v9 = 0;
  v22 = v12->bitvGroupHi[i] & v16;
  if ( !v22 )
  {
    v9 = 32;
    v22 = v12->bitvGroupLo[i] & v10;
  }
  while ( v22 >= 0 )
  {
    v22 *= 2;
    ++v9;
  }
  v20 = &v13->listHead[v9].pEntryNext->sizeFront;
  v11 = *v20 - v7;
  v18 = (v11 >> 4) - 1;
  if ( v18 > 63 )
    v18 = 63;
  if ( v18 != v9 )
  {
    if ( v20[1] == v20[2] )
    {
      if ( v9 >= 32 )
      {
        v12->bitvGroupLo[i] &= ~(0x80000000 >> (v9 - 32));
        if ( !--v12->cntRegionSize[v9] )
          pHeader->bitvEntryLo &= ~(0x80000000 >> (v9 - 32));
      }
      else
      {
        v12->bitvGroupHi[i] &= ~(0x80000000 >> v9);
        if ( !--v12->cntRegionSize[v9] )
          pHeader->bitvEntryHi &= ~(0x80000000 >> v9);
      }
    }
    *(_DWORD *)(v20[2] + 4) = v20[1];
    *(_DWORD *)(v20[1] + 8) = v20[2];
    if ( v11 )
    {
      v14 = &v13->cntEntries + 2 * v18;
      v20[1] = v14[1];
      v20[2] = (int)v14;
      v14[1] = (int)v20;
      *(_DWORD *)(v20[1] + 8) = v20;
      if ( v20[1] == v20[2] )
      {
        if ( v18 >= 32 )
        {
          if ( !v12->cntRegionSize[v18]++ )
            pHeader->bitvEntryLo |= 0x80000000 >> (v18 - 32);
          v12->bitvGroupLo[i] |= 0x80000000 >> (v18 - 32);
        }
        else
        {
          if ( !v12->cntRegionSize[v18]++ )
            pHeader->bitvEntryHi |= 0x80000000 >> v18;
          v12->bitvGroupHi[i] |= 0x80000000 >> v18;
        }
      }
    }
  }
  if ( v11 )
  {
    *v20 = v11;
    *(int *)((char *)v20 + v11 - 4) = v11;
  }
  v21 = (char *)v20 + v11;
  *(_DWORD *)v21 = v7 + 1;
  *(_DWORD *)&v21[v7 - 4] = v7 + 1;
  v5 = v13->cntEntries++;
  if ( !v5 && pHeader == this->__sbh_pHeaderDefer && i == this->__sbh_indGroupDefer )
    this->__sbh_pHeaderDefer = 0;
  v12->indGroupUse = i;
  return (CMemory::tagEntry **)(v21 + 4);
}

//----- (0040E6D0) --------------------------------------------------------
CMemory::tagHeader *__thiscall CMemory::__sbh_alloc_new_region(CMemory *this)
{
  CMemory::tagHeader *result; // eax
  CMemory::tagHeader *v3; // [esp+4h] [ebp-4h]
  CMemory::tagHeader *v4; // [esp+4h] [ebp-4h]

  if ( this->__sbh_cntHeaderList == this->__sbh_sizeHeaderList )
  {
    v3 = (CMemory::tagHeader *)HeapReAlloc(
                                 this->_crtheap,
                                 0,
                                 this->__sbh_pHeaderList,
                                 20 * (this->__sbh_sizeHeaderList + 16));
    if ( !v3 )
      return 0;
    this->__sbh_pHeaderList = v3;
    this->__sbh_sizeHeaderList += 16;
  }
  v4 = &this->__sbh_pHeaderList[this->__sbh_cntHeaderList];
  v4->pRegion = (CMemory::tagRegion *)HeapAlloc(this->_crtheap, 8u, 0x41C4u);
  if ( !v4->pRegion )
    return 0;
  v4->pHeapData = VirtualAlloc(0, 0x1000000u, 0x2000u, 4u);
  if ( v4->pHeapData )
  {
    v4->bitvEntryHi = 0;
    v4->bitvEntryLo = 0;
    v4->bitvCommit = -1;
    ++this->__sbh_cntHeaderList;
    v4->pRegion->indGroupUse = -1;
    result = v4;
  }
  else
  {
    HeapFree(this->_crtheap, 0, v4->pRegion);
    result = 0;
  }
  return result;
}

//----- (0040E7F0) --------------------------------------------------------
int __thiscall CMemory::__sbh_alloc_new_group(CMemory *this, CMemory::tagHeader *pHeader)
{
  signed int v4; // [esp+4h] [ebp-2Ch]
  int v5; // [esp+8h] [ebp-28h]
  CMemory::tagRegion *v6; // [esp+10h] [ebp-20h]
  int v7; // [esp+14h] [ebp-1Ch]
  int i; // [esp+1Ch] [ebp-14h]
  _DWORD *j; // [esp+20h] [ebp-10h]
  char *lpAddress; // [esp+24h] [ebp-Ch]

  v6 = pHeader->pRegion;
  v4 = pHeader->bitvCommit;
  v5 = 0;
  while ( v4 >= 0 )
  {
    v4 *= 2;
    ++v5;
  }
  v7 = (int)&v6->grpHeadList[v5];
  for ( i = 0; i < 63; ++i )
  {
    *(_DWORD *)(v7 + 8 * i + 8) = v7 + 8 * i;
    *(_DWORD *)(v7 + 8 * i + 4) = v7 + 8 * i;
  }
  lpAddress = (char *)pHeader->pHeapData + 0x80000 * v5;
  if ( !VirtualAlloc(lpAddress, 0x80000u, 0x1000u, 4u) )
    return -1;
  for ( j = lpAddress; j <= (_DWORD *)lpAddress + 114688; j += 0x4000 )
  {
    j[2] = -1;
    j[0x3FFF] = -1;
    j[3] = 65520;
    j[4] = j + 16387;
    j[5] = j - 16381;
    j[16382] = 65520;
  }
  v6->grpHeadList[v5].listHead[63].pEntryNext = (CMemory::tagEntry *)(lpAddress + 12);
  v6->grpHeadList[v5].listHead[63].pEntryNext->pEntryPrev = (CMemory::tagEntry *)&v6->grpHeadList[v5].listHead[62].pEntryPrev;
  v6->grpHeadList[v5].listHead[63].pEntryPrev = (CMemory::tagEntry *)(lpAddress + 458764);
  v6->grpHeadList[v5].listHead[63].pEntryPrev->pEntryNext = (CMemory::tagEntry *)&v6->grpHeadList[v5].listHead[62].pEntryPrev;
  v6->bitvGroupHi[v5] = 0;
  v6->bitvGroupLo[v5] = 1;
  if ( !v6->cntRegionSize[63]++ )
    pHeader->bitvEntryLo |= 1u;
  pHeader->bitvCommit &= ~(0x80000000 >> v5);
  return v5;
}

//----- (0040E9E0) --------------------------------------------------------
void __cdecl CMemory::_free(void *pBlock)
{
  HANDLE *v1; // [esp+0h] [ebp-8h]

  if ( pBlock )
  {
    v1 = (HANDLE *)*((_DWORD *)pBlock - 1);
    *((_DWORD *)pBlock - 1) = 0;
    CMemory::_free_base(v1, (char *)pBlock - 4);
  }
}

//----- (0040EA20) --------------------------------------------------------
void __thiscall CMemory::_free_base(HANDLE *this, LPCVOID lpMem)
{
  SIZE_T v3; // [esp+4h] [ebp-Ch]
  CMemory::tagHeader *pHeader; // [esp+Ch] [ebp-4h]

  CMemory::_mlock((int)this);
  pHeader = CMemory::__sbh_find_block((CMemory *)this, (void *)lpMem);
  if ( pHeader )
  {
    memset((void *)lpMem, 253, *((_DWORD *)lpMem - 1) - 9);
    CMemory::__sbh_free_block((CMemory *)this, pHeader, (void *)lpMem);
  }
  else
  {
    v3 = HeapSize(*this, 0, lpMem);
    memset((void *)lpMem, 253, v3);
    HeapFree(*this, 0, (LPVOID)lpMem);
  }
  CMemory::_munlock((int)this);
}

//----- (0040EAD0) --------------------------------------------------------
CMemory::tagHeader *__thiscall CMemory::__sbh_find_block(CMemory *this, void *pvAlloc)
{
  CMemory::tagHeader *i; // [esp+8h] [ebp-8h]

  for ( i = this->__sbh_pHeaderList; i < &this->__sbh_pHeaderList[this->__sbh_cntHeaderList]; ++i )
  {
    if ( (unsigned int)pvAlloc - (unsigned int)i->pHeapData < 0x1000000 )
      return i;
  }
  return 0;
}

//----- (0040EB30) --------------------------------------------------------
void __thiscall CMemory::__sbh_free_block(CMemory *this, CMemory::tagHeader *pHeader, void *pvAlloc)
{
  int v6; // [esp+8h] [ebp-3Ch]
  unsigned int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  unsigned int v9; // [esp+14h] [ebp-30h]
  CMemory::tagRegion *v10; // [esp+18h] [ebp-2Ch]
  CMemory::tagGroup *v11; // [esp+1Ch] [ebp-28h]
  int *v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+28h] [ebp-1Ch]
  int *v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  unsigned int v16; // [esp+34h] [ebp-10h]
  char *v17; // [esp+38h] [ebp-Ch]
  char *v18; // [esp+3Ch] [ebp-8h]

  v10 = pHeader->pRegion;
  v15 = ((unsigned int)pvAlloc - (unsigned int)pHeader->pHeapData) >> 19;
  v11 = &v10->grpHeadList[v15];
  v14 = (int *)((char *)pvAlloc - 4);
  v6 = *((_DWORD *)pvAlloc - 1) - 1;
  if ( (v6 & 1) == 0 )
  {
    v18 = (char *)v14 + v6;
    v8 = *(int *)((char *)v14 + v6);
    v13 = *((_DWORD *)pvAlloc - 2);
    if ( (v8 & 1) == 0 )
    {
      v16 = (v8 >> 4) - 1;
      if ( v16 > 0x3F )
        v16 = 63;
      if ( *((_DWORD *)v18 + 1) == *((_DWORD *)v18 + 2) )
      {
        if ( v16 >= 0x20 )
        {
          v10->bitvGroupLo[v15] &= ~(0x80000000 >> (v16 - 32));
          if ( !--v10->cntRegionSize[v16] )
            pHeader->bitvEntryLo &= ~(0x80000000 >> (v16 - 32));
        }
        else
        {
          v10->bitvGroupHi[v15] &= ~(0x80000000 >> v16);
          if ( !--v10->cntRegionSize[v16] )
            pHeader->bitvEntryHi &= ~(0x80000000 >> v16);
        }
      }
      *(_DWORD *)(*((_DWORD *)v18 + 2) + 4) = *((_DWORD *)v18 + 1);
      *(_DWORD *)(*((_DWORD *)v18 + 1) + 8) = *((_DWORD *)v18 + 2);
      v6 += v8;
    }
    v7 = (v6 >> 4) - 1;
    if ( v7 > 0x3F )
      v7 = 63;
    if ( (v13 & 1) == 0 )
    {
      v17 = (char *)v14 - v13;
      v9 = (v13 >> 4) - 1;
      if ( v9 > 0x3F )
        v9 = 63;
      v6 += v13;
      v7 = (v6 >> 4) - 1;
      if ( v7 > 0x3F )
        v7 = 63;
      if ( v9 != v7 )
      {
        if ( *((_DWORD *)v17 + 1) == *((_DWORD *)v17 + 2) )
        {
          if ( v9 >= 0x20 )
          {
            v10->bitvGroupLo[v15] &= ~(0x80000000 >> (v9 - 32));
            if ( !--v10->cntRegionSize[v9] )
              pHeader->bitvEntryLo &= ~(0x80000000 >> (v9 - 32));
          }
          else
          {
            v10->bitvGroupHi[v15] &= ~(0x80000000 >> v9);
            if ( !--v10->cntRegionSize[v9] )
              pHeader->bitvEntryHi &= ~(0x80000000 >> v9);
          }
        }
        *(_DWORD *)(*((_DWORD *)v17 + 2) + 4) = *((_DWORD *)v17 + 1);
        *(_DWORD *)(*((_DWORD *)v17 + 1) + 8) = *((_DWORD *)v17 + 2);
      }
      v14 = (int *)((char *)v14 - v13);
    }
    if ( (v13 & 1) != 0 || v9 != v7 )
    {
      v12 = &v11->cntEntries + 2 * v7;
      v14[1] = v12[1];
      v14[2] = (int)v12;
      v12[1] = (int)v14;
      *(_DWORD *)(v14[1] + 8) = v14;
      if ( v14[1] == v14[2] )
      {
        if ( v7 >= 0x20 )
        {
          if ( !v10->cntRegionSize[v7]++ )
            pHeader->bitvEntryLo |= 0x80000000 >> (v7 - 32);
          v10->bitvGroupLo[v15] |= 0x80000000 >> (v7 - 32);
        }
        else
        {
          if ( !v10->cntRegionSize[v7]++ )
            pHeader->bitvEntryHi |= 0x80000000 >> v7;
          v10->bitvGroupHi[v15] |= 0x80000000 >> v7;
        }
      }
    }
    *v14 = v6;
    *(int *)((char *)v14 + v6 - 4) = v6;
    if ( !--v11->cntEntries )
    {
      if ( this->__sbh_pHeaderDefer )
      {
        VirtualFree(
          (char *)this->__sbh_pHeaderDefer->pHeapData + 0x80000 * this->__sbh_indGroupDefer,
          0x80000u,
          0x4000u);
        this->__sbh_pHeaderDefer->bitvCommit |= 0x80000000 >> this->__sbh_indGroupDefer;
        this->__sbh_pHeaderDefer->pRegion->bitvGroupLo[this->__sbh_indGroupDefer] = 0;
        if ( !--this->__sbh_pHeaderDefer->pRegion->cntRegionSize[63] )
          this->__sbh_pHeaderDefer->bitvEntryLo &= 0xFFFFFFFE;
        if ( this->__sbh_pHeaderDefer->bitvCommit == -1 )
        {
          VirtualFree(this->__sbh_pHeaderDefer->pHeapData, 0, 0x8000u);
          HeapFree(this->_crtheap, 0, this->__sbh_pHeaderDefer->pRegion);
          memcpy_0(
            this->__sbh_pHeaderDefer,
            &this->__sbh_pHeaderDefer[1],
            (char *)&this->__sbh_pHeaderList[this->__sbh_cntHeaderList] - (char *)&this->__sbh_pHeaderDefer[1]);
          --this->__sbh_cntHeaderList;
          if ( pHeader > this->__sbh_pHeaderDefer )
            --pHeader;
          this->__sbh_pHeaderScan = this->__sbh_pHeaderList;
        }
      }
      this->__sbh_pHeaderDefer = pHeader;
      this->__sbh_indGroupDefer = v15;
    }
  }
}
// 40EE4D: variable 'v9' is possibly undefined

//----- (0040F160) --------------------------------------------------------
void *__thiscall CMemory::_calloc_base(CMemory *this, unsigned int size)
{
  void *result; // eax
  unsigned int Size; // [esp+4h] [ebp-8h]
  void *v5; // [esp+8h] [ebp-4h]

  Size = size;
  if ( size <= 0xFFFFFFE0 )
  {
    if ( !size )
      size = 1;
    size = (size + 15) & 0xFFFFFFF0;
  }
  v5 = 0;
  if ( size <= 0xFFFFFFE0 )
  {
    if ( Size <= this->__sbh_threshold )
    {
      CMemory::_mlock((int)this);
      v5 = CMemory::__sbh_alloc_block(this, Size);
      CMemory::_munlock((int)this);
      if ( v5 )
        memset(v5, 0, Size);
    }
    if ( !v5 )
      v5 = HeapAlloc(this->_crtheap, 8u, size);
  }
  if ( v5 )
    result = v5;
  else
    result = 0;
  return result;
}

//----- (0040F210) --------------------------------------------------------
CMemory **__cdecl CMemory::_realloc(void *pBlock, unsigned int newsize)
{
  CMemory **result; // eax
  CMemory *v3; // [esp+0h] [ebp-8h]
  CMemory **lpMem; // [esp+4h] [ebp-4h]

  if ( !pBlock )
    return CMemory::_malloc(newsize);
  if ( newsize )
  {
    v3 = (CMemory *)*((_DWORD *)pBlock - 1);
    *((_DWORD *)pBlock - 1) = 0;
    lpMem = (CMemory **)CMemory::_realloc_base(v3, (char *)pBlock - 4, newsize + 4);
    if ( lpMem )
      *lpMem++ = v3;
    result = lpMem;
  }
  else
  {
    CMemory::_free(pBlock);
    result = 0;
  }
  return result;
}

//----- (0040F2A0) --------------------------------------------------------
void *__thiscall CMemory::_realloc_base(CMemory *this, void *pBlock, unsigned int newsize)
{
  void *result; // eax
  unsigned int v4; // [esp+0h] [ebp-18h]
  unsigned int Size; // [esp+4h] [ebp-14h]
  CMemory::tagHeader *pHeader; // [esp+Ch] [ebp-Ch]
  void *v8; // [esp+14h] [ebp-4h]

  v8 = 0;
  if ( newsize <= 0xFFFFFFE0 )
  {
    CMemory::_mlock((int)this);
    pHeader = CMemory::__sbh_find_block(this, pBlock);
    if ( pHeader )
    {
      if ( newsize <= this->__sbh_threshold )
      {
        if ( CMemory::__sbh_resize_block(this, pHeader, pBlock, newsize) )
        {
          v8 = pBlock;
        }
        else
        {
          v8 = CMemory::__sbh_alloc_block(this, newsize);
          if ( v8 )
          {
            if ( *((_DWORD *)pBlock - 1) - 9 >= newsize )
              Size = newsize;
            else
              Size = *((_DWORD *)pBlock - 1) - 9;
            memcpy(v8, pBlock, Size);
            pHeader = CMemory::__sbh_find_block(this, pBlock);
            CMemory::__sbh_free_block(this, pHeader, pBlock);
          }
        }
      }
      if ( !v8 )
      {
        if ( !newsize )
          newsize = 1;
        newsize = (newsize + 15) & 0xFFFFFFF0;
        v8 = HeapAlloc(this->_crtheap, 0, newsize);
        if ( v8 )
        {
          if ( *((_DWORD *)pBlock - 1) - 9 >= newsize )
            v4 = newsize;
          else
            v4 = *((_DWORD *)pBlock - 1) - 9;
          memcpy(v8, pBlock, v4);
          CMemory::__sbh_free_block(this, pHeader, pBlock);
        }
      }
    }
    CMemory::_munlock((int)this);
    if ( !pHeader )
    {
      if ( !newsize )
        newsize = 1;
      v8 = HeapReAlloc(this->_crtheap, 0, pBlock, (newsize + 15) & 0xFFFFFFF0);
    }
  }
  if ( v8 )
    result = v8;
  else
    result = 0;
  return result;
}

//----- (0040F450) --------------------------------------------------------
int __thiscall CMemory::__sbh_resize_block(CMemory *this, CMemory::tagHeader *pHeader, void *pvAlloc, int intNew)
{
  int v9; // [esp+4h] [ebp-30h]
  int v10; // [esp+4h] [ebp-30h]
  unsigned int v11; // [esp+8h] [ebp-2Ch]
  int v12; // [esp+Ch] [ebp-28h]
  int v13; // [esp+Ch] [ebp-28h]
  CMemory::tagRegion *v14; // [esp+10h] [ebp-24h]
  int v15; // [esp+14h] [ebp-20h]
  signed int v16; // [esp+18h] [ebp-1Ch]
  unsigned int v17; // [esp+1Ch] [ebp-18h]
  unsigned int v18; // [esp+1Ch] [ebp-18h]
  _DWORD *v19; // [esp+24h] [ebp-10h]
  int *v20; // [esp+24h] [ebp-10h]
  unsigned int v21; // [esp+28h] [ebp-Ch]
  unsigned int v22; // [esp+2Ch] [ebp-8h]
  unsigned int v23; // [esp+2Ch] [ebp-8h]
  unsigned int v24; // [esp+2Ch] [ebp-8h]
  int *v25; // [esp+30h] [ebp-4h]
  int *v26; // [esp+30h] [ebp-4h]

  v16 = (intNew + 23) & 0xFFFFFFF0;
  v14 = pHeader->pRegion;
  v21 = ((unsigned int)pvAlloc - (unsigned int)pHeader->pHeapData) >> 19;
  v15 = (int)&v14->grpHeadList[v21];
  v19 = (char *)pvAlloc - 4;
  v9 = *((_DWORD *)pvAlloc - 1) - 1;
  v25 = (int *)((char *)pvAlloc + v9 - 4);
  v12 = *v25;
  if ( v16 <= v9 )
  {
    if ( v16 < v9 )
    {
      *v19 = v16 + 1;
      *(_DWORD *)((char *)v19 + v16 - 4) = v16 + 1;
      v20 = (_DWORD *)((char *)v19 + v16);
      v10 = v9 - v16;
      v11 = (v10 >> 4) - 1;
      if ( v11 > 0x3F )
        v11 = 63;
      if ( (v12 & 1) == 0 )
      {
        v24 = (v12 >> 4) - 1;
        if ( v24 > 0x3F )
          v24 = 63;
        if ( v25[1] == v25[2] )
        {
          if ( v24 >= 0x20 )
          {
            v14->bitvGroupLo[v21] &= ~(0x80000000 >> (v24 - 32));
            if ( !--v14->cntRegionSize[v24] )
              pHeader->bitvEntryLo &= ~(0x80000000 >> (v24 - 32));
          }
          else
          {
            v14->bitvGroupHi[v21] &= ~(0x80000000 >> v24);
            if ( !--v14->cntRegionSize[v24] )
              pHeader->bitvEntryHi &= ~(0x80000000 >> v24);
          }
        }
        *(_DWORD *)(v25[2] + 4) = v25[1];
        *(_DWORD *)(v25[1] + 8) = v25[2];
        v10 += v12;
        v11 = (v10 >> 4) - 1;
        if ( v11 > 0x3F )
          v11 = 63;
      }
      v18 = v15 + 8 * v11;
      v20[1] = *(_DWORD *)(v18 + 4);
      v20[2] = v18;
      *(_DWORD *)(v18 + 4) = v20;
      *(_DWORD *)(v20[1] + 8) = v20;
      if ( v20[1] == v20[2] )
      {
        if ( v11 >= 0x20 )
        {
          if ( !v14->cntRegionSize[v11]++ )
            pHeader->bitvEntryLo |= 0x80000000 >> (v11 - 32);
          v14->bitvGroupLo[v21] |= 0x80000000 >> (v11 - 32);
        }
        else
        {
          if ( !v14->cntRegionSize[v11]++ )
            pHeader->bitvEntryHi |= 0x80000000 >> v11;
          v14->bitvGroupHi[v21] |= 0x80000000 >> v11;
        }
      }
      *v20 = v10;
      *(int *)((char *)v20 + v10 - 4) = v10;
    }
  }
  else
  {
    if ( (v12 & 1) != 0 || v16 > v12 + v9 )
      return 0;
    v22 = (v12 >> 4) - 1;
    if ( v22 > 0x3F )
      v22 = 63;
    if ( *(_DWORD *)((char *)pvAlloc + v9) == *(_DWORD *)((char *)pvAlloc + v9 + 4) )
    {
      if ( v22 >= 0x20 )
      {
        v14->bitvGroupLo[v21] &= ~(0x80000000 >> (v22 - 32));
        if ( !--v14->cntRegionSize[v22] )
          pHeader->bitvEntryLo &= ~(0x80000000 >> (v22 - 32));
      }
      else
      {
        v14->bitvGroupHi[v21] &= ~(0x80000000 >> v22);
        if ( !--v14->cntRegionSize[v22] )
          pHeader->bitvEntryHi &= ~(0x80000000 >> v22);
      }
    }
    *(_DWORD *)(*(_DWORD *)((char *)pvAlloc + v9 + 4) + 4) = *(_DWORD *)((char *)pvAlloc + v9);
    *(_DWORD *)(*(_DWORD *)((char *)pvAlloc + v9) + 8) = *(_DWORD *)((char *)pvAlloc + v9 + 4);
    v13 = v12 + v9 - v16;
    if ( v13 > 0 )
    {
      v26 = (_DWORD *)((char *)v19 + v16);
      v23 = (v13 >> 4) - 1;
      if ( v23 > 0x3F )
        v23 = 63;
      v17 = v15 + 8 * v23;
      v26[1] = *(_DWORD *)(v17 + 4);
      v26[2] = v17;
      *(_DWORD *)(v17 + 4) = v26;
      *(_DWORD *)(v26[1] + 8) = v26;
      if ( v26[1] == v26[2] )
      {
        if ( v23 >= 0x20 )
        {
          if ( !v14->cntRegionSize[v23]++ )
            pHeader->bitvEntryLo |= 0x80000000 >> (v23 - 32);
          v14->bitvGroupLo[v21] |= 0x80000000 >> (v23 - 32);
        }
        else
        {
          if ( !v14->cntRegionSize[v23]++ )
            pHeader->bitvEntryHi |= 0x80000000 >> v23;
          v14->bitvGroupHi[v21] |= 0x80000000 >> v23;
        }
      }
      *v26 = v13;
      *(int *)((char *)v26 + v13 - 4) = v13;
    }
    *v19 = v16 + 1;
    *(_DWORD *)((char *)v19 + v16 - 4) = v16 + 1;
  }
  return 1;
}

//----- (0040FA80) --------------------------------------------------------
void *__thiscall CMemory::_expand_base(CMemory *this, void *pBlock, unsigned int newsize)
{
  CMemory::tagHeader *pHeader; // [esp+4h] [ebp-8h]
  void *v6; // [esp+8h] [ebp-4h]

  if ( newsize > 0xFFFFFFE0 )
    return 0;
  CMemory::_mlock((int)this);
  pHeader = CMemory::__sbh_find_block(this, pBlock);
  if ( pHeader )
  {
    v6 = 0;
    if ( newsize <= this->__sbh_threshold )
    {
      if ( CMemory::__sbh_resize_block(this, pHeader, pBlock, newsize) )
        v6 = pBlock;
    }
  }
  CMemory::_munlock((int)this);
  if ( !pHeader )
  {
    if ( !newsize )
      newsize = 1;
    v6 = HeapReAlloc(this->_crtheap, 0x10u, pBlock, (newsize + 15) & 0xFFFFFFF0);
  }
  return v6;
}
// 40FB23: variable 'v6' is possibly undefined

//----- (0040FB70) --------------------------------------------------------
unsigned int __thiscall CMemory::_msize_base(CMemory *this, void *pblock)
{
  CMemory::tagHeader *v4; // [esp+4h] [ebp-8h]
  unsigned int v5; // [esp+8h] [ebp-4h]

  CMemory::_mlock((int)this);
  v4 = CMemory::__sbh_find_block(this, pblock);
  if ( v4 )
    v5 = *((_DWORD *)pblock - 1) - 9;
  CMemory::_munlock((int)this);
  if ( !v4 )
    v5 = HeapSize(this->_crtheap, 0, pblock);
  return v5;
}
// 40FBC5: variable 'v5' is possibly undefined

//----- (0040FBD0) --------------------------------------------------------
void *__cdecl CNoMemoryObject::operator new(size_t Size)
{
  return malloc(Size);
}

//----- (0040FBF0) --------------------------------------------------------
void __cdecl CNoMemoryObject::operator delete(void *Block)
{
  free(Block);
}

//----- (0040FC10) --------------------------------------------------------
void __thiscall CMemory::_mlock(int this)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 32));
}

//----- (0040FC30) --------------------------------------------------------
void __thiscall CMemory::_munlock(int this)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 32));
}

//----- (0040FCF0) --------------------------------------------------------
void __thiscall CRWLock::Wait(CRWLock *this)
{
  int v2; // [esp+4h] [ebp-4h]
  int v3; // [esp+4h] [ebp-4h]

  v2 = 4000;
  while ( --v2 >= 0 )
  {
    if ( !InterlockedCompareExchange(&this->m_nLock, 1, 0) )
      return;
    _mm_pause();
  }
  v3 = 4000;
  while ( --v3 >= 0 )
  {
    SwitchToThread();
    if ( !InterlockedCompareExchange(&this->m_nLock, 1, 0) )
      return;
  }
  do
    Sleep(0x3E8u);
  while ( InterlockedCompareExchange(&this->m_nLock, 1, 0) );
}

//----- (00410140) --------------------------------------------------------
void __thiscall sub_410140(volatile LONG *this)
{
  if ( InterlockedCompareExchange(this + 1, 1, 0) )
    CRWLock::Wait((CRWLock *)this);
}

//----- (00410170) --------------------------------------------------------
LONG __thiscall sub_410170(volatile LONG *this)
{
  return InterlockedExchange(this + 1, 0);
}

//----- (00410190) --------------------------------------------------------
char *__thiscall sub_410190(char *this)
{
  CIOCriticalSection::CIOCriticalSection((struct _RTL_CRITICAL_SECTION *)(this + 20));
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 3) = 0;
  *(_DWORD *)this = 0;
  return this;
}

//----- (004101E0) --------------------------------------------------------
void __thiscall sub_4101E0(char *this)
{
  operator delete(*(_DWORD *)this);
  CIOCriticalSection::~CIOCriticalSection((CIOCriticalSection *)(this + 20));
}
// 42036F: using guessed type _DWORD __cdecl operator delete(_DWORD);

//----- (00410210) --------------------------------------------------------
void __thiscall CScreen::Open(CScreen *this, int nWidth, int nHeight)
{
  this->m_nWidth = nWidth;
  this->m_nHeight = nHeight;
  this->m_nPitch = (nWidth + 8) & 0xFFFFFFFC;
  this->m_nLine = 0;
  this->m_pBuffer = (char *)operator new(nHeight * this->m_nPitch);
  memset(this->m_pBuffer, 0, nHeight * this->m_nPitch);
}

//----- (00410290) --------------------------------------------------------
void CScreen::Add(CScreen *this, unsigned int color, const char *format, ...)
{
  int v3; // [esp+4h] [ebp-8h]
  char *Buffer; // [esp+8h] [ebp-4h]
  va_list va; // [esp+20h] [ebp+14h] BYREF

  va_start(va, format);
  if ( this->m_nLine == this->m_nHeight )
  {
    v3 = this->m_nLine - 1;
    memcpy_0(this->m_pBuffer, &this->m_pBuffer[this->m_nPitch], this->m_nPitch * v3);
  }
  else
  {
    v3 = this->m_nLine;
    this->m_nLine = v3 + 1;
  }
  Buffer = &this->m_pBuffer[this->m_nPitch * v3];
  *(_DWORD *)Buffer = color;
  _vsnprintf(Buffer + 4, this->m_nWidth, format, va);
}

//----- (00410340) --------------------------------------------------------
void __thiscall CScreen::AddString(CScreen *this, unsigned int color, const char *string)
{
  int v4; // [esp+4h] [ebp-8h]
  char *Destination; // [esp+8h] [ebp-4h]

  if ( this->m_nLine == this->m_nHeight )
  {
    v4 = this->m_nLine - 1;
    memcpy_0(this->m_pBuffer, &this->m_pBuffer[this->m_nPitch], this->m_nPitch * v4);
  }
  else
  {
    v4 = this->m_nLine;
    this->m_nLine = v4 + 1;
  }
  Destination = &this->m_pBuffer[this->m_nPitch * v4];
  *(_DWORD *)Destination = color;
  strncpy(Destination + 4, string, this->m_nWidth);
}

//----- (00410410) --------------------------------------------------------
void __thiscall CScreen::OnPaint(CScreen *this)
{
  int v1; // eax
  HDC hdc; // [esp+4h] [ebp-9Ch]
  struct tagPAINTSTRUCT Paint; // [esp+8h] [ebp-98h] BYREF
  struct tagRECT Rect; // [esp+4Ch] [ebp-54h] BYREF
  int y; // [esp+5Ch] [ebp-44h]
  struct tagTEXTMETRICA tm; // [esp+60h] [ebp-40h] BYREF
  char *v8; // [esp+98h] [ebp-8h]
  int v9; // [esp+9Ch] [ebp-4h]

  hdc = BeginPaint((HWND)*(&stru_4441A4 + 1), &Paint);
  Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(this);
  GetTextMetricsA(hdc, &tm);
  GetClientRect((HWND)*(&stru_4441A4 + 1), &Rect);
  y = 0;
  v9 = Rect.bottom / tm.tmHeight;
  if ( this->m_nLine <= Rect.bottom / tm.tmHeight )
  {
    v8 = this->m_pBuffer;
    v9 = this->m_nLine;
  }
  else
  {
    v8 = &this->m_pBuffer[this->m_nPitch * (this->m_nLine - v9)];
  }
  while ( --v9 >= 0 )
  {
    SetTextColor(hdc, *(_DWORD *)v8);
    v1 = strlen(v8 + 4);
    TextOutA(hdc, 0, y, v8 + 4, v1);
    v8 += this->m_nPitch;
    y += tm.tmHeight;
  }
  Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(this);
  EndPaint((HWND)*(&stru_4441A4 + 1), &Paint);
}
// 40DE00: using guessed type int __thiscall Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(_DWORD);
// 40DE20: using guessed type int __thiscall Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(_DWORD);

//----- (00410560) --------------------------------------------------------
void sub_410560()
{
  CIOServer::Start((CIOServer *)(&stru_4441A4 + 7), *(int *)&nPort);
  CLink::Initialize((CLink *)(&stru_4441A4 + 3));
}

//----- (00410580) --------------------------------------------------------
CIOSocket *__thiscall CServer::CreateSocket(CServer *this, unsigned int newSocket, sockaddr_in *addr)
{
  CSocket *v4; // [esp+0h] [ebp-1Ch]
  CMemory **v5; // [esp+8h] [ebp-14h]

  v5 = operator new(0x78u);
  if ( v5 )
    v4 = CSocket::CSocket((CSocket *)v5, newSocket, addr->sin_addr.S_un.S_addr);
  else
    v4 = 0;
  return v4;
}

//----- (00410600) --------------------------------------------------------
LONG __cdecl CServer::Add(int a1)
{
  CIOSpinLock::Enter((volatile LONG *)&stru_4441A4 + 6);
  CLink::Insert((CLink *)(a1 + 108), (CLink *)(&stru_4441A4 + 3));
  *(&stru_4441A4 + 2) = (CScreen *)((char *)*(&stru_4441A4 + 2) + 1);
  return CIOSpinLock::Leave((volatile LONG *)&stru_4441A4 + 6);
}

//----- (00410640) --------------------------------------------------------
LONG __cdecl CServer::Remove(int a1)
{
  CIOSpinLock::Enter((volatile LONG *)&stru_4441A4 + 6);
  CLink::Remove((CLink *)(a1 + 108));
  *(&stru_4441A4 + 2) = (CScreen *)((char *)*(&stru_4441A4 + 2) - 1);
  return CIOSpinLock::Leave((volatile LONG *)&stru_4441A4 + 6);
}

//----- (00410680) --------------------------------------------------------
int CServer::Size()
{
  return (int)*(&stru_4441A4 + 2);
}

//----- (00410690) --------------------------------------------------------
int CServer::Stop()
{
  return sub_40C1D0(&stru_4441A4 + 7);
}

//----- (004106A0) --------------------------------------------------------
void __stdcall CServer::Shutdown()
{
  int v0; // [esp+4h] [ebp-4h]

  while ( 1 )
  {
    CIOSpinLock::Enter((volatile LONG *)&stru_4441A4 + 6);
    v0 = (int)*(&stru_4441A4 + 3);
    if ( *(&stru_4441A4 + 3) == (CScreen *)(&stru_4441A4 + 3) )
      break;
    CIOObject::AddRef((volatile LONG *)&(*(&stru_4441A4 + 3))[-3].m_lock.m_dwEIP[1]);
    CIOSpinLock::Leave((volatile LONG *)&stru_4441A4 + 6);
    CIOSocket::Close((char *)(v0 - 108));
    CIOObject::Release((volatile LONG *)(v0 - 108));
  }
  CIOSpinLock::Leave((volatile LONG *)&stru_4441A4 + 6);
}

//----- (00410700) --------------------------------------------------------
int __cdecl CServer::PendingWrite()
{
  Concurrency::details::UMSFreeVirtualProcessorRoot *v1; // [esp+0h] [ebp-Ch]
  struct Concurrency::details::UMSThreadProxy *v2; // [esp+4h] [ebp-8h]
  CScreen **v3; // [esp+8h] [ebp-4h]

  v2 = 0;
  CIOSpinLock::Enter((volatile LONG *)&stru_4441A4 + 6);
  v3 = (CScreen **)*(&stru_4441A4 + 3);
  while ( v3 != &stru_4441A4 + 3 )
  {
    v1 = (Concurrency::details::UMSFreeVirtualProcessorRoot *)(v3 - 27);
    v3 = (CScreen **)*v3;
    v2 = Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy(v1);
  }
  CIOSpinLock::Leave((volatile LONG *)&stru_4441A4 + 6);
  return (int)v2;
}

//----- (00410760) --------------------------------------------------------
void __thiscall CLink::Initialize(CLink *this)
{
  this->m_pNext = this;
  this->m_pPrev = this;
}

//----- (00410780) --------------------------------------------------------
void __thiscall CLink::Insert(CLink *this, CLink *pLink)
{
  this->m_pPrev = pLink->m_pPrev;
  this->m_pNext = pLink;
  pLink->m_pPrev->m_pNext = this;
  pLink->m_pPrev = this;
}

//----- (004107C0) --------------------------------------------------------
void __thiscall CLink::Remove(CLink *this)
{
  this->m_pNext->m_pPrev = this->m_pPrev;
  this->m_pPrev->m_pNext = this->m_pNext;
}

//----- (00410810) --------------------------------------------------------
_DWORD *__thiscall sub_410810(_DWORD *this)
{
  sub_40BF80(this);
  *this = &off_42B738;
  return this;
}
// 42B738: using guessed type int (__stdcall *off_42B738)(int);

//----- (00410830) --------------------------------------------------------
void *__thiscall CSocket::`vector deleting destructor'(void *this, char a2)
{
  sub_410860(this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (00410860) --------------------------------------------------------
void __thiscall sub_410860(_DWORD *this)
{
  CIOServer::~CIOServer((CIOServer *)this);
}

//----- (00410880) --------------------------------------------------------
LONG __thiscall sub_410880(int this, int a2, int a3, int a4)
{
  CSocket::Process(*(CSocket **)(this + 16), (DBPACKET *)a3);
  CIOObject::Release(*(volatile LONG **)(this + 16));
  CIOBuffer::Release(*(CIOBuffer **)(this + 20));
  sub_41B4B0(this);
  return InterlockedDecrement((volatile LONG *)&stru_4441A4 + 5);
}

//----- (004108D0) --------------------------------------------------------
void __thiscall CSyncPacket::OnIOCallback(CSyncPacket *this, int bSuccess, unsigned int dwTransferred, _OVERLAPPED *lpOverlapped)
{
  int v4; // eax
  int nSize; // [esp+0h] [ebp-1Ch]
  CSocket *v7; // [esp+8h] [ebp-14h]
  CIOBuffer *v8; // [esp+Ch] [ebp-10h]
  DBPACKET *dbpacket; // [esp+10h] [ebp-Ch]
  int v10; // [esp+14h] [ebp-8h]

  if ( dwTransferred )
    EBREAK();
  if ( lpOverlapped )
    EBREAK();
  do
  {
    CIOCriticalSection::Enter((CIOCriticalSection *)((char *)this + 40));
    if ( !std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::operator!=((int)this + 36) )
      EBREAK();
    v4 = CSyncPacket::Front((char *)this);
    v7 = *(CSocket **)v4;
    v8 = *(CIOBuffer **)(v4 + 4);
    dbpacket = *(DBPACKET **)(v4 + 8);
    v10 = *(_DWORD *)(v4 + 12);
    CSyncPacket::Pop(this);
    CIOCriticalSection::Leave((CIOCriticalSection *)((char *)this + 40));
    if ( dbpacket && (this - (CSyncPacket *)&g_syncPacket) / 76 == (unsigned __int8)dbpacket->data[0] )
    {
      CSocket::Process(v7, dbpacket);
      CIOObject::Release((volatile LONG *)v7);
      CIOBuffer::Release(v8);
    }
    else
    {
      ELOG(
        "Invalid Sync Packet m_front(%p) m_back(%p) m_nSize(%d) m_packet(%p) data(%02x%02x%02x%02x) m_pBuf(%p) m_pSocket("
        "%p) m_nRef(%d) m_dwSize(%d)\n",
        *((const void **)this + 8),
        *((const void **)this + 9),
        *((_DWORD *)this + 18),
        dbpacket,
        (unsigned __int8)v10,
        BYTE1(v10),
        BYTE2(v10),
        HIBYTE(v10),
        v8,
        v7,
        v8->m_nRef,
        v8->m_dwSize);
      LogPacket(dbpacket->byType, dbpacket->wSize, dbpacket->data);
      if ( (char *)dbpacket - (char *)v8 >= 1024 )
        nSize = 1024;
      else
        nSize = (char *)dbpacket - (char *)v8;
      LogPacket(-1, nSize, v8->m_buffer);
      EBREAK();
    }
    InterlockedDecrement((volatile LONG *)&stru_4441A4 + 5);
  }
  while ( InterlockedDecrement((volatile LONG *)this + 18) );
}

//----- (00410A80) --------------------------------------------------------
CSocket *__thiscall CSocket::CSocket(CSocket *this, int a2, int a3)
{
  CIOSocket::CIOSocket(this, a2);
  this->__vftable = (CSocket_vtbl *)&off_42F84C;
  this->m_addr.S_un.S_addr = a3;
  return this;
}
// 42F84C: using guessed type int (__stdcall *off_42F84C)(int);

//----- (00410AB0) --------------------------------------------------------
void __thiscall sub_410AB0(_DWORD *this)
{
  *this = &off_42F84C;
  CIOSocket::~CIOSocket((CIOSocket *)this);
}
// 42F84C: using guessed type int (__stdcall *off_42F84C)(int);

//----- (00410AD0) --------------------------------------------------------
void __thiscall CSocket::OnCreate(CSocket *this)
{
  char *v1; // eax
  int v2; // eax
  ULONG v3; // esi
  int v4; // eax
  char *v5; // eax
  char v7[4]; // [esp+8h] [ebp-30h] BYREF
  char v8[4]; // [esp+Ch] [ebp-2Ch] BYREF
  char v9[4]; // [esp+10h] [ebp-28h] BYREF
  CDB v10; // [esp+14h] [ebp-24h] BYREF
  char v11[4]; // [esp+24h] [ebp-14h] BYREF
  int TargetValue; // [esp+28h] [ebp-10h] BYREF
  int v13; // [esp+34h] [ebp-4h]

  CServer::Add((int)this);
  CIOSocket::OnCreate(this);
  TargetValue = 0;
  v1 = inet_ntoa(this->m_addr);
  LOG_NORMAL("new connection %s", v1);
  if ( !std::vector<IPAddrMask>::empty(CDBConfig::s_vSubNet) )
  {
    std::vector<CSyncPacket::CElement>::begin(CDBConfig::s_vSubNet, v11);
    while ( 1 )
    {
      v2 = std::vector<CIOSocket::CIOTimer>::end(CDBConfig::s_vSubNet, (int)v8);
      if ( !std::_Tree<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::const_iterator::operator!=(v2) )
        break;
      v3 = *(_DWORD *)(std::vector<IPAddrMask>::iterator::operator->(v11) + 4) & this->m_addr.S_un.S_addr;
      if ( v3 == *(_DWORD *)std::vector<IPAddrMask>::iterator::operator->(v11) )
        break;
      std::vector<IPAddrMask>::iterator::operator++((int *)v11, v9, 0);
    }
    v4 = std::vector<CIOSocket::CIOTimer>::end(CDBConfig::s_vSubNet, (int)v7);
    if ( (unsigned __int8)unknown_libname_18(v4) )
    {
      v5 = inet_ntoa(this->m_addr);
      LOG_NORMAL("IP %s is restricted", v5);
      CIOSocket::Close((char *)this);
    }
  }
  if ( CServer::Size() <= 1 )
  {
    CDB::CDB(&v10);
    v13 = 0;
    CDB::Bind(&v10, &TargetValue);
    if ( CDB::Execute(&v10, "SELECT MAX([IID]) FROM Item") && CDB::Fetch(&v10) && !TargetValue )
      TargetValue = 0x80000000;
    CSocket::s_nIID = TargetValue;
    if ( TargetValue > 1610612736 )
    {
      LOG_ERR("Item identity is %d. Prepare IID composition.", TargetValue);
      ELOG("Item identity is %d. Prepare IID composition.\n", TargetValue);
    }
    v13 = -1;
    CDB::~CDB(&v10);
  }
  LOG_NORMAL("max item ID(%x)", TargetValue);
  CSocket::Write(
    (int)this,
    1,
    "bddddb",
    6,
    dword_43D97C,
    TargetValue,
    dword_43D974,
    CDBConfig::s_nSystem,
    CDBConfig::s_nEvent);
}
// 405110: using guessed type _DWORD __stdcall unknown_libname_18(_DWORD);
// 43D97C: using guessed type int dword_43D97C;

//----- (00410CD0) --------------------------------------------------------
void __thiscall CSocket::OnRead(CSocket *this)
{
  _DWORD *v2; // [esp+4h] [ebp-2Ch]
  CSyncPacket *v3; // [esp+8h] [ebp-28h]
  CSyncPacket::CElement element; // [esp+Ch] [ebp-24h] BYREF
  DWORD dwNumberOfBytesTransferred; // [esp+20h] [ebp-10h]
  size_t v6; // [esp+24h] [ebp-Ch]
  CIOBuffer *v7; // [esp+28h] [ebp-8h]
  size_t Size; // [esp+2Ch] [ebp-4h]

  Size = this->m_pReadBuf->m_dwSize;
  v7 = this->m_pReadBuf;
  while ( 1 )
  {
    dwNumberOfBytesTransferred = (DWORD)v7;
    if ( Size < 2 )
      break;
    v6 = *(unsigned __int16 *)dwNumberOfBytesTransferred;
    if ( Size < v6 )
      break;
    Size -= v6;
    v7 = (CIOBuffer *)((char *)v7 + v6);
    InterlockedIncrement((volatile LONG *)&stru_4441A4 + 5);
    if ( *(unsigned __int8 *)(dwNumberOfBytesTransferred + 2) >= 0x1Fu )
    {
      if ( *(unsigned __int8 *)(dwNumberOfBytesTransferred + 2) >= 0x51u )
      {
        ELOG("Invalid packet Type at CSocket::OnRead\n");
        LogPacket(
          *(unsigned __int8 *)(dwNumberOfBytesTransferred + 2),
          *(unsigned __int16 *)dwNumberOfBytesTransferred,
          (char *)(dwNumberOfBytesTransferred + 3));
      }
      else
      {
        v2 = CMemoryPool<CPacket>::Alloc();
        v2[5] = this->m_pReadBuf;
        CIOBuffer::AddRef((volatile LONG *)this->m_pReadBuf->m_buffer);
        v2[4] = this;
        CIOObject::AddRef((volatile LONG *)this);
        CIOObject::PostObject(v2, dwNumberOfBytesTransferred);
      }
    }
    else
    {
      v3 = (CSyncPacket *)((char *)&g_syncPacket + 76 * *(unsigned __int8 *)(dwNumberOfBytesTransferred + 3));
      CSyncPacket::CElement::CElement(&element, this, this->m_pReadBuf, (DBPACKET *)dwNumberOfBytesTransferred);
      CIOBuffer::AddRef((volatile LONG *)this->m_pReadBuf->m_buffer);
      CIOObject::AddRef((volatile LONG *)this);
      CIOCriticalSection::Enter((CIOCriticalSection *)((char *)v3 + 40));
      CSyncPacket::Push(v3, &element);
      CIOCriticalSection::Leave((CIOCriticalSection *)((char *)v3 + 40));
      if ( InterlockedIncrement((volatile LONG *)v3 + 18) == 1 )
        CIOObject::PostObject(v3, 0);
    }
  }
  CIOSocket::Read(this, Size);
}

//----- (00410E60) --------------------------------------------------------
void __thiscall CSocket::OnClose(CSocket *this)
{
  char *v1; // eax

  CServer::Remove((int)this);
  v1 = inet_ntoa(this->m_addr);
  LOG_NORMAL("close connection %s", v1);
}

//----- (00410EA0) --------------------------------------------------------
void CSocket::Write(int a1, char a2, ...)
{
  CIOBuffer *v5; // [esp+8h] [ebp-8h]
  va_list va; // [esp+20h] [ebp+10h] BYREF

  va_start(va, a2);
  v5 = CIOBuffer::Alloc();
  v5->m_buffer[2] = a2;
  *(_WORD *)v5->m_buffer = (unsigned __int16)WritePacketV(&v5->m_buffer[3], va) - (_WORD)v5;
  v5->m_dwSize = *(unsigned __int16 *)v5->m_buffer;
  CIOSocket::Write((CIOSocket *)a1, v5);
}

//----- (00410F10) --------------------------------------------------------
void __thiscall CSocket::Process(CSocket *this, DBPACKET *dbpacket)
{
  int v2; // eax
  char v4[4]; // [esp+10h] [ebp-3B4h] BYREF
  CDB v5; // [esp+14h] [ebp-3B0h] BYREF
  int v6; // [esp+24h] [ebp-3A0h] BYREF
  int v7; // [esp+28h] [ebp-39Ch] BYREF
  int v8; // [esp+2Ch] [ebp-398h] BYREF
  int v9; // [esp+30h] [ebp-394h] BYREF
  int v10; // [esp+34h] [ebp-390h] BYREF
  int v11; // [esp+38h] [ebp-38Ch] BYREF
  int v12; // [esp+3Ch] [ebp-388h] BYREF
  int v13; // [esp+40h] [ebp-384h] BYREF
  int v14; // [esp+44h] [ebp-380h] BYREF
  int v15; // [esp+48h] [ebp-37Ch] BYREF
  unsigned __int8 v16; // [esp+4Fh] [ebp-375h] BYREF
  int v17; // [esp+50h] [ebp-374h] BYREF
  unsigned __int8 v18; // [esp+57h] [ebp-36Dh] BYREF
  int v19; // [esp+58h] [ebp-36Ch] BYREF
  int v20; // [esp+5Ch] [ebp-368h] BYREF
  int v21; // [esp+60h] [ebp-364h] BYREF
  int v22; // [esp+64h] [ebp-360h] BYREF
  int v23; // [esp+68h] [ebp-35Ch] BYREF
  int v24; // [esp+6Ch] [ebp-358h] BYREF
  int v25; // [esp+70h] [ebp-354h] BYREF
  int v26; // [esp+74h] [ebp-350h] BYREF
  const char *v27; // [esp+78h] [ebp-34Ch] BYREF
  int v28; // [esp+7Ch] [ebp-348h] BYREF
  const char *v29; // [esp+80h] [ebp-344h] BYREF
  int v30; // [esp+84h] [ebp-340h] BYREF
  const char *v31; // [esp+88h] [ebp-33Ch] BYREF
  int v32; // [esp+8Ch] [ebp-338h] BYREF
  const char *v33; // [esp+90h] [ebp-334h] BYREF
  int v34; // [esp+94h] [ebp-330h] BYREF
  unsigned __int8 v35; // [esp+9Bh] [ebp-329h] BYREF
  char v36[4]; // [esp+9Ch] [ebp-328h] BYREF
  int v37; // [esp+A0h] [ebp-324h] BYREF
  int v38; // [esp+A4h] [ebp-320h] BYREF
  unsigned __int8 v39; // [esp+ABh] [ebp-319h] BYREF
  char v40[4]; // [esp+ACh] [ebp-318h] BYREF
  const char *v41; // [esp+B0h] [ebp-314h] BYREF
  const char *v42; // [esp+B4h] [ebp-310h] BYREF
  const char *v43; // [esp+B8h] [ebp-30Ch] BYREF
  int v44; // [esp+BCh] [ebp-308h] BYREF
  char v45[4]; // [esp+C0h] [ebp-304h] BYREF
  int v46; // [esp+C4h] [ebp-300h] BYREF
  int v47; // [esp+C8h] [ebp-2FCh] BYREF
  const char *v48; // [esp+CCh] [ebp-2F8h] BYREF
  int v49; // [esp+D0h] [ebp-2F4h] BYREF
  int v50; // [esp+D4h] [ebp-2F0h] BYREF
  int v51; // [esp+D8h] [ebp-2ECh] BYREF
  unsigned __int8 v52; // [esp+DFh] [ebp-2E5h] BYREF
  const char *v53; // [esp+E0h] [ebp-2E4h] BYREF
  int v54; // [esp+E4h] [ebp-2E0h] BYREF
  int v55; // [esp+E8h] [ebp-2DCh] BYREF
  int v56; // [esp+ECh] [ebp-2D8h] BYREF
  int v57; // [esp+F0h] [ebp-2D4h] BYREF
  int v58; // [esp+F4h] [ebp-2D0h] BYREF
  int v59; // [esp+F8h] [ebp-2CCh] BYREF
  int v60; // [esp+FCh] [ebp-2C8h] BYREF
  int v61; // [esp+100h] [ebp-2C4h] BYREF
  unsigned __int8 v62; // [esp+107h] [ebp-2BDh] BYREF
  int v63; // [esp+108h] [ebp-2BCh] BYREF
  int v64; // [esp+10Ch] [ebp-2B8h] BYREF
  int v65; // [esp+110h] [ebp-2B4h] BYREF
  int v66; // [esp+114h] [ebp-2B0h] BYREF
  int v67; // [esp+118h] [ebp-2ACh] BYREF
  int v68; // [esp+11Ch] [ebp-2A8h] BYREF
  unsigned __int8 v69; // [esp+123h] [ebp-2A1h] BYREF
  int v70; // [esp+124h] [ebp-2A0h] BYREF
  int v71; // [esp+128h] [ebp-29Ch] BYREF
  int v72; // [esp+12Ch] [ebp-298h] BYREF
  int v73; // [esp+130h] [ebp-294h] BYREF
  int v74; // [esp+134h] [ebp-290h] BYREF
  int v75; // [esp+138h] [ebp-28Ch] BYREF
  int v76; // [esp+13Ch] [ebp-288h] BYREF
  int v77; // [esp+140h] [ebp-284h] BYREF
  unsigned __int8 v78; // [esp+147h] [ebp-27Dh] BYREF
  int v79; // [esp+148h] [ebp-27Ch] BYREF
  int v80; // [esp+14Ch] [ebp-278h] BYREF
  int v81; // [esp+150h] [ebp-274h] BYREF
  int v82; // [esp+154h] [ebp-270h] BYREF
  int v83; // [esp+158h] [ebp-26Ch] BYREF
  int v84; // [esp+15Ch] [ebp-268h] BYREF
  int v85; // [esp+160h] [ebp-264h] BYREF
  int v86; // [esp+164h] [ebp-260h] BYREF
  int v87; // [esp+168h] [ebp-25Ch] BYREF
  int v88; // [esp+16Ch] [ebp-258h] BYREF
  int v89; // [esp+170h] [ebp-254h] BYREF
  int v90; // [esp+174h] [ebp-250h] BYREF
  int v91; // [esp+178h] [ebp-24Ch] BYREF
  int v92; // [esp+17Ch] [ebp-248h] BYREF
  char *szMessage; // [esp+180h] [ebp-244h] BYREF
  int v94; // [esp+184h] [ebp-240h] BYREF
  const char *v95; // [esp+188h] [ebp-23Ch] BYREF
  unsigned __int8 v96; // [esp+18Fh] [ebp-235h] BYREF
  int v97; // [esp+190h] [ebp-234h] BYREF
  int v98; // [esp+194h] [ebp-230h] BYREF
  int v99; // [esp+198h] [ebp-22Ch] BYREF
  unsigned __int8 v100; // [esp+19Fh] [ebp-225h] BYREF
  int nDate; // [esp+1A0h] [ebp-224h] BYREF
  int v102; // [esp+1A4h] [ebp-220h] BYREF
  int nSecedeDate; // [esp+1A8h] [ebp-21Ch] BYREF
  int v104; // [esp+1ACh] [ebp-218h] BYREF
  int v105; // [esp+1B0h] [ebp-214h] BYREF
  int v106; // [esp+1B4h] [ebp-210h] BYREF
  int nGID; // [esp+1B8h] [ebp-20Ch] BYREF
  char *v108; // [esp+1BCh] [ebp-208h] BYREF
  int nPlayer; // [esp+1C0h] [ebp-204h] BYREF
  char *szGuildName; // [esp+1C4h] [ebp-200h] BYREF
  int v111; // [esp+1C8h] [ebp-1FCh] BYREF
  int v112; // [esp+1CCh] [ebp-1F8h] BYREF
  int v113; // [esp+1D0h] [ebp-1F4h] BYREF
  int v114; // [esp+1D4h] [ebp-1F0h] BYREF
  unsigned __int8 v115; // [esp+1DBh] [ebp-1E9h] BYREF
  int nId; // [esp+1DCh] [ebp-1E8h] BYREF
  unsigned __int8 v117; // [esp+1E3h] [ebp-1E1h] BYREF
  int v118; // [esp+1E4h] [ebp-1E0h] BYREF
  unsigned __int8 v119; // [esp+1EBh] [ebp-1D9h] BYREF
  int v120; // [esp+1ECh] [ebp-1D8h] BYREF
  unsigned __int8 v121; // [esp+1F2h] [ebp-1D2h] BYREF
  unsigned __int8 v122; // [esp+1F3h] [ebp-1D1h] BYREF
  unsigned __int16 v123; // [esp+1F4h] [ebp-1D0h] BYREF
  int v124; // [esp+1F8h] [ebp-1CCh] BYREF
  int v125; // [esp+1FCh] [ebp-1C8h] BYREF
  unsigned __int8 v126; // [esp+203h] [ebp-1C1h] BYREF
  int v127; // [esp+204h] [ebp-1C0h] BYREF
  unsigned __int8 v128; // [esp+20Bh] [ebp-1B9h] BYREF
  int v129; // [esp+20Ch] [ebp-1B8h] BYREF
  unsigned __int8 v130; // [esp+213h] [ebp-1B1h] BYREF
  int TargetValue; // [esp+214h] [ebp-1B0h] BYREF
  int v132; // [esp+218h] [ebp-1ACh] BYREF
  int v133; // [esp+21Ch] [ebp-1A8h] BYREF
  int v134; // [esp+220h] [ebp-1A4h] BYREF
  unsigned __int8 v135; // [esp+227h] [ebp-19Dh] BYREF
  int v136; // [esp+228h] [ebp-19Ch] BYREF
  char v137[4]; // [esp+22Ch] [ebp-198h] BYREF
  int v138; // [esp+230h] [ebp-194h] BYREF
  unsigned __int8 v139; // [esp+237h] [ebp-18Dh] BYREF
  int v140; // [esp+238h] [ebp-18Ch] BYREF
  unsigned __int8 v141; // [esp+23Fh] [ebp-185h] BYREF
  int v142; // [esp+240h] [ebp-184h] BYREF
  int v143; // [esp+244h] [ebp-180h] BYREF
  unsigned __int8 v144; // [esp+24Ah] [ebp-17Ah] BYREF
  unsigned __int8 v145; // [esp+24Bh] [ebp-179h] BYREF
  unsigned __int16 v146[3]; // [esp+24Ch] [ebp-178h] BYREF
  unsigned __int8 v147; // [esp+253h] [ebp-171h] BYREF
  int v148; // [esp+254h] [ebp-170h] BYREF
  unsigned __int8 v149; // [esp+25Ah] [ebp-16Ah] BYREF
  unsigned __int8 v150; // [esp+25Bh] [ebp-169h] BYREF
  int v151; // [esp+25Ch] [ebp-168h] BYREF
  unsigned __int8 v152; // [esp+263h] [ebp-161h] BYREF
  int v153; // [esp+264h] [ebp-160h] BYREF
  int v154; // [esp+268h] [ebp-15Ch] BYREF
  int v155; // [esp+26Ch] [ebp-158h] BYREF
  unsigned __int8 v156; // [esp+273h] [ebp-151h] BYREF
  int v157; // [esp+274h] [ebp-150h] BYREF
  unsigned __int8 v158; // [esp+27Ah] [ebp-14Ah] BYREF
  unsigned __int8 v159; // [esp+27Bh] [ebp-149h] BYREF
  int v160; // [esp+27Ch] [ebp-148h] BYREF
  int nExp; // [esp+280h] [ebp-144h] BYREF
  int v162; // [esp+284h] [ebp-140h] BYREF
  char v163; // [esp+28Bh] [ebp-139h] BYREF
  int v164; // [esp+28Ch] [ebp-138h] BYREF
  unsigned __int8 v165; // [esp+293h] [ebp-131h] BYREF
  int v166; // [esp+294h] [ebp-130h] BYREF
  int v167; // [esp+298h] [ebp-12Ch] BYREF
  unsigned __int8 v168; // [esp+29Fh] [ebp-125h] BYREF
  int v169; // [esp+2A0h] [ebp-124h] BYREF
  char v170; // [esp+2A6h] [ebp-11Eh] BYREF
  unsigned __int8 v171; // [esp+2A7h] [ebp-11Dh] BYREF
  int v172; // [esp+2A8h] [ebp-11Ch] BYREF
  unsigned __int8 v173; // [esp+2AFh] [ebp-115h] BYREF
  int v174; // [esp+2B0h] [ebp-114h] BYREF
  unsigned __int8 v175; // [esp+2B7h] [ebp-10Dh] BYREF
  int v176; // [esp+2B8h] [ebp-10Ch] BYREF
  int v177; // [esp+2BCh] [ebp-108h] BYREF
  unsigned __int8 v178; // [esp+2C2h] [ebp-102h] BYREF
  unsigned __int8 v179; // [esp+2C3h] [ebp-101h] BYREF
  int v180; // [esp+2C4h] [ebp-100h] BYREF
  unsigned __int16 v181[3]; // [esp+2C8h] [ebp-FCh] BYREF
  unsigned __int8 v182; // [esp+2CEh] [ebp-F6h] BYREF
  unsigned __int8 v183; // [esp+2CFh] [ebp-F5h] BYREF
  int v184; // [esp+2D0h] [ebp-F4h] BYREF
  unsigned __int16 v185[3]; // [esp+2D4h] [ebp-F0h] BYREF
  unsigned __int8 v186; // [esp+2DBh] [ebp-E9h] BYREF
  int v187; // [esp+2DCh] [ebp-E8h] BYREF
  int v188; // [esp+2E0h] [ebp-E4h] BYREF
  unsigned __int8 v189; // [esp+2E7h] [ebp-DDh] BYREF
  int v190; // [esp+2E8h] [ebp-DCh] BYREF
  int v191; // [esp+2ECh] [ebp-D8h] BYREF
  int v192; // [esp+2F0h] [ebp-D4h] BYREF
  unsigned __int8 v193; // [esp+2F7h] [ebp-CDh] BYREF
  int nUID; // [esp+2F8h] [ebp-CCh] BYREF
  int v195; // [esp+2FCh] [ebp-C8h] BYREF
  unsigned __int16 v196[3]; // [esp+300h] [ebp-C4h] BYREF
  unsigned __int8 v197; // [esp+307h] [ebp-BDh] BYREF
  int v198; // [esp+308h] [ebp-BCh] BYREF
  unsigned __int8 v199; // [esp+30Fh] [ebp-B5h] BYREF
  unsigned __int16 v200; // [esp+310h] [ebp-B4h] BYREF
  int v201; // [esp+314h] [ebp-B0h] BYREF
  unsigned __int8 v202; // [esp+31Bh] [ebp-A9h] BYREF
  unsigned __int16 v203; // [esp+31Ch] [ebp-A8h] BYREF
  int Number; // [esp+320h] [ebp-A4h] BYREF
  int v205; // [esp+324h] [ebp-A0h] BYREF
  unsigned __int8 v206; // [esp+32Bh] [ebp-99h] BYREF
  int v207; // [esp+32Ch] [ebp-98h] BYREF
  unsigned __int16 v208; // [esp+330h] [ebp-94h] BYREF
  int nOldPID; // [esp+334h] [ebp-90h] BYREF
  int nNum; // [esp+338h] [ebp-8Ch] BYREF
  int nNewPID; // [esp+33Ch] [ebp-88h] BYREF
  unsigned __int8 v212; // [esp+343h] [ebp-81h] BYREF
  int v213; // [esp+344h] [ebp-80h] BYREF
  char v214; // [esp+34Bh] [ebp-79h] BYREF
  __int16 v215; // [esp+34Ch] [ebp-78h] BYREF
  int v216; // [esp+350h] [ebp-74h] BYREF
  int v217; // [esp+354h] [ebp-70h] BYREF
  char v218; // [esp+35Bh] [ebp-69h] BYREF
  int v219; // [esp+35Ch] [ebp-68h] BYREF
  char v220; // [esp+362h] [ebp-62h] BYREF
  char v221; // [esp+363h] [ebp-61h] BYREF
  char *packet; // [esp+364h] [ebp-60h] BYREF
  int v223; // [esp+368h] [ebp-5Ch] BYREF
  int v224; // [esp+36Ch] [ebp-58h] BYREF
  int nLogType; // [esp+370h] [ebp-54h] BYREF
  unsigned __int16 v226; // [esp+374h] [ebp-50h] BYREF
  int v227; // [esp+378h] [ebp-4Ch] BYREF
  int nVal1; // [esp+37Ch] [ebp-48h] BYREF
  int nIndex; // [esp+380h] [ebp-44h] BYREF
  int v230; // [esp+384h] [ebp-40h] BYREF
  unsigned __int8 v231; // [esp+38Bh] [ebp-39h] BYREF
  int nPID; // [esp+38Ch] [ebp-38h] BYREF
  int v233; // [esp+390h] [ebp-34h] BYREF
  int nLoadGID; // [esp+394h] [ebp-30h] BYREF
  char v235; // [esp+39Bh] [ebp-29h] BYREF
  int v236; // [esp+39Ch] [ebp-28h] BYREF
  int v237; // [esp+3A0h] [ebp-24h] BYREF
  int v238; // [esp+3A4h] [ebp-20h] BYREF
  int v239; // [esp+3A8h] [ebp-1Ch] BYREF
  int v240; // [esp+3ACh] [ebp-18h] BYREF
  void *Src; // [esp+3B0h] [ebp-14h]
  int v242; // [esp+3B4h] [ebp-10h]
  int v243; // [esp+3C0h] [ebp-4h]
  int vars0; // [esp+3C4h] [ebp+0h]
  void *retaddr; // [esp+3C8h] [ebp+4h]

  Src = dbpacket->data;
  v242 = dbpacket->byType;
  switch ( v242 )
  {
    case 0:
      ReadPacket((char *)Src, "ddd", &v239, &v240, &v238);
      CSocket::DelPlayer(this, v239, v240, v238);
      break;
    case 1:
      ReadPacket((char *)Src, "ddddb", &v236, &nLoadGID, &v237, &v233, &v235);
      CSocket::LoadPlayer(this, v236, nLoadGID, v237, v233);
      break;
    case 2:
      sub_413CB0(Src);
      break;
    case 3:
      ReadPacket((char *)Src, "ddwdbddd", &nPID, &nIndex, &v226, &nVal1, &v231, &nLogType, &v227, &v230);
      CSocket::DeleteItem((CSocket *)nPID, (int)this, nPID, nIndex, v226, nVal1, v231, nLogType);
      break;
    case 4:
      ReadPacket((char *)Src, "d", &v224);
      CSocket::PutOnItem(this, v224);
      break;
    case 5:
      ReadPacket((char *)Src, "d", &v223);
      CSocket::PutOffItem(this, v223);
      break;
    case 6:
      ReadPacket((char *)Src, "dwbddbbdb", &packet, &v215, &v218, &v216, &v217, &v214, &v220, &v219, &v221);
      CSocket::InsertItem(this, packet);
      break;
    case 7:
      ReadPacket((char *)Src, "dddwbd", &v213, &nOldPID, &nNewPID, &v208, &v212, &nNum);
      CSocket::UpdateItemPID(this, v213, nOldPID, nNewPID, v208, nNum, v212);
      break;
    case 8:
      ReadPacket((char *)Src, "ddwdb", &v207, &v205, &v203, &Number, &v206);
      CSocket::UpdateItemNum(this, v207, v205, v203, Number, v206);
      break;
    case 9:
      ReadPacket((char *)Src, "dbw", &v201, &v202, &v200);
      CSocket::InsertSkill(this, v201, v202, v200);
      break;
    case 10:
      ReadPacket((char *)Src, "dbbw", &v198, &v199, &v197, v196);
      CSocket::SkillUp(this, v198, v199, v197, v196[0]);
      break;
    case 11:
      ReadPacket((char *)Src, "dddbd", &v195, &v192, &nUID, &v193, &v191);
      CSocket::PutInStorage(this, v195, v192, nUID, v193, v191);
      break;
    case 12:
      ReadPacket((char *)Src, "ddbd", &v190, &v188, &v189, &v187);
      CSocket::PutOutStorage(this, v190, v188, v189, v187);
      break;
    case 13:
      ReadPacket((char *)Src, "dwbb", &v184, v185, &v183, &v186);
      CSocket::InsertQuestFlag(this, v184, v185[0], v183, v186);
      break;
    case 14:
      ReadPacket((char *)Src, "dwbb", &v180, v181, &v179, &v182);
      CSocket::UpdateQuestFlag(this, v180, v181[0], v179, v182);
      break;
    case 15:
      ReadPacket((char *)Src, "db", &v177, &v178);
      CSocket::SaveSpecialty(this, v177, v178);
      break;
    case 16:
      Src = ReadPacket((char *)Src, "db", &v176, &v175);
      CSocket::UpdateProperty(this, v176, v175, (char *)Src);
      break;
    case 17:
      ReadPacket((char *)Src, "ddbbb", &v174, &v172, &v171, &v173, &v170);
      CSocket::UpdateItemXValue(this, v174, v172, v171, v173);
      break;
    case 18:
      ReadPacket((char *)Src, "ddb", &v169, &v167, &v168);
      CSocket::UpdateItemEnd(this, v169, v167, v168);
      break;
    case 19:
      ReadPacket((char *)Src, "ddbb", &v166, &v164, &v165, &v163);
      CSocket::UpdateItemPrefix(this, v166, v164, v165);
      break;
    case 20:
      ReadPacket((char *)Src, "dddbb", &v162, &v160, &nExp, &v158, &v159);
      CSocket::UpdateTransformItem(this, v162, v160, nExp, v158, v159);
      break;
    case 21:
      Src = ReadPacket((char *)Src, "dddb", &v157, &v155, &v154, &v156);
      sub_414E10(v157, v155, v154, v156, Src);
      break;
    case 22:
      ReadPacket((char *)Src, "dbbw", &v148, &v149, &v147, v146);
      CSocket::SkillRedistribute(this, v148, v149, v147, v146[0]);
      break;
    case 23:
      ReadPacket((char *)Src, "dd", &v79, &v80);
      sub_4180A0(v79, v80);
      break;
    case 24:
      ReadPacket((char *)Src, "ddb", &v76, &v77, &v78);
      sub_418140(v76, v77, v78);
      break;
    case 25:
      ReadPacket((char *)Src, "dbdb", &v143, &v144, &v142, &v145);
      sub_415180(v143, v144, v142, v145);
      break;
    case 26:
      ReadPacket((char *)Src, "d", &v75);
      sub_418300(v75);
      break;
    case 27:
      ReadPacket((char *)Src, "dd", &v67, &v66);
      sub_418AC0(v67, v66);
      break;
    case 28:
      Src = ReadPacket((char *)Src, "ddbb", &v153, &v151, &v152, &v150);
      sub_414F80(v153, v151, v152, v150);
      break;
    case 29:
      Src = ReadPacket((char *)Src, "db", &v138, &v139);
      if ( (dword_43D974 & 0x40) != 0 )
        sub_415500(this, v139, v138, Src);
      break;
    case 30:
      Src = ReadPacket((char *)Src, "dbd", v137, &v135, &v136);
      if ( (dword_43D974 & 0x400) != 0 )
        sub_415790(this, v135, v136, Src);
      break;
    case 32:
      CIOSocket::Close((char *)this);
      break;
    case 33:
      ReadPacket((char *)Src, "dd", &v133, &v134);
      sub_4168C0(this, v133, v134);
      break;
    case 34:
      CSocket::NewPlayer(this, (char *)Src);
      break;
    case 35:
      ReadPacket(
        (char *)Src,
        "bdwbddbbdds",
        &v130,
        &v132,
        &v123,
        &v126,
        &v124,
        &v125,
        &v122,
        &v128,
        &TargetValue,
        &v127,
        &v129);
      sub_417340(v130, v132, v123, v126, v124, v125, v122, v128, TargetValue, v129, v127);
      break;
    case 36:
      ReadPacket((char *)Src, "db", &v120, &v121);
      CSocket::SaveRevivalPt(this, v120, v121);
      break;
    case 37:
      Src = ReadPacket((char *)Src, "db", &v118, &v119);
      CSocket::EventSave(this, v118, v119, (const char *)Src);
      break;
    case 38:
      Src = ReadPacket((char *)Src, "db", &nId, &v117);
      CSocket::ProcessEvent(this, nId, v117, (char *)Src);
      break;
    case 39:
      Src = ReadPacket((char *)Src, "db", &v114, &v115);
      CSocket::GuildCreateSecedeCheck(this, v114, v115, (const char *)Src);
      break;
    case 40:
      ReadPacket((char *)Src, "ddd", &v111, &v113, &v112);
      CSocket::GuildSecedeCheck(this, v111, v113, v112);
      break;
    case 41:
      ReadPacket((char *)Src, "ds", &nPlayer, &szGuildName);
      CSocket::GuildSameNameCheck(this, nPlayer, szGuildName);
      break;
    case 42:
      ReadPacket((char *)Src, "ds", &nGID, &v108);
      CSocket::GuildCreate(this, nGID, v108);
      break;
    case 43:
      ReadPacket((char *)Src, "dd", &v105, &v106);
      CSocket::GuildConflux(this, v105, v106);
      break;
    case 44:
      ReadPacket((char *)Src, "d", &v104);
      CSocket::GuildSecederDelete(this, v104);
      break;
    case 45:
      ReadPacket((char *)Src, "dd", &v102, &nSecedeDate);
      CSocket::GuildSeceder(this, v102, nSecedeDate);
      break;
    case 46:
      ReadPacket((char *)Src, "dbd", &v99, &v100, &nDate);
      CSocket::GuildAppointment(this, v99, v100, nDate);
      break;
    case 47:
      ReadPacket((char *)Src, "dd", &v97, &v98);
      CSocket::GuildDissolution(this, v97, v98);
      break;
    case 48:
      ReadPacket((char *)Src, "dbs", &v94, &v96, &v95);
      CSocket::GuildTitleChange(this, v94, v96, (char *)v95);
      break;
    case 49:
      ReadPacket((char *)Src, "ds", &v92, &szMessage);
      CSocket::GuildTodayMessageChange(this, v92, szMessage);
      break;
    case 50:
      ReadPacket((char *)Src, "ddd", &v89, &v90, &v91);
      sub_417EC0(v89, v90, v91);
      break;
    case 51:
      ReadPacket((char *)Src, "dddddd", &v81, &v82, &v83, &v86, &v85, &v84);
      sub_418020(v81, v82, v83, v86, v85, v84);
      break;
    case 52:
      ReadPacket((char *)Src, "dbdss", &v51, &v52, &v55, &v54, &v53);
      sub_4193B0(this, v51, v52, v55, v54, v53);
      break;
    case 53:
      ReadPacket((char *)Src, "dddss", &v46, &v49, &v50, &v48, &v47);
      sub_419510(this, v46, v49, v50, v48, v47);
      break;
    case 54:
      Src = ReadPacket((char *)Src, "dd", &v44, v45);
      sub_419D90(this, v44, *(int *)v45, Src);
      break;
    case 55:
      ReadPacket((char *)Src, "sss", &v41, &v42, &v43);
      sub_41A280(v41, v42, v43);
      break;
    case 56:
      sub_41A2F0(this);
      break;
    case 57:
      sub_418430(this);
      break;
    case 58:
      sub_4185D0(this);
      break;
    case 59:
      ReadPacket((char *)Src, "sd", &v87, &v88);
      CSocket::GuildSetExp(this, v87, v88);
      break;
    case 60:
      ReadPacket((char *)Src, "dd", &v73, &v74);
      sub_4183A0(v73, v74);
      break;
    case 61:
      ReadPacket((char *)Src, "ddd", &v72, &v70, &v71);
      sub_418930(v72, v70, v71);
      break;
    case 62:
      sub_4188D0();
      break;
    case 63:
      ReadPacket((char *)Src, "db", &v68, &v69);
      sub_418A50(v68, v69);
      break;
    case 64:
      ReadPacket((char *)Src, "dd", &v65, &v64);
      sub_4189C0(v65, v64);
      break;
    case 65:
      ReadPacket((char *)Src, "db", &v63, &v62);
      sub_418B30(v63, v62);
      break;
    case 66:
      Src = ReadPacket((char *)Src, "db", &v140, &v141);
      sub_415240(this, v141, v140, Src);
      break;
    case 67:
      Src = ReadPacket((char *)Src, "bd", &v39, v40);
      sub_41A450(this, v39, *(int *)v40, Src);
      break;
    case 68:
      ReadPacket((char *)Src, "ddd", &v59, &v60, &v61);
      sub_4191C0(this, v59, v60, v61);
      break;
    case 69:
      ReadPacket((char *)Src, "ddd", &v56, &v57, &v58);
      sub_4192D0(this, v56, v57, v58);
      break;
    case 70:
      ReadPacket((char *)Src, "dd", &v37, &v38);
      sub_41A5B0(this, v37, v38);
      break;
    case 71:
      Src = ReadPacket((char *)Src, "dbs", v36, &v35, &v34);
      sub_41A750(this, *(int *)v36, v35, v34, Src);
      break;
    case 72:
      ReadPacket((char *)Src, "ddss", &v30, &v32, &v33, &v31);
      sub_41A890(this, v30, v32, v33, v31);
      break;
    case 73:
      ReadPacket((char *)Src, "ddss", &v26, &v28, &v29, &v27);
      sub_41AA30(this, v26, v28, v29, v27);
      break;
    case 74:
      ReadPacket((char *)Src, "ddddddd", &v21, &v19, &v23, &v24, &v25, &v20, &v22);
      sub_41AB20(v21, v19, v23, v24, v25, v20, v22);
      break;
    case 75:
      ReadPacket((char *)Src, "dbb", &v17, &v18, &v16);
      sub_41ABA0(v17, v18, v16);
      break;
    case 76:
      ReadPacket((char *)Src, "ddd", &v13, &v14, &v15);
      sub_41AC30(v13, v14, v15);
      break;
    case 77:
      ReadPacket((char *)Src, "dd", &v11, &v12);
      sub_41AC50(this, v11, v12);
      break;
    case 78:
      ReadPacket((char *)Src, "dd", &v9, &v10);
      sub_41AD20(v9, v10);
      break;
    case 79:
      ReadPacket((char *)Src, "ddd", &v6, &v8, &v7);
      v2 = sub_41AD90(v8, v7);
      CSocket::Write((int)this, 30, "db", v6, v2);
      break;
    case 80:
      ReadPacket((char *)Src, "d", v4);
      CDB::CDB(&v5);
      v243 = 0;
      CDB::ExecuteNoData(&v5, "EXEC RestoreRestUserItem %d", *(_DWORD *)v4);
      v243 = -1;
      CDB::~CDB(&v5);
      break;
    default:
      ELOG("Invalid packet Type at CSocket::Process dwEIP(%x,%x)\n", retaddr, *(_DWORD *)(vars0 + 4));
      LogPacket(dbpacket->byType, dbpacket->wSize, dbpacket->data);
      break;
  }
}

//----- (00412820) --------------------------------------------------------
void __thiscall CSocket::DelPlayer(CSocket *this, int nPID, int nUID, int nId)
{
  __time32_t v4; // eax
  __time32_t v5; // eax
  int v7; // [esp+4h] [ebp-48h] BYREF
  CDB v8; // [esp+8h] [ebp-44h] BYREF
  int n; // [esp+18h] [ebp-34h] BYREF
  int v10; // [esp+1Ch] [ebp-30h] BYREF
  int v11; // [esp+20h] [ebp-2Ch] BYREF
  int nGID; // [esp+24h] [ebp-28h] BYREF
  int TargetValue; // [esp+28h] [ebp-24h] BYREF
  int v14; // [esp+2Ch] [ebp-20h]
  CDB v15; // [esp+30h] [ebp-1Ch] BYREF
  int v16; // [esp+48h] [ebp-4h]

  v14 = 0;
  CDB::CDB(&v15);
  v16 = 0;
  CDB::Bind(&v15, &TargetValue);
  CDB::Bind(&v15, &nGID);
  if ( CDB::Execute(&v15, "SELECT [UID], [GID] FROM Player WHERE [PID] = %d", nPID)
    && CDB::Fetch(&v15)
    && TargetValue == nUID )
  {
    if ( nGID )
    {
      if ( nPID == nGID )
      {
        CDB::Reset(&v15);
        CDB::Bind(&v15, &n);
        if ( CDB::Execute(&v15, "SELECT [GID] FROM GuildCastle") )
        {
          CDB::CDB(&v8);
          LOBYTE(v16) = 1;
          while ( CDB::Fetch(&v15) )
          {
            if ( n )
            {
              if ( nGID == n
                || (CDB::Reset(&v8),
                    CDB::Bind(&v8, &v7),
                    CDB::Execute(&v8, "SELECT [AID] FROM Guild WHERE [GID] = %d", nGID))
                && CDB::Fetch(&v8)
                && v7 == n )
              {
                v14 = 3;
                LOBYTE(v16) = 0;
                CDB::~CDB(&v8);
                goto LABEL_32;
              }
            }
          }
          LOBYTE(v16) = 0;
          CDB::~CDB(&v8);
        }
        CDB::Reset(&v15);
        CDB::Bind(&v15, &v10);
        if ( CDB::Execute(&v15, "SELECT [GID] FROM GuildWar") )
        {
          while ( CDB::Fetch(&v15) )
          {
            if ( nGID == v10 )
            {
              v14 = 3;
              goto LABEL_32;
            }
          }
        }
        v4 = time(0);
        CSocket::GuildDissolution(this, nGID, v4 + 259200);
      }
      else
      {
        v5 = time(0);
        CSocket::GuildSeceder(this, nPID, v5 + 259200);
      }
      CSocket::Write((int)this, 12, "dd", nPID, nGID);
    }
    CDB::Reset(&v15);
    if ( CDB::Execute(&v15, "UPDATE Player SET [UID] = 0 WHERE [PID] = %d", nPID) )
    {
      CDB::Reset(&v15);
      CDB::ExecuteInsertUnique(&v15, "INSERT INTO PlayerDeleted VALUES (%d, %d, GETDATE())", nPID, nUID);
      LOG_DB(0, 4, nPID, nUID, 0, 0, 0, 0, 0);
      v14 = 1;
    }
    CDB::Reset(&v15);
    CDB::Bind(&v15, &v11);
    if ( CDB::Execute(&v15, "SELECT COUNT(*) FROM MLM WHERE [PID] = %d AND [Relation] = %d", nPID, 2)
      && CDB::Fetch(&v15)
      && v11 > 0 )
    {
      CDB::Reset(&v15);
      CDB::ExecuteNoData(
        &v15,
        "DELETE FROM MLM WHERE [PID] IN (SELECT [RPID] FROM MLM WHERE [PID] = %d AND [Relation] = %d) AND [Relation] = %d",
        nPID,
        4,
        1);
      v14 = 2;
    }
    CDB::Reset(&v15);
    CDB::ExecuteNoData(&v15, "DELETE FROM MLM WHERE [Relation] <> %d AND ([PID] = %d OR [RPID] = %d)", 0, nPID, nPID);
    CDB::Reset(&v15);
    CDB::ExecuteNoData(&v15, "DELETE FROM MLMMsg WHERE [PID] = %d", nPID);
  }
LABEL_32:
  CSocket::Write((int)this, 3, "db", nId, v14);
  v16 = -1;
  CDB::~CDB(&v15);
}

//----- (00412B80) --------------------------------------------------------
void __thiscall CSocket::LoadPlayer(CSocket *this, int nPID, int nLoadGID, int nUID, int nId)
{
  char v6; // [esp+7h] [ebp-E1h] BYREF
  int v7; // [esp+8h] [ebp-E0h] BYREF
  char *v8; // [esp+Ch] [ebp-DCh]
  int v9; // [esp+10h] [ebp-D8h] BYREF
  char v10; // [esp+17h] [ebp-D1h] BYREF
  unsigned __int16 v11; // [esp+18h] [ebp-D0h] BYREF
  char v12; // [esp+1Ch] [ebp-CCh] BYREF
  char v13; // [esp+1Dh] [ebp-CBh] BYREF
  char v14; // [esp+1Eh] [ebp-CAh] BYREF
  char v15; // [esp+1Fh] [ebp-C9h] BYREF
  int v16; // [esp+20h] [ebp-C8h] BYREF
  int v17; // [esp+24h] [ebp-C4h] BYREF
  char v18; // [esp+2Ah] [ebp-BEh] BYREF
  char v19; // [esp+2Bh] [ebp-BDh] BYREF
  char v20; // [esp+2Ch] [ebp-BCh] BYREF
  char v21; // [esp+2Dh] [ebp-BBh] BYREF
  char v22; // [esp+2Eh] [ebp-BAh] BYREF
  char v23; // [esp+2Fh] [ebp-B9h] BYREF
  char v24; // [esp+30h] [ebp-B8h] BYREF
  char v25; // [esp+31h] [ebp-B7h] BYREF
  char v26; // [esp+32h] [ebp-B6h] BYREF
  char v27; // [esp+33h] [ebp-B5h] BYREF
  int v28; // [esp+34h] [ebp-B4h] BYREF
  char v29; // [esp+3Ah] [ebp-AEh] BYREF
  char v30; // [esp+3Bh] [ebp-ADh] BYREF
  unsigned __int16 v31; // [esp+3Ch] [ebp-ACh] BYREF
  int v32; // [esp+40h] [ebp-A8h] BYREF
  char v33; // [esp+47h] [ebp-A1h] BYREF
  int v34; // [esp+48h] [ebp-A0h] BYREF
  char v35; // [esp+4Ch] [ebp-9Ch] BYREF
  char v36; // [esp+4Dh] [ebp-9Bh] BYREF
  char v37; // [esp+4Eh] [ebp-9Ah] BYREF
  char v38; // [esp+4Fh] [ebp-99h] BYREF
  int v39; // [esp+50h] [ebp-98h] BYREF
  unsigned __int16 v40; // [esp+54h] [ebp-94h] BYREF
  int v41; // [esp+58h] [ebp-90h] BYREF
  int n; // [esp+5Ch] [ebp-8Ch] BYREF
  int v43; // [esp+60h] [ebp-88h] BYREF
  char *packet; // [esp+64h] [ebp-84h]
  char v45; // [esp+6Bh] [ebp-7Dh] BYREF
  unsigned __int16 v46; // [esp+6Ch] [ebp-7Ch] BYREF
  unsigned __int16 v47; // [esp+70h] [ebp-78h] BYREF
  __int16 v48[3]; // [esp+74h] [ebp-74h] BYREF
  char v49; // [esp+7Bh] [ebp-6Dh] BYREF
  int v50; // [esp+7Ch] [ebp-6Ch] BYREF
  char v51; // [esp+81h] [ebp-67h] BYREF
  char v52; // [esp+82h] [ebp-66h] BYREF
  char v53; // [esp+83h] [ebp-65h] BYREF
  __int16 v54[3]; // [esp+84h] [ebp-64h] BYREF
  char v55; // [esp+8Bh] [ebp-5Dh] BYREF
  char str[20]; // [esp+8Ch] [ebp-5Ch] BYREF
  char v57; // [esp+A6h] [ebp-42h] BYREF
  char v58; // [esp+A7h] [ebp-41h] BYREF
  char *v59; // [esp+A8h] [ebp-40h]
  int v60; // [esp+ACh] [ebp-3Ch]
  int v61; // [esp+B0h] [ebp-38h] BYREF
  __int64 v62; // [esp+B4h] [ebp-34h] BYREF
  char v63; // [esp+C1h] [ebp-27h] BYREF
  char v64; // [esp+C2h] [ebp-26h] BYREF
  char TargetValue; // [esp+C3h] [ebp-25h] BYREF
  CDB v66; // [esp+C4h] [ebp-24h] BYREF
  void *Src; // [esp+D4h] [ebp-14h]
  char v68; // [esp+DAh] [ebp-Eh] BYREF
  char v69; // [esp+DBh] [ebp-Dh] BYREF
  int v70; // [esp+E4h] [ebp-4h]
  int v71; // [esp+100h] [ebp+18h]

  Src = CIOBuffer::Alloc();
  v59 = (char *)Src;
  *((_BYTE *)Src + 2) = 4;
  packet = v59 + 8;
  v60 = 0;
  CDB::CDB(&v66);
  v70 = 0;
  CDB::Bind(&v66, &n);
  CDB::Skip(&v66);
  CDB::Bind(&TargetValue);
  CDB::Bind(&v66, str, 17);
  CDB::Bind(&v52);
  CDB::Bind(&v68);
  CDB::Bind(&v45);
  CDB::Bind(&v66, (unsigned __int16 *)v54);
  CDB::Bind(&v66, &v62);
  CDB::Bind(&v66, &v39);
  CDB::Bind(&v51);
  CDB::Bind(&v63);
  CDB::Bind(&v57);
  CDB::Bind(&v55);
  CDB::Bind(&v37);
  CDB::Bind(&v38);
  CDB::Bind(&v66, &v46);
  CDB::Bind(&v66, &v40);
  CDB::Bind(&v66, &v47);
  CDB::Bind(&v66, (unsigned __int16 *)v48);
  CDB::Bind(&v69);
  CDB::Bind(&v53);
  CDB::Bind(&v66, &v61);
  CDB::Bind(&v66, &v41);
  CDB::Bind(&v66, &v43);
  CDB::Bind(&v58);
  CDB::Bind(&v49);
  CDB::Bind(&v64);
  CDB::Bind(&v66, &v50);
  if ( CDB::Execute(&v66, "SELECT * FROM Player WHERE [PID] = %d", nPID) )
  {
    if ( CDB::Fetch(&v66) )
    {
      if ( nUID == n )
      {
        packet = PutNumeric<unsigned char>(packet, TargetValue);
        if ( TargetValue != 1 )
        {
          packet = PutString(packet, str);
          packet = PutNumeric<unsigned char>(packet, v52);
          packet = PutNumeric<unsigned char>(packet, v68);
          packet = PutNumeric<unsigned char>(packet, v45);
          packet = (char *)PutNumeric<short>(packet, v54[0]);
          packet = (char *)PutNumeric<__int64>(packet, v62, SHIDWORD(v62));
          packet = (char *)PutNumeric<int>(packet, v39);
          packet = PutNumeric<unsigned char>(packet, v51);
          packet = PutNumeric<unsigned char>(packet, v63);
          packet = PutNumeric<unsigned char>(packet, v57);
          packet = PutNumeric<unsigned char>(packet, v55);
          packet = PutNumeric<unsigned char>(packet, v37);
          packet = PutNumeric<unsigned char>(packet, v38);
          packet = (char *)PutNumeric<short>(packet, v46);
          packet = (char *)PutNumeric<short>(packet, v40);
          packet = (char *)PutNumeric<short>(packet, v47);
          packet = (char *)PutNumeric<short>(packet, v48[0]);
          packet = PutNumeric<unsigned char>(packet, v69);
          packet = PutNumeric<unsigned char>(packet, v53);
          packet = (char *)PutNumeric<int>(packet, v61);
          packet = (char *)PutNumeric<int>(packet, v41);
          packet = (char *)PutNumeric<int>(packet, v43);
          packet = PutNumeric<unsigned char>(packet, v58);
          packet = PutNumeric<unsigned char>(packet, v49);
          packet = PutNumeric<unsigned char>(packet, v64);
          packet = (char *)PutNumeric<int>(packet, v50);
          if ( !CDBConfig::s_nEvent )
          {
            CDB::Reset(&v66);
            CDB::Bind(&v10);
            if ( !CDB::Execute(&v66, "SELECT [Index] FROM Skill WHERE [PID] = %d AND [Index] = 62", nPID)
              || !CDB::Fetch(&v66) )
            {
              CDB::Reset(&v66);
              CDB::Execute(&v66, "INSERT INTO Skill VALUES(%d, 62, 1)", nPID);
            }
          }
          v8 = packet++;
          *v8 = 0;
          CDB::Reset(&v66);
          CDB::Bind(&v10);
          CDB::Bind(&v35);
          if ( CDB::Execute(&v66, "SELECT TOP 84 [Index], [Level] FROM Skill WHERE [PID] = %d", nPID) )
          {
            while ( CDB::Fetch(&v66) )
            {
              packet = PutNumeric<unsigned char>(packet, v10);
              packet = PutNumeric<unsigned char>(packet, v35);
              ++*v8;
            }
          }
          v8 = packet++;
          *v8 = 0;
          CDB::Reset(&v66);
          CDB::Skip(&v66);
          CDB::Bind(&v66, &v34);
          CDB::Bind(&v66, &v11);
          CDB::Bind(&v22);
          CDB::Bind(&v66, &v16);
          CDB::Bind(&v66, &v17);
          CDB::Bind(&v18);
          CDB::Bind(&v24);
          CDB::Bind(&v29);
          CDB::Bind(&v19);
          CDB::Bind(&v13);
          CDB::Bind(&v25);
          CDB::Bind(&v26);
          CDB::Bind(&v14);
          CDB::Bind(&v36);
          CDB::Bind(&v30);
          CDB::Bind(&v15);
          if ( CDB::Execute(&v66, "SELECT TOP %d * FROM Item WHERE [PID] = %d AND ( [Info] & %d) = 0", 72, nPID, 16) )
          {
            while ( CDB::Fetch(&v66) )
            {
              packet = (char *)PutNumeric<short>(packet, v11);
              packet = (char *)PutNumeric<int>(packet, v34);
              packet = PutNumeric<unsigned char>(packet, v22);
              packet = (char *)PutNumeric<int>(packet, v16);
              packet = (char *)PutNumeric<int>(packet, v17);
              packet = PutNumeric<unsigned char>(packet, v18);
              packet = PutNumeric<unsigned char>(packet, v24);
              packet = PutNumeric<unsigned char>(packet, v29);
              packet = PutNumeric<unsigned char>(packet, v19);
              packet = PutNumeric<unsigned char>(packet, v13);
              packet = PutNumeric<unsigned char>(packet, v25);
              packet = PutNumeric<unsigned char>(packet, v26);
              packet = PutNumeric<unsigned char>(packet, v14);
              packet = PutNumeric<unsigned char>(packet, v36);
              packet = PutNumeric<unsigned char>(packet, v30);
              packet = PutNumeric<unsigned char>(packet, v15);
              ++*v8;
            }
          }
          v8 = packet++;
          *v8 = 0;
          CDB::Reset(&v66);
          CDB::Skip(&v66);
          CDB::Bind(&v66, &v34);
          CDB::Bind(&v66, &v11);
          CDB::Bind(&v22);
          CDB::Bind(&v66, &v16);
          CDB::Bind(&v66, &v17);
          CDB::Bind(&v18);
          CDB::Bind(&v24);
          CDB::Bind(&v29);
          CDB::Bind(&v19);
          CDB::Bind(&v13);
          CDB::Bind(&v25);
          CDB::Bind(&v26);
          CDB::Bind(&v14);
          CDB::Bind(&v36);
          CDB::Bind(&v30);
          CDB::Bind(&v15);
          if ( CDB::Execute(&v66, "SELECT TOP %d * FROM Item WHERE [PID] = %d AND ( [Info] & %d) <> 0", 100, nUID, 16) )
          {
            while ( CDB::Fetch(&v66) )
            {
              packet = (char *)PutNumeric<short>(packet, v11);
              packet = (char *)PutNumeric<int>(packet, v34);
              packet = PutNumeric<unsigned char>(packet, v22);
              packet = (char *)PutNumeric<int>(packet, v16);
              packet = (char *)PutNumeric<int>(packet, v17);
              packet = PutNumeric<unsigned char>(packet, v18);
              packet = PutNumeric<unsigned char>(packet, v24);
              packet = PutNumeric<unsigned char>(packet, v29);
              packet = PutNumeric<unsigned char>(packet, v19);
              packet = PutNumeric<unsigned char>(packet, v13);
              packet = PutNumeric<unsigned char>(packet, v25);
              packet = PutNumeric<unsigned char>(packet, v26);
              packet = PutNumeric<unsigned char>(packet, v14);
              packet = PutNumeric<unsigned char>(packet, v36);
              packet = PutNumeric<unsigned char>(packet, v30);
              packet = PutNumeric<unsigned char>(packet, v15);
              ++*v8;
            }
          }
          v8 = packet++;
          *v8 = 0;
          CDB::Reset(&v66);
          CDB::Skip(&v66);
          CDB::Bind(&v66, &v31);
          CDB::Bind(&v12);
          CDB::Bind(&v33);
          if ( CDB::Execute(&v66, "SELECT * FROM Quest WHERE [PID] = %d", nPID) )
          {
            while ( CDB::Fetch(&v66) )
            {
              packet = (char *)PutNumeric<short>(packet, v31);
              packet = PutNumeric<unsigned char>(packet, v12);
              packet = PutNumeric<unsigned char>(packet, v33);
              ++*v8;
            }
          }
          if ( (CDBConfig::s_nSystem & 4) != 0 )
          {
            v8 = packet++;
            *v8 = 0;
            CDB::Reset(&v66);
            CDB::Bind(&v6);
            CDB::Bind(&v66, &v7);
            if ( CDB::Execute(&v66, "SELECT [Type], [nF1] FROM Event WHERE [PID] = %d", nPID) )
            {
              while ( CDB::Fetch(&v66) )
              {
                packet = PutNumeric<unsigned char>(packet, v6);
                packet = (char *)PutNumeric<int>(packet, v7);
                ++*v8;
              }
            }
          }
          v8 = packet++;
          *v8 = 0;
          CDB::Reset(&v66);
          CDB::Bind(&v20);
          CDB::Bind(&v66, str, 17);
          CDB::Bind(&v66, &v28);
          CDB::Bind(&v66, &v32);
          CDB::Bind(&v27);
          CDB::Bind(&v21);
          if ( CDB::Execute(
                 &v66,
                 "SELECT [Relation], [Name], [RPID], [RUID], [Class], [Level] FROM MLM WHERE [PID] = %d ORDER BY [Relation]",
                 nPID) )
          {
            while ( CDB::Fetch(&v66) )
            {
              packet = PutNumeric<unsigned char>(packet, v20);
              packet = PutString(packet, str);
              packet = (char *)PutNumeric<int>(packet, v28);
              packet = (char *)PutNumeric<int>(packet, v32);
              packet = PutNumeric<unsigned char>(packet, v27);
              packet = PutNumeric<unsigned char>(packet, v21);
              ++*v8;
            }
          }
          v8 = packet++;
          *v8 = 0;
          CDB::Reset(&v66);
          CDB::Bind(&v23);
          CDB::Bind(&v66, &v9);
          if ( CDB::Execute(&v66, "SELECT [Type],[Remain] FROM BuffRemain WHERE [PID] = %d", nPID) )
          {
            while ( CDB::Fetch(&v66) )
            {
              packet = PutNumeric<unsigned char>(packet, v23);
              packet = (char *)PutNumeric<int>(packet, v9);
              ++*v8;
            }
          }
          packet = (char *)PutNumeric<int>(packet, nLoadGID);
          if ( nLoadGID )
          {
            if ( v39 != nLoadGID )
            {
              LOG_ERR("CSocket::LoadPlayer() Load Guild Error (Load GID %d) (Curr. GID %d)", nLoadGID, v39);
              v60 = 2;
              goto LABEL_36;
            }
            packet = sub_418BA0(v39, v71, packet);
          }
          v60 = 1;
          goto LABEL_36;
        }
      }
    }
  }
LABEL_36:
  WritePacket(v59 + 3, "db", nId, (unsigned __int8)v60);
  *(_WORD *)v59 = (_WORD)packet - (_WORD)v59;
  *((_DWORD *)Src + 2000) = *(unsigned __int16 *)v59;
  CIOSocket::Write(this, (CIOBuffer *)Src);
  v70 = -1;
  CDB::~CDB(&v66);
}
// 41B150: using guessed type int __thiscall CDB::Skip(_DWORD);

//----- (00413CB0) --------------------------------------------------------
void __stdcall sub_413CB0(void *Src)
{
  int v1; // [esp+4h] [ebp-64h] BYREF
  int v2; // [esp+8h] [ebp-60h] BYREF
  unsigned __int8 v3; // [esp+Eh] [ebp-5Ah] BYREF
  unsigned __int8 v4; // [esp+Fh] [ebp-59h] BYREF
  unsigned __int16 v5; // [esp+10h] [ebp-58h] BYREF
  int v6; // [esp+14h] [ebp-54h] BYREF
  int v7; // [esp+18h] [ebp-50h] BYREF
  unsigned __int8 v8; // [esp+1Eh] [ebp-4Ah] BYREF
  char v9; // [esp+1Fh] [ebp-49h] BYREF
  unsigned __int16 v10; // [esp+20h] [ebp-48h] BYREF
  unsigned __int16 v11; // [esp+24h] [ebp-44h] BYREF
  unsigned __int16 v12; // [esp+28h] [ebp-40h] BYREF
  int nID1; // [esp+2Ch] [ebp-3Ch] BYREF
  unsigned __int8 v14; // [esp+31h] [ebp-37h] BYREF
  unsigned __int8 v15; // [esp+32h] [ebp-36h] BYREF
  unsigned __int8 v16; // [esp+33h] [ebp-35h] BYREF
  unsigned __int16 v17[3]; // [esp+34h] [ebp-34h] BYREF
  unsigned __int8 v18; // [esp+3Ah] [ebp-2Eh] BYREF
  unsigned __int8 v19; // [esp+3Bh] [ebp-2Dh] BYREF
  __int64 v20; // [esp+3Ch] [ebp-2Ch] BYREF
  CDB v21; // [esp+48h] [ebp-20h] BYREF
  unsigned __int8 v22; // [esp+5Ah] [ebp-Eh] BYREF
  unsigned __int8 v23; // [esp+5Bh] [ebp-Dh] BYREF
  int v24; // [esp+64h] [ebp-4h]

  ReadPacket(
    (char *)Src,
    "dbbwIbbbbbbwwwwbbddddb",
    &nID1,
    &v8,
    &v22,
    v17,
    &v20,
    &v14,
    &v19,
    &v18,
    &v16,
    &v3,
    &v4,
    &v10,
    &v5,
    &v11,
    &v12,
    &v23,
    &v15,
    &v1,
    &v2,
    &v6,
    &v7,
    &v9);
  CDB::CDB(&v21);
  v24 = 0;
  if ( CDB::Execute(
         &v21,
         "UPDATE Player SET [Level] = %d, [Specialty] = %d, [Contribute] = %d, [Exp] = %I64d, [GRole] = %d, [Strength] = "
         "%d, [Health] = %d, [Intelligence] = %d, [Wisdom] = %d, [Dexterity] = %d, [CurHP] = %d, [CurMP] = %d, [PUPoint] "
         "= %d, [SUPoint] = %d, [Killed] = %d, [Map] = %d, [X] = %d, [Y] = %d, [Z] = %d, [Rage] = %d WHERE [PID] = %d",
         v8,
         v22,
         v17[0],
         v20,
         v14,
         v19,
         v18,
         v16,
         v3,
         v4,
         v10,
         v5,
         v11,
         v12,
         v23,
         v15,
         v1,
         v2,
         v6,
         v7,
         nID1)
    && v9 )
  {
    CDB::Reset(&v21);
    CDB::ExecuteNoData(&v21, "UPDATE MLM SET [Level] = %d WHERE [RPID] = %d AND [Relation] <> %d", v8, nID1, 0);
    LOG_DB(0, 18, nID1, 0, 0, 26, v8, 0, 0);
    LOG_DB(0, 18, nID1, 0, 0, 23, v11, 0, 0);
    LOG_DB(0, 18, nID1, 0, 0, 24, v12, 0, 0);
  }
  v24 = -1;
  CDB::~CDB(&v21);
}

//----- (00413E80) --------------------------------------------------------
void __thiscall CSocket::DeleteItem(CSocket *this, int nIID, int nPID, int nIndex, int nNum, int nVal1, int nVal2, int nLogType)
{
  CDB v8; // [esp+10h] [ebp-1Ch] BYREF
  int v9; // [esp+28h] [ebp-4h]
  int v10; // [esp+50h] [ebp+24h]
  int v11; // [esp+54h] [ebp+28h]

  CDB::CDB(&v8);
  v9 = 0;
  if ( CDB::ExecuteNoData(&v8, "DELETE FROM Item WHERE [IID] = %d", nPID) )
    LOG_DB(1, nVal2, nIndex, v11, nPID, nNum, nVal1, nLogType, v10);
  v9 = -1;
  CDB::~CDB(&v8);
}

//----- (00413F50) --------------------------------------------------------
void __thiscall CSocket::PutOnItem(CSocket *this, int nIID)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v2);
  v3 = 0;
  CDB::Execute(&v2, "UPDATE Item SET [Info] = [Info] | %d WHERE [IID] = %d", 1, nIID);
  v3 = -1;
  CDB::~CDB(&v2);
}

//----- (00413FC0) --------------------------------------------------------
void __thiscall CSocket::PutOffItem(CSocket *this, int nIID)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v2);
  v3 = 0;
  CDB::Execute(&v2, "UPDATE Item SET [Info] = [Info] & %d WHERE [IID] = %d", -2, nIID);
  v3 = -1;
  CDB::~CDB(&v2);
}

//----- (00414030) --------------------------------------------------------
void __thiscall CSocket::InsertItem(CSocket *this, char *packet)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]
  int nVal1; // [esp+2Ch] [ebp+Ch]
  int v5; // [esp+30h] [ebp+10h]
  int v6; // [esp+34h] [ebp+14h]
  int nVal2; // [esp+38h] [ebp+18h]
  int v8; // [esp+3Ch] [ebp+1Ch]
  int v9; // [esp+40h] [ebp+20h]
  int nID1; // [esp+44h] [ebp+24h]
  int nType; // [esp+48h] [ebp+28h]

  if ( packet && abs((int)&packet[-CSocket::s_nIID]) <= 1000 )
  {
    CSocket::s_nIID = (int)packet;
    CDB::CDB(&v2);
    v3 = 0;
    CDB::Execute(
      &v2,
      "INSERT INTO Item ( [PID], [IID], [Index], [Prefix], [Info], [Num], [MaxEnd], [CurEnd], [SetGem]) VALUES ( %d, %d, "
      "%d, %d, %d, %d, %d, %d, %d)",
      nID1,
      packet,
      nVal1,
      v5,
      v6,
      nVal2,
      v8,
      v8,
      v9);
    LOG_DB(2, nType, nID1, 0, (int)packet, nVal1, nVal2, 0, 0);
    v3 = -1;
    CDB::~CDB(&v2);
  }
  else
  {
    LOG_ERR("CSocket::InsertItem() Invalid IID(%X)", packet);
  }
}

//----- (00414120) --------------------------------------------------------
void __thiscall CSocket::UpdateItemPID(CSocket *this, int nIID, int nOldPID, int nNewPID, int nIndex, int nNum, int nLogType)
{
  CDB v7; // [esp+4h] [ebp-1Ch] BYREF
  int v8; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v7);
  v8 = 0;
  if ( nLogType == 10 )
  {
    if ( nNewPID )
      CDB::Execute(&v7, "UPDATE Item SET [PID] = %d, [Info] = [Info] & %d WHERE [IID] = %d", nNewPID, -5, nIID);
    else
      CDB::Execute(&v7, "UPDATE Item SET [PID] = %d, [Info] = [Info] | %d WHERE [IID] = %d", 0, 4, nIID);
  }
  else
  {
    CDB::Execute(&v7, "UPDATE Item SET [PID] = %d WHERE [IID] = %d", nNewPID, nIID);
  }
  LOG_DB(3, nLogType, nOldPID, nNewPID, nIID, nIndex, nNum, 0, 0);
  v8 = -1;
  CDB::~CDB(&v7);
}

//----- (00414200) --------------------------------------------------------
void __thiscall CSocket::UpdateItemNum(CSocket *this, int nIID, int nPID, int nIndex, int nNum, int nLogType)
{
  CDB v6; // [esp+4h] [ebp-1Ch] BYREF
  int v7; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v6);
  v7 = 0;
  CDB::Execute(&v6, "UPDATE Item SET [Num] = [Num] + %d WHERE [IID] = %d", nNum, nIID);
  if ( nLogType != 9 && nLogType != 41 && (nLogType != 25 && nLogType != 12 && nLogType != 11 || abs(nNum) >= 1000) )
    LOG_DB(4, nLogType, nPID, 0, nIID, nIndex, nNum, 0, 0);
  v7 = -1;
  CDB::~CDB(&v6);
}

//----- (004142C0) --------------------------------------------------------
void __thiscall CSocket::InsertSkill(CSocket *this, int nPID, int nSkill, int nSUPoint)
{
  CDB v4; // [esp+4h] [ebp-1Ch] BYREF
  int v5; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v4);
  v5 = 0;
  CDB::Execute(&v4, "INSERT INTO Skill VALUES ( %d, %d, 1)", nPID, nSkill);
  LOG_DB(0, 14, nPID, 0, 0, nSkill, 1, 0, 0);
  CDB::Reset(&v4);
  CDB::Execute(&v4, "UPDATE Player SET [SUPoint] = %d WHERE [PID] = %d", nSUPoint, nPID);
  LOG_DB(0, 18, nPID, 0, 0, 24, nSUPoint, 0, 0);
  v5 = -1;
  CDB::~CDB(&v4);
}

//----- (00414390) --------------------------------------------------------
void __thiscall CSocket::SkillUp(CSocket *this, int nPID, int nSkill, int nLevel, int nSUPoint)
{
  CDB v5; // [esp+4h] [ebp-1Ch] BYREF
  int v6; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v5);
  v6 = 0;
  CDB::Execute(&v5, "UPDATE Skill SET [Level] = [Level] + 1 WHERE [PID] = %d AND [Index] = %d", nPID, nSkill);
  LOG_DB(0, 14, nPID, 0, 0, nSkill, nLevel, 0, 0);
  if ( nSkill != 11 )
  {
    CDB::Reset(&v5);
    CDB::Execute(&v5, "UPDATE Player SET [SUPoint] = %d WHERE [PID] = %d", nSUPoint, nPID);
    LOG_DB(0, 18, nPID, 0, 0, 24, nSUPoint, 0, 0);
  }
  v6 = -1;
  CDB::~CDB(&v5);
}

//----- (00414460) --------------------------------------------------------
void __thiscall CSocket::PutInStorage(CSocket *this, int nIID, int nPID, int nUID, int nUpdateType, int nNum)
{
  CDB v6; // [esp+8h] [ebp-1Ch] BYREF
  int v7; // [esp+20h] [ebp-4h]

  CDB::CDB(&v6);
  v7 = 0;
  if ( nUpdateType )
  {
    if ( nUpdateType == 1 )
      CDB::Execute(&v6, "UPDATE Item SET [Num] = [Num] + %d WHERE [IID] = %d", nNum, nIID);
  }
  else
  {
    CDB::Execute(
      &v6,
      "UPDATE Item SET [PID] = %d, [Info] = ( [Info] & %d) | %d WHERE [IID] = %d",
      nUID,
      2097128,
      16,
      nIID);
  }
  LOG_DB(5, 15, nPID, nUID, nIID, 0, 0, nNum, nUpdateType);
  v7 = -1;
  CDB::~CDB(&v6);
}

//----- (00414520) --------------------------------------------------------
void __thiscall CSocket::PutOutStorage(CSocket *this, int nIID, int nPID, int nUpdateType, int nNum)
{
  CDB v5; // [esp+8h] [ebp-1Ch] BYREF
  int v6; // [esp+20h] [ebp-4h]

  CDB::CDB(&v5);
  v6 = 0;
  if ( nUpdateType )
  {
    if ( nUpdateType == 1 )
    {
      CDB::Execute(&v5, "UPDATE Item SET [Num] = [Num] - %d WHERE [IID] = %d", nNum, nIID);
    }
    else if ( nUpdateType == 2 )
    {
      CDB::Execute(&v5, "DELETE FROM Item WHERE [IID] = %d", nIID);
    }
  }
  else
  {
    CDB::Execute(&v5, "UPDATE Item SET [PID] = %d, [Info] = [Info] & %d WHERE [IID] = %d", nPID, -17, nIID);
  }
  LOG_DB(6, 15, nPID, 0, nIID, 0, 0, -nNum, nUpdateType);
  v6 = -1;
  CDB::~CDB(&v5);
}

//----- (00414600) --------------------------------------------------------
void __thiscall CSocket::InsertQuestFlag(CSocket *this, int nPID, int nQuest, int nFlag, int bClear)
{
  CDB v5; // [esp+4h] [ebp-1Ch] BYREF
  int v6; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v5);
  v6 = 0;
  CDB::Execute(&v5, "INSERT INTO Quest VALUES ( %d, %d, %d, %d)", nPID, nQuest, nFlag, bClear);
  LOG_DB(7, 16, nPID, 0, 0, nQuest, nFlag, bClear, 0);
  v6 = -1;
  CDB::~CDB(&v5);
}

//----- (00414690) --------------------------------------------------------
void __thiscall CSocket::UpdateQuestFlag(CSocket *this, int nPID, int nQuest, int nFlag, int bClear)
{
  CDB v5; // [esp+4h] [ebp-1Ch] BYREF
  int v6; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v5);
  v6 = 0;
  CDB::Execute(
    &v5,
    "UPDATE Quest SET [Flag] = %d, [Clear] = %d WHERE [PID] = %d AND [Quest] = %d",
    nFlag,
    bClear,
    nPID,
    nQuest);
  LOG_DB(7, 16, nPID, 0, 0, nQuest, nFlag, bClear, 0);
  v6 = -1;
  CDB::~CDB(&v5);
}

//----- (00414720) --------------------------------------------------------
void __thiscall CSocket::SaveSpecialty(CSocket *this, int nPID, int nSpecialty)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::Execute(&v3, "UPDATE Player SET [Specialty] = [Specialty] | %d WHERE [PID] = %d", nSpecialty, nPID);
  LOG_DB(0, 17, nPID, 0, 0, nSpecialty, 0, 0, 0);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (004147B0) --------------------------------------------------------
void __thiscall CSocket::UpdateProperty(CSocket *this, int nPID, int nPrtyType, char *packet)
{
  unsigned __int16 v4; // [esp+8h] [ebp-38h] BYREF
  unsigned __int16 v5[3]; // [esp+Ch] [ebp-34h] BYREF
  unsigned __int8 v6; // [esp+13h] [ebp-2Dh] BYREF
  unsigned __int16 v7[3]; // [esp+14h] [ebp-2Ch] BYREF
  unsigned __int8 v8; // [esp+1Bh] [ebp-25h] BYREF
  unsigned __int8 v9; // [esp+1Ch] [ebp-24h] BYREF
  unsigned __int8 v10; // [esp+1Dh] [ebp-23h] BYREF
  unsigned __int8 v11; // [esp+1Eh] [ebp-22h] BYREF
  unsigned __int8 v12; // [esp+1Fh] [ebp-21h] BYREF
  int nVal2; // [esp+20h] [ebp-20h]
  CDB v14; // [esp+24h] [ebp-1Ch] BYREF
  int v15; // [esp+3Ch] [ebp-4h]
  char *Src; // [esp+50h] [ebp+10h]

  CDB::CDB(&v14);
  v15 = 0;
  while ( 2 )
  {
    switch ( nPrtyType )
    {
      case 0:
        ReadPacket(packet, "b", &v12);
        nVal2 = v12;
        CDB::Execute(&v14, "UPDATE Player SET [Strength] = %d WHERE [PID] = %d", v12, nPID);
        goto LABEL_12;
      case 1:
        ReadPacket(packet, "b", &v11);
        nVal2 = v11;
        CDB::Execute(&v14, "UPDATE Player SET [Health] = %d WHERE [PID] = %d", v11, nPID);
        goto LABEL_12;
      case 2:
        ReadPacket(packet, "b", &v10);
        nVal2 = v10;
        CDB::Execute(&v14, "UPDATE Player SET [Intelligence] = %d WHERE [PID] = %d", v10, nPID);
        goto LABEL_12;
      case 3:
        ReadPacket(packet, "b", &v9);
        nVal2 = v9;
        CDB::Execute(&v14, "UPDATE Player SET [Wisdom] = %d WHERE [PID] = %d", v9, nPID);
        goto LABEL_12;
      case 4:
        ReadPacket(packet, "b", &v8);
        nVal2 = v8;
        CDB::Execute(&v14, "UPDATE Player SET [Dexterity] = %d WHERE [PID] = %d", v8, nPID);
        goto LABEL_12;
      case 23:
        Src = ReadPacket(packet, "w", v7);
        CDB::Execute(&v14, "UPDATE Player SET [PUPoint] = %d WHERE [PID] = %d", v7[0], nPID);
        LOG_DB(0, 18, nPID, 0, 0, 23, v7[0], 0, 0);
        CDB::Reset(&v14);
        packet = ReadPacket(Src, "b", &v6);
        nPrtyType = v6;
        continue;
      case 24:
        ReadPacket(packet, "w", v5);
        nVal2 = v5[0];
        CDB::Execute(&v14, "UPDATE Player SET [SUPoint] = %d WHERE [PID] = %d", v5[0], nPID);
        goto LABEL_12;
      case 30:
        ReadPacket(packet, "w", &v4);
        nVal2 = v4;
        CDB::Execute(&v14, "UPDATE Player SET [Contribute] = %d WHERE [PID] = %d", v4, nPID);
LABEL_12:
        LOG_DB(0, 18, nPID, 0, 0, nPrtyType, nVal2, 0, 0);
        v15 = -1;
        CDB::~CDB(&v14);
        break;
      default:
        v15 = -1;
        CDB::~CDB(&v14);
        break;
    }
    break;
  }
}

//----- (00414AA0) --------------------------------------------------------
void __thiscall CSocket::UpdateItemXValue(CSocket *this, int nIID, int nPID, int nPrtyType, int nXValue)
{
  CDB v5; // [esp+8h] [ebp-1Ch] BYREF
  int v6; // [esp+20h] [ebp-4h]
  int v7; // [esp+3Ch] [ebp+18h]

  CDB::CDB(&v5);
  v6 = 0;
  switch ( nPrtyType )
  {
    case 9:
      CDB::Execute(&v5, "UPDATE Item SET [XHit] = %d WHERE [IID] = %d", nXValue, nIID);
      goto LABEL_7;
    case 10:
      CDB::Execute(&v5, "UPDATE Item SET [XDodge] = %d WHERE [IID] = %d", nXValue, nIID);
      goto LABEL_7;
    case 15:
      CDB::Execute(&v5, "UPDATE Item SET [XDefense] = %d WHERE [IID] = %d", nXValue, nIID);
      goto LABEL_7;
    case 27:
      CDB::Execute(&v5, "UPDATE Item SET [XAttack] = %d WHERE [IID] = %d", nXValue, nIID);
      goto LABEL_7;
    case 28:
      CDB::Execute(&v5, "UPDATE Item SET [XMagic] = %d WHERE [IID] = %d", nXValue, nIID);
LABEL_7:
      LOG_DB(9, 21, nPID, 0, nIID, nPrtyType, nXValue, 0, 0);
      if ( v7 )
        sub_414E10(nIID, nPID, 64, 0, &nPrtyType);
      break;
    default:
      break;
  }
  v6 = -1;
  CDB::~CDB(&v5);
}

//----- (00414C20) --------------------------------------------------------
void __thiscall CSocket::UpdateItemEnd(CSocket *this, int nIID, int nPID, int nCurEnd)
{
  CDB v4; // [esp+4h] [ebp-1Ch] BYREF
  int v5; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v4);
  v5 = 0;
  CDB::Execute(&v4, "UPDATE Item SET [CurEnd] = %d WHERE [IID] = %d", nCurEnd, nIID);
  LOG_DB(9, 23, nPID, 0, nIID, nCurEnd, 0, 0, 0);
  v5 = -1;
  CDB::~CDB(&v4);
}

//----- (00414CB0) --------------------------------------------------------
void __thiscall CSocket::UpdateItemPrefix(CSocket *this, int nIID, int nPID, int nNewPrefix)
{
  int Src; // [esp+4h] [ebp-20h] BYREF
  CDB v5; // [esp+8h] [ebp-1Ch] BYREF
  int v6; // [esp+20h] [ebp-4h]
  int v7; // [esp+38h] [ebp+14h]

  CDB::CDB(&v5);
  v6 = 0;
  CDB::Execute(&v5, "UPDATE Item SET [Prefix] = %d WHERE [IID] = %d", nNewPrefix, nIID);
  LOG_DB(9, 27, nPID, 0, nIID, nNewPrefix, 0, 0, 0);
  if ( v7 )
  {
    Src = 255;
    sub_414E10(nIID, nPID, 64, 0, &Src);
  }
  v6 = -1;
  CDB::~CDB(&v5);
}

//----- (00414D60) --------------------------------------------------------
void __thiscall CSocket::UpdateTransformItem(CSocket *this, int nIID, int nPID, int nExp, int nLevel, int bLevelUp)
{
  CDB v6; // [esp+4h] [ebp-1Ch] BYREF
  int v7; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v6);
  v7 = 0;
  if ( bLevelUp )
  {
    CDB::Execute(&v6, "UPDATE Item SET [Num] = %d, [MaxEnd] = %d WHERE [IID] = %d", nExp, nLevel, nIID);
    LOG_DB(10, 29, nPID, 0, nIID, nExp, nLevel, 0, 0);
  }
  else
  {
    CDB::Execute(&v6, "UPDATE Item SET [Num] = %d WHERE [IID] = %d", nExp, nIID);
  }
  v7 = -1;
  CDB::~CDB(&v6);
}

//----- (00414E10) --------------------------------------------------------
void __stdcall sub_414E10(int a1, int a2, int a3, int a4, void *Src)
{
  unsigned __int8 v5; // [esp+7h] [ebp-2Dh] BYREF
  unsigned __int16 v6; // [esp+8h] [ebp-2Ch] BYREF
  int nVal3; // [esp+Ch] [ebp-28h] BYREF
  int nVal4; // [esp+10h] [ebp-24h] BYREF
  unsigned __int8 v9; // [esp+17h] [ebp-1Dh] BYREF
  CDB v10; // [esp+18h] [ebp-1Ch] BYREF
  int v11; // [esp+30h] [ebp-4h]

  CDB::CDB(&v10);
  v11 = 0;
  if ( a4 )
  {
    ReadPacket((char *)Src, "wddb", &v6, &nVal3, &nVal4, &v9);
    CDB::Execute(&v10, "UPDATE Item SET [Info] = [Info] | %d WHERE [IID] = %d", a3, a1);
    if ( ((a3 & 0x40) == 0 || !v9) && (a3 & 0x7FF00) == 0 )
      LOG_ERR("CSocket::UpdateItemInfo() Protect Number Error (PID:%d, IID:%d, Info:%d)", a2, a1, a3);
    if ( (a3 & 0x40) != 0 )
    {
      CDB::Reset(&v10);
      CDB::Execute(&v10, "UPDATE Item SET [Protect] = %d WHERE [IID] = %d", v9, a1);
    }
    LOG_DB(9, 44, a2, 1, a1, a3, v6, nVal3, nVal4);
  }
  else
  {
    ReadPacket((char *)Src, "b", &v5);
    CDB::Execute(&v10, "UPDATE Item SET [Info] = [Info] & %d WHERE [IID] = %d", ~a3, a1);
    LOG_DB(9, 44, a2, 0, a1, a3, v5, 0, 0);
  }
  v11 = -1;
  CDB::~CDB(&v10);
}

//----- (00414F80) --------------------------------------------------------
void __stdcall sub_414F80(int a1, int a2, int a3, int a4)
{
  CDB v4; // [esp+8h] [ebp-1Ch] BYREF
  int v5; // [esp+20h] [ebp-4h]

  CDB::CDB(&v4);
  v5 = 0;
  if ( a3 == 1 )
  {
    CDB::Execute(&v4, "UPDATE Item SET [UpgrRate] = %d WHERE [IID] = %d", a4, a1);
    LOG_DB(13, 46, a2, 0, a1, 1, a4, 0, 0);
  }
  else if ( a3 == 2 )
  {
    CDB::Execute(&v4, "UPDATE Item SET [UpgrLevel] = %d, [UpgrRate] = 0 WHERE [IID] = %d", a4, a1);
    LOG_DB(13, 47, a2, 0, a1, 2, a4, 0, 0);
  }
  v5 = -1;
  CDB::~CDB(&v4);
}

//----- (00415070) --------------------------------------------------------
void __thiscall CSocket::SkillRedistribute(CSocket *this, int nPID, int nSkill, int nLevel, int nSUPoint)
{
  CDB v5; // [esp+4h] [ebp-1Ch] BYREF
  int v6; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v5);
  v6 = 0;
  if ( nLevel )
  {
    CDB::Execute(&v5, "UPDATE Skill SET [Level] = %d WHERE [PID] = %d AND [Index] = %d", nLevel, nPID, nSkill);
    LOG_DB(0, 30, nPID, 0, 0, nSkill, nLevel, 0, 0);
  }
  else
  {
    CDB::Execute(&v5, "DELETE Skill WHERE [PID] = %d AND [Index] = %d", nPID, nSkill);
    LOG_DB(0, 30, nPID, 0, 0, nSkill, 0, 0, 0);
  }
  CDB::Reset(&v5);
  CDB::Execute(&v5, "UPDATE Player SET [SUPoint] = %d WHERE [PID] = %d", nSUPoint, nPID);
  LOG_DB(0, 18, nPID, 0, 0, 24, nSUPoint, 0, 0);
  v6 = -1;
  CDB::~CDB(&v5);
}

//----- (00415180) --------------------------------------------------------
void __stdcall sub_415180(int a1, int a2, int a3, int a4)
{
  CDB v4; // [esp+8h] [ebp-1Ch] BYREF
  int v5; // [esp+20h] [ebp-4h]

  CDB::CDB(&v4);
  v5 = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      CDB::Execute(&v4, "DELETE BuffRemain WHERE [PID] = %d AND [Type] = %d", a1, a2);
    }
    else if ( a4 == 2 )
    {
      CDB::Execute(&v4, "UPDATE BuffRemain SET [Remain] = %d WHERE [PID] = %d AND [Type] = %d", a3, a1, a2);
    }
  }
  else
  {
    CDB::Execute(&v4, "INSERT INTO BuffRemain VALUES( %d, %d, %d)", a1, a2, a3);
  }
  v5 = -1;
  CDB::~CDB(&v4);
}

//----- (00415240) --------------------------------------------------------
void __thiscall sub_415240(void *this, int a2, int a3, void *Src)
{
  int v8; // [esp+8h] [ebp-FCh] BYREF
  unsigned __int8 v9; // [esp+Fh] [ebp-F5h] BYREF
  char TargetValue[184]; // [esp+10h] [ebp-F4h] BYREF
  char v11[4]; // [esp+CCh] [ebp-38h] BYREF
  char v12[4]; // [esp+D0h] [ebp-34h] BYREF
  int v13; // [esp+D4h] [ebp-30h] BYREF
  unsigned __int8 v14; // [esp+D9h] [ebp-2Bh] BYREF
  unsigned __int8 v15; // [esp+DAh] [ebp-2Ah] BYREF
  unsigned __int8 v16; // [esp+DBh] [ebp-29h] BYREF
  int v17; // [esp+DCh] [ebp-28h] BYREF
  const char *v18; // [esp+E0h] [ebp-24h] BYREF
  int v19; // [esp+E4h] [ebp-20h] BYREF
  CDB v20; // [esp+E8h] [ebp-1Ch] BYREF
  int v21; // [esp+100h] [ebp-4h]

  CDB::CDB(&v20);
  v21 = 0;
  switch ( a2 )
  {
    case 0:
      ReadPacket((char *)Src, "ddbsbb", &v17, &v19, &v14, &v18, &v16, &v15);
      CDB::Execute(&v20, "INSERT INTO MLM VALUES ( %d, %d, '%s', %d, %d, %d, %d)", a3, v14, v18, v17, v19, v16, v15);
      break;
    case 1:
      ReadPacket((char *)Src, "d", &v13);
      CDB::ExecuteNoData(&v20, "DELETE FROM MLM WHERE [PID] = %d AND [Relation] = %d AND [RPID] = %d", a3, 4, v13);
      break;
    case 2:
      CDB::ExecuteNoData(
        &v20,
        "DELETE FROM MLM WHERE ( [PID] = %d AND [Relation] IN ( %d, %d, %d)) OR ( [Relation] = %d AND [RPID] = %d)",
        a3,
        1,
        2,
        3,
        3,
        a3);
      CDB::Reset(&v20);
      CDB::ExecuteNoData(
        &v20,
        "DELETE FROM MLM WHERE [PID] IN ( SELECT [RPID] FROM MLM WHERE [PID] = %d AND [Relation] = %d) AND [Relation] = %d",
        a3,
        4,
        1);
      break;
    case 3:
      ReadPacket((char *)Src, "d", v12);
      if ( !CDB::ExecuteNoData(
              &v20,
              "UPDATE MLM SET [RPID] = [RPID] + %d WHERE [PID] = %d AND [Relation] = %d",
              *(_DWORD *)v12,
              a3,
              0) )
      {
        CDB::Reset(&v20);
        CDB::Execute(&v20, "INSERT INTO MLM VALUES ( %d, %d, '', %d, 0, 0, 0)", a3, 0, *(_DWORD *)v12);
      }
      break;
    case 4:
      ReadPacket((char *)Src, "s", v11);
      if ( !CDB::ExecuteNoData(&v20, "UPDATE MLMMsg SET [Msg] = '%s' WHERE [PID] = %d", *(const char **)v11, a3) )
      {
        CDB::Reset(&v20);
        CDB::Execute(&v20, "INSERT INTO MLMMsg VALUES ( %d, '%s')", a3, *(const char **)v11);
      }
      break;
    case 5:
      ReadPacket((char *)Src, "bd", &v9, &v8);
      CDB::Bind(&v20, TargetValue, 181);
      if ( CDB::Execute(&v20, "SELECT [Msg] FROM MLMMsg WHERE [PID] = %d", a3) && CDB::Fetch(&v20) )
        CSocket::Write((int)this, 8, "dbbbs", v8, 5, 8, v9, TargetValue);
      break;
    default:
      break;
  }
  v21 = -1;
  CDB::~CDB(&v20);
}

//----- (00415500) --------------------------------------------------------
void __thiscall sub_415500(void *this, int a2, int a3, void *Src)
{
  char *v7; // eax
  char *packet; // [esp+8h] [ebp-64h]
  char str[20]; // [esp+Ch] [ebp-60h] BYREF
  CIOBuffer *v11; // [esp+24h] [ebp-48h]
  int n; // [esp+28h] [ebp-44h] BYREF
  int v13; // [esp+2Ch] [ebp-40h]
  CIOBuffer *pBuffer; // [esp+30h] [ebp-3Ch]
  int i; // [esp+34h] [ebp-38h]
  unsigned __int8 v16; // [esp+3Bh] [ebp-31h] BYREF
  int v17; // [esp+3Ch] [ebp-30h] BYREF
  const char *v18; // [esp+40h] [ebp-2Ch] BYREF
  int TargetValue; // [esp+44h] [ebp-28h] BYREF
  const char *v20; // [esp+48h] [ebp-24h] BYREF
  int v21; // [esp+4Ch] [ebp-20h] BYREF
  CDB v22; // [esp+50h] [ebp-1Ch] BYREF
  int v23; // [esp+68h] [ebp-4h]
  char *Srca; // [esp+7Ch] [ebp+10h]

  CDB::CDB(&v22);
  v23 = 0;
  switch ( a2 )
  {
    case 0:
      ReadPacket((char *)Src, "ds", &v21, &v20);
      CDB::Execute(&v22, "INSERT INTO Friend VALUES ( %d, %d, '%s')", a3, v21, v20);
      break;
    case 1:
      Srca = ReadPacket((char *)Src, "b", &v16);
      for ( i = 0; i < v16; ++i )
      {
        Srca = ReadPacket(Srca, "d", &v17);
        CDB::Execute(&v22, "DELETE Friend WHERE [PID] = %d AND [FPID] = %d", a3, v17);
      }
      break;
    case 2:
      TargetValue = 0;
      ReadPacket((char *)Src, "s", &v18);
      CDB::Bind(&v22, &TargetValue);
      CDB::Execute(&v22, "SELECT [PID] FROM Player WHERE [Name] = '%s' AND [UID] <> 0", v18);
      CDB::Fetch(&v22);
      CSocket::Write((int)this, 24, "dbds", a3, 2, TargetValue, v18);
      break;
    case 3:
      pBuffer = CIOBuffer::Alloc();
      v11 = pBuffer;
      pBuffer->m_buffer[2] = 24;
      packet = &v11->m_buffer[9];
      v13 = 0;
      CDB::Bind(&v22, &n);
      CDB::Bind(&v22, str, 17);
      if ( CDB::Execute(&v22, "SELECT TOP %d [FPID], [FName] FROM Friend WHERE [PID] = %d", 30, a3) )
      {
        while ( CDB::Fetch(&v22) )
        {
          v7 = (char *)PutNumeric<int>(packet, n);
          packet = PutString(v7, str);
          ++v13;
        }
      }
      if ( v13 )
      {
        WritePacket(&v11->m_buffer[3], "dbb", a3, 3, v13);
        *(_WORD *)v11->m_buffer = (_WORD)packet - (_WORD)v11;
        pBuffer->m_dwSize = *(unsigned __int16 *)v11->m_buffer;
        CIOSocket::Write((CIOSocket *)this, pBuffer);
      }
      else
      {
        CIOBuffer::Release(pBuffer);
      }
      break;
    default:
      break;
  }
  v23 = -1;
  CDB::~CDB(&v22);
}

//----- (00415790) --------------------------------------------------------
void __thiscall sub_415790(void *this, int a2, int a3, void *Src)
{
  __time32_t v7; // eax
  __time32_t v8; // eax
  int v9; // [esp-4h] [ebp-390h]
  char v11; // [esp+Fh] [ebp-37Dh] BYREF
  unsigned __int16 v12; // [esp+10h] [ebp-37Ch] BYREF
  int v13; // [esp+14h] [ebp-378h] BYREF
  int v14; // [esp+18h] [ebp-374h] BYREF
  unsigned __int8 v15; // [esp+1Fh] [ebp-36Dh] BYREF
  int v16; // [esp+20h] [ebp-36Ch] BYREF
  unsigned __int8 v17; // [esp+27h] [ebp-365h] BYREF
  int v18; // [esp+28h] [ebp-364h] BYREF
  unsigned __int16 v19[2]; // [esp+2Ch] [ebp-360h] BYREF
  unsigned __int8 v20; // [esp+31h] [ebp-35Bh] BYREF
  unsigned __int8 v21; // [esp+32h] [ebp-35Ah] BYREF
  unsigned __int8 v22; // [esp+33h] [ebp-359h] BYREF
  int v23; // [esp+34h] [ebp-358h] BYREF
  int v24; // [esp+38h] [ebp-354h] BYREF
  unsigned __int8 v25; // [esp+3Fh] [ebp-34Dh] BYREF
  unsigned __int8 v26; // [esp+40h] [ebp-34Ch] BYREF
  unsigned __int8 v27; // [esp+41h] [ebp-34Bh] BYREF
  unsigned __int8 v28; // [esp+42h] [ebp-34Ah] BYREF
  unsigned __int8 v29; // [esp+43h] [ebp-349h] BYREF
  unsigned __int8 v30; // [esp+44h] [ebp-348h] BYREF
  unsigned __int8 v31; // [esp+45h] [ebp-347h] BYREF
  unsigned __int8 v32; // [esp+46h] [ebp-346h] BYREF
  unsigned __int8 v33; // [esp+47h] [ebp-345h] BYREF
  int v34; // [esp+48h] [ebp-344h] BYREF
  int v35[2]; // [esp+4Ch] [ebp-340h] BYREF
  int v36; // [esp+54h] [ebp-338h] BYREF
  int v37; // [esp+58h] [ebp-334h] BYREF
  unsigned __int16 v38[2]; // [esp+5Ch] [ebp-330h] BYREF
  unsigned __int8 v39; // [esp+61h] [ebp-32Bh] BYREF
  unsigned __int8 v40; // [esp+62h] [ebp-32Ah] BYREF
  unsigned __int8 v41; // [esp+63h] [ebp-329h] BYREF
  int v42; // [esp+64h] [ebp-328h] BYREF
  int v43; // [esp+68h] [ebp-324h] BYREF
  unsigned __int8 v44; // [esp+6Fh] [ebp-31Dh] BYREF
  unsigned __int8 v45; // [esp+70h] [ebp-31Ch] BYREF
  unsigned __int8 v46; // [esp+71h] [ebp-31Bh] BYREF
  unsigned __int8 v47; // [esp+72h] [ebp-31Ah] BYREF
  unsigned __int8 v48; // [esp+73h] [ebp-319h] BYREF
  unsigned __int8 v49; // [esp+74h] [ebp-318h] BYREF
  unsigned __int8 v50; // [esp+75h] [ebp-317h] BYREF
  unsigned __int8 v51; // [esp+76h] [ebp-316h] BYREF
  unsigned __int8 v52; // [esp+77h] [ebp-315h] BYREF
  char v53[520]; // [esp+78h] [ebp-314h] BYREF
  SQLINTEGER StrLen_or_Ind; // [esp+280h] [ebp-10Ch] BYREF
  int v55; // [esp+284h] [ebp-108h] BYREF
  unsigned __int8 v56; // [esp+28Bh] [ebp-101h] BYREF
  __time32_t v57; // [esp+28Ch] [ebp-100h]
  int v58; // [esp+290h] [ebp-FCh] BYREF
  int v59; // [esp+294h] [ebp-F8h] BYREF
  unsigned __int16 v60; // [esp+298h] [ebp-F4h] BYREF
  int v61; // [esp+29Ch] [ebp-F0h] BYREF
  int v62; // [esp+2A0h] [ebp-ECh] BYREF
  char *packet; // [esp+2A4h] [ebp-E8h]
  char v64; // [esp+2AAh] [ebp-E2h] BYREF
  char v65; // [esp+2ABh] [ebp-E1h] BYREF
  int v66; // [esp+2ACh] [ebp-E0h] BYREF
  char TargetValue; // [esp+2B3h] [ebp-D9h] BYREF
  char str[20]; // [esp+2B4h] [ebp-D8h] BYREF
  char v69[20]; // [esp+2C8h] [ebp-C4h] BYREF
  int v70; // [esp+2E0h] [ebp-ACh] BYREF
  int v71; // [esp+2E4h] [ebp-A8h] BYREF
  char v72; // [esp+2EBh] [ebp-A1h] BYREF
  CIOBuffer *v73; // [esp+2ECh] [ebp-A0h]
  char v74; // [esp+2F3h] [ebp-99h] BYREF
  __time32_t v75; // [esp+2F4h] [ebp-98h]
  int v76; // [esp+2F8h] [ebp-94h] BYREF
  int v77; // [esp+2FCh] [ebp-90h]
  int v78; // [esp+300h] [ebp-8Ch] BYREF
  int v79; // [esp+304h] [ebp-88h] BYREF
  CIOBuffer *pBuffer; // [esp+308h] [ebp-84h]
  unsigned __int16 v81; // [esp+30Ch] [ebp-80h] BYREF
  int v82; // [esp+310h] [ebp-7Ch] BYREF
  char v83; // [esp+317h] [ebp-75h] BYREF
  int v84; // [esp+318h] [ebp-74h] BYREF
  int nID2; // [esp+31Ch] [ebp-70h] BYREF
  int v86; // [esp+320h] [ebp-6Ch] BYREF
  unsigned __int8 v87; // [esp+327h] [ebp-65h] BYREF
  int v88; // [esp+328h] [ebp-64h] BYREF
  __time32_t v89; // [esp+32Ch] [ebp-60h]
  SQLINTEGER pcbValue; // [esp+330h] [ebp-5Ch] BYREF
  int v91; // [esp+334h] [ebp-58h]
  char *Str; // [esp+338h] [ebp-54h] BYREF
  __time32_t v93; // [esp+33Ch] [ebp-50h]
  int v94; // [esp+340h] [ebp-4Ch] BYREF
  unsigned __int16 v95; // [esp+344h] [ebp-48h] BYREF
  int nVal3; // [esp+348h] [ebp-44h] BYREF
  unsigned __int8 v97; // [esp+34Eh] [ebp-3Eh] BYREF
  unsigned __int8 v98; // [esp+34Fh] [ebp-3Dh] BYREF
  const char *v99; // [esp+350h] [ebp-3Ch] BYREF
  const char *v100; // [esp+354h] [ebp-38h] BYREF
  int v101; // [esp+358h] [ebp-34h] BYREF
  int nVal4; // [esp+35Ch] [ebp-30h] BYREF
  int n; // [esp+360h] [ebp-2Ch] BYREF
  unsigned __int8 v104; // [esp+366h] [ebp-26h] BYREF
  unsigned __int8 v105; // [esp+367h] [ebp-25h] BYREF
  int v106; // [esp+368h] [ebp-24h]
  int nIID; // [esp+36Ch] [ebp-20h] BYREF
  CDB v108; // [esp+370h] [ebp-1Ch] BYREF
  int v109; // [esp+388h] [ebp-4h]
  char *Srca; // [esp+39Ch] [ebp+10h]

  CDB::CDB(&v108);
  v109 = 0;
  switch ( a2 )
  {
    case 0:
      Srca = ReadPacket((char *)Src, "bbssdbwbdd", &v98, &v105, &v99, &v100, &nIID, &v104, &v95, &v97, &nVal3, &nVal4);
      v101 = 0;
      v106 = 0;
      n = 0;
      CDB::Bind(&v108, &n);
      if ( CDB::Execute(&v108, " SELECT [PID] FROM Player WHERE [Name] = '%s'", v100) && CDB::Fetch(&v108) )
      {
        v94 = 0;
        if ( v105 != 4 && v105 != 3 )
        {
          CDB::Reset(&v108);
          CDB::Bind(&v108, &v94);
          v7 = time(0);
          CDB::Execute(&v108, " SELECT COUNT(*) FROM Mail WHERE [RPID] = %d AND [TimetE] > %d", n, v7);
          CDB::Fetch(&v108);
        }
        if ( v94 >= 100 )
        {
          v106 = 1;
        }
        else
        {
          v91 = 2;
          v89 = time(0);
          v93 = v89;
          switch ( v105 )
          {
            case 0u:
            case 4u:
              v93 += 2592000;
              break;
            case 1u:
              v93 += nVal4 != 0 ? 3600 : 172800;
              break;
            case 3u:
              v93 = 0x7FFFFFFF;
              v91 = 0;
              break;
            default:
              break;
          }
          ReadPacket(Srca, "s", &Str);
          pcbValue = strlen(Str);
          CDB::Reset(&v108);
          sub_41B310(&v108.m_hStmt, 1u, 1, -2, -3, 0x200u, 0, Str, 512, &pcbValue);
          CDB::Execute(
            &v108,
            "INSERT INTO Mail ([TimetS], [TimetE], [Priority], [Type], [Status], [SPID], [SName], [RPID], [RName], [IID],"
            " [Ver], [Index], [Prefix], [Num], [Pay], [Msg])VALUES ( %d, %d, %d, %d, %d, %d, '%s', %d, '%s', %d, %d, %d, %d, %d, %d, ?)",
            v89,
            v93,
            v98,
            v105,
            v91,
            a3,
            v99,
            n,
            v100,
            v95 == 0 ? nIID : 0,
            v104,
            v95,
            v97,
            nVal3,
            nVal4);
          CDB::Reset(&v108);
          CDB::Bind(&v108, &v101);
          if ( CDB::Execute(&v108, "SELECT @@IDENTITY") && CDB::Fetch(&v108) )
            v106 = 0;
          if ( !v101 )
          {
            LOG_ERR(
              "CSocket::MAILProcess():MAIL_D_SEND:  not get mid  mailInfo(%d %s %s %d %d %d)",
              v105,
              v99,
              v100,
              nIID,
              v95,
              nVal3);
            v106 = 5;
          }
        }
      }
      else
      {
        v106 = 2;
      }
      if ( v105 == 3 )
        LOG_DB(14, 48, a3, n, nIID, v105, v95, nVal3, nVal4);
      else
        CSocket::Write(
          (int)this,
          25,
          "dbdbbdsdbwbdd",
          a3,
          1,
          v101,
          v105,
          v106,
          n,
          v100,
          nIID,
          v104,
          v95,
          v97,
          nVal3,
          nVal4);
      goto LABEL_67;
    case 1:
      ReadPacket((char *)Src, "dbbddwdd", &v84, &v83, &v87, &nID2, &v88, &v81, &v82, &v86);
      if ( v83 )
      {
        CDB::Execute(&v108, "DELETE Mail WHERE [MID] = %d", v84);
      }
      else
      {
        CDB::Execute(
          &v108,
          "UPDATE Mail SET [Status] = %d, [IID] = %d, [Index] = %d WHERE [MID] = %d",
          0,
          v81 == 0 ? v88 : 0,
          v81,
          v84);
        LOG_DB(14, 48, a3, nID2, v88, v87, v81, v82, v86);
      }
      goto LABEL_67;
    case 2:
      pBuffer = CIOBuffer::Alloc();
      v73 = pBuffer;
      pBuffer->m_buffer[2] = 25;
      packet = &v73->m_buffer[9];
      v75 = time(0);
      CDB::ExecuteNoData(
        &v108,
        "UPDATE Mail SET [Type] = %d, [Status] = %d, [SPID] = [RPID], [SName] = [RName], [RPID] = [SPID], [RName] = [SNam"
        "e], [TimetE] = %d, [Pay] = %d WHERE ([SPID] = %d OR [RPID] = %d) AND [Type] = %d AND [TimetE] <= %d AND [Status] IN( %d, %d)",
        2,
        0,
        0x7FFFFFFF,
        0,
        a3,
        a3,
        1,
        v75,
        0,
        1);
      v77 = 0;
      CDB::Reset(&v108);
      CDB::Bind(&v108, &v66);
      CDB::Bind(&TargetValue);
      CDB::Bind(&v74);
      CDB::Bind(&v64);
      CDB::Bind(&v108, &v61);
      CDB::Bind(&v108, str, 17);
      CDB::Bind(&v108, &v70);
      CDB::Bind(&v108, v69, 17);
      CDB::Bind(&v108, &v76);
      CDB::Bind(&v108, &v78);
      CDB::Bind(&v108, &v79);
      CDB::Bind(&v72);
      CDB::Bind(&v108, &v60);
      CDB::Bind(&v65);
      CDB::Bind(&v108, &v62);
      CDB::Bind(&v108, &v71);
      if ( CDB::Execute(
             &v108,
             "SELECT TOP %d [MID], [Priority], [Type], [Status], [SPID], [SName], [RPID], [RName], [TimetS], [TimetE], [I"
             "ID] , [Ver], [Index], [Prefix], [Num], [Pay] FROM Mail WHERE [RPID] = %d AND [TimetE] > %d AND [Status] IN( %d, %d)",
             50,
             a3,
             v75,
             0,
             1) )
      {
        while ( CDB::Fetch(&v108) )
        {
          packet = (char *)PutNumeric<int>(packet, v66);
          packet = PutNumeric<unsigned char>(packet, TargetValue);
          packet = PutNumeric<unsigned char>(packet, v74);
          packet = PutNumeric<unsigned char>(packet, v64);
          packet = (char *)PutNumeric<int>(packet, v61);
          packet = PutString(packet, str);
          packet = (char *)PutNumeric<int>(packet, v70);
          packet = PutString(packet, v69);
          packet = (char *)PutNumeric<int>(packet, v76);
          packet = (char *)PutNumeric<int>(packet, v78);
          packet = (char *)PutNumeric<int>(packet, v79);
          packet = PutNumeric<unsigned char>(packet, v72);
          packet = (char *)PutNumeric<short>(packet, v60);
          packet = PutNumeric<unsigned char>(packet, v65);
          packet = (char *)PutNumeric<int>(packet, v62);
          packet = (char *)PutNumeric<int>(packet, v71);
          ++v77;
        }
      }
      if ( v77 )
      {
        WritePacket(&v73->m_buffer[3], "dbb", a3, 3, v77);
        *(_WORD *)v73->m_buffer = (_WORD)packet - (_WORD)v73;
        pBuffer->m_dwSize = *(unsigned __int16 *)v73->m_buffer;
        CIOSocket::Write((CIOSocket *)this, pBuffer);
      }
      else
      {
        CIOBuffer::Release(pBuffer);
      }
      goto LABEL_67;
    case 3:
      ReadPacket((char *)Src, "d", &v59);
      CDB::ExecuteNoData(
        &v108,
        "UPDATE Mail SET [Type] = %d, [Status] = %d, [SPID] = [RPID], [SName] = [RName] , [RPID] = [SPID], [RName] = [SNa"
        "me], [TimetE] = %d, [Pay] = %d WHERE [MID] = %d AND [RPID] = %d AND [Type] = %d AND [Status] IN( %d, %d)",
        2,
        0,
        0x7FFFFFFF,
        0,
        v59,
        a3,
        1,
        0,
        1);
      goto LABEL_67;
    case 4:
      ReadPacket((char *)Src, "dbd", &v55, &v56, &v58);
      v57 = time(0);
      if ( v56 == 2 || v56 == 3 )
        CDB::ExecuteNoData(
          &v108,
          "UPDATE Mail SET [Status] = %d WHERE [MID] = %d AND [Type] IN( %d, %d) AND [Status] = %d",
          1,
          v55,
          2,
          3,
          0);
      else
        CDB::ExecuteNoData(
          &v108,
          "UPDATE Mail SET [Status] = %d, [TimetE] = %d WHERE [MID] = %d AND [Type] IN( %d, %d, %d) AND [Status] = %d",
          1,
          v57 + 3600,
          v55,
          0,
          1,
          4,
          0);
      CDB::Reset(&v108);
      StrLen_or_Ind = 0;
      sub_41B2B0((int)&v108, -2, v53, 512, &StrLen_or_Ind);
      if ( CDB::Execute(&v108, "SELECT [Msg] FROM Mail WHERE [MID] = %d AND [RPID] = %d", v55, a3) && CDB::Fetch(&v108) )
      {
        if ( v58 )
        {
          CDB::Reset(&v108);
          Concurrency::details::ExternalStatistics::IncrementDequeuedTaskCounter(
            (Concurrency::details::ExternalStatistics *)&v108,
            2u);
          CDB::Bind(&v108, v38);
          CDB::Bind(&v46);
          CDB::Bind(&v108, &v42);
          CDB::Bind(&v108, &v43);
          CDB::Bind(&v44);
          CDB::Bind(&v47);
          CDB::Bind(&v50);
          CDB::Bind(&v45);
          CDB::Bind(&v39);
          CDB::Bind(&v48);
          CDB::Bind(&v49);
          CDB::Bind(&v40);
          CDB::Bind(&v52);
          CDB::Bind(&v51);
          CDB::Bind(&v41);
          if ( CDB::Execute(&v108, "SELECT * FROM Item WHERE [IID] = %d", v58) && CDB::Fetch(&v108) )
            CSocket::Write(
              (int)this,
              25,
              "dbdbdwmwbddbbbbbbbbbbb",
              a3,
              7,
              v55,
              v56,
              v58,
              StrLen_or_Ind,
              v53,
              StrLen_or_Ind,
              v38[0],
              v46,
              v42,
              v43,
              v44,
              v47,
              v50,
              v45,
              v39,
              v48,
              v49,
              v40,
              v52,
              v51,
              v41);
        }
        else
        {
          CSocket::Write((int)this, 25, "dbdbdwm", a3, 7, v55, v56, 0, StrLen_or_Ind, v53, StrLen_or_Ind);
        }
      }
      else
      {
        CSocket::Write((int)this, 25, "dbdb", a3, 5, v55, 2);
      }
      goto LABEL_67;
    case 6:
      ReadPacket((char *)Src, "d", &v37);
      CDB::Execute(&v108, "DELETE Mail WHERE [MID] = %d AND [RPID] = %d", v37, a3);
      goto LABEL_67;
    case 7:
      ReadPacket((char *)Src, "dd", &v34, &v36);
      CDB::Reset(&v108);
      CDB::Bind(&v108, v35);
      if ( CDB::Execute(&v108, "SELECT [Status] FROM Mail WHERE [MID] = %d AND [RPID] = %d", v34, a3)
        && CDB::Fetch(&v108) )
      {
        if ( v35[0] == 3 )
        {
          CSocket::Write((int)this, 25, "dbdb", a3, 5, v34, 3);
          v109 = -1;
          CDB::~CDB(&v108);
          return;
        }
      }
      else
      {
        CSocket::Write((int)this, 25, "dbdb", a3, 5, v34, 2);
      }
      v35[1] = time(0);
      CDB::Reset(&v108);
      CDB::ExecuteNoData(
        &v108,
        "UPDATE Mail Set [Status] = %d WHERE [MID] = %d AND [RPID] = %d AND [Type] IN( %d, %d, %d) AND [TimetE] > %d",
        3,
        v34,
        a3,
        1,
        2,
        3,
        3);
      CDB::Reset(&v108);
      CDB::Bind(&v108, v35);
      if ( CDB::Execute(&v108, "SELECT [Status] FROM Mail WHERE [MID] = %d AND [RPID] = %d", v34, a3)
        && CDB::Fetch(&v108) )
      {
        if ( v35[0] != 3 )
        {
          CSocket::Write((int)this, 25, "dbdb", a3, 5, v34, 2);
          v109 = -1;
          CDB::~CDB(&v108);
          return;
        }
        if ( v36 )
        {
          CDB::Reset(&v108);
          Concurrency::details::ExternalStatistics::IncrementDequeuedTaskCounter(
            (Concurrency::details::ExternalStatistics *)&v108,
            2u);
          CDB::Bind(&v108, v19);
          CDB::Bind(&v27);
          CDB::Bind(&v108, &v23);
          CDB::Bind(&v108, &v24);
          CDB::Bind(&v25);
          CDB::Bind(&v28);
          CDB::Bind(&v31);
          CDB::Bind(&v26);
          CDB::Bind(&v20);
          CDB::Bind(&v29);
          CDB::Bind(&v30);
          CDB::Bind(&v21);
          CDB::Bind(&v33);
          CDB::Bind(&v32);
          CDB::Bind(&v22);
          if ( CDB::Execute(&v108, "SELECT * FROM Item WHERE [IID] = %d", v36) && CDB::Fetch(&v108) )
            CSocket::Write(
              (int)this,
              25,
              "dbddwdbddbbbbbbbbbbb",
              a3,
              11,
              v34,
              v36,
              v19[0],
              v36,
              v27,
              v23,
              v24,
              v25,
              v28,
              v31,
              v26,
              v20,
              v29,
              v30,
              v21,
              v33,
              v32,
              v22);
        }
        else
        {
          CSocket::Write((int)this, 25, "dbdd", a3, 11, v34, 0);
        }
      }
      else
      {
        CSocket::Write((int)this, 25, "dbdb", a3, 5, v34, 2);
      }
LABEL_67:
      v109 = -1;
      CDB::~CDB(&v108);
      return;
    case 8:
      ReadPacket((char *)Src, "dbbddwbd", &v16, &v11, &v17, &v13, &v18, &v12, &v15, &v14);
      if ( v11 )
      {
        CDB::Reset(&v108);
        CDB::Execute(&v108, "UPDATE Mail SET [Status] = %d WHERE [MID] = %d", 1, v16);
      }
      else
      {
        CDB::Reset(&v108);
        v9 = v16;
        v8 = time(0);
        CDB::Execute(
          &v108,
          "UPDATE Mail SET [Type] = %d, [Status] = %d, [TimetE] = %d, [IID] = %d, [Index] = %d, [Prefix] = %d, [Num] = %d"
          ", [Pay] = %d WHERE [MID] = %d",
          0,
          1,
          v8 + 86400,
          0,
          0,
          0,
          0,
          0,
          v9);
        LOG_DB(14, 51, a3, v13, v18, v17, v12, v15, v14);
      }
      goto LABEL_67;
    default:
      goto LABEL_67;
  }
}

//----- (004168C0) --------------------------------------------------------
void __thiscall sub_4168C0(void *this, int a2, int a3)
{
  int v6; // [esp+0h] [ebp-C0h]
  char v8[20]; // [esp+8h] [ebp-B8h] BYREF
  int v9; // [esp+1Ch] [ebp-A4h] BYREF
  char v10; // [esp+22h] [ebp-9Eh] BYREF
  char v11; // [esp+23h] [ebp-9Dh] BYREF
  int v12; // [esp+24h] [ebp-9Ch]
  CIOBuffer *pBuffer; // [esp+28h] [ebp-98h]
  CIOBuffer *v14; // [esp+2Ch] [ebp-94h]
  char v15; // [esp+33h] [ebp-8Dh] BYREF
  CDB v16; // [esp+34h] [ebp-8Ch] BYREF
  _BYTE *v17; // [esp+44h] [ebp-7Ch]
  unsigned __int16 v18; // [esp+48h] [ebp-78h] BYREF
  CDB v19; // [esp+4Ch] [ebp-74h] BYREF
  char v20; // [esp+5Eh] [ebp-62h] BYREF
  char v21; // [esp+5Fh] [ebp-61h] BYREF
  int v22; // [esp+60h] [ebp-60h] BYREF
  char *packet; // [esp+64h] [ebp-5Ch]
  char v24; // [esp+6Ah] [ebp-56h] BYREF
  char v25; // [esp+6Bh] [ebp-55h] BYREF
  int n; // [esp+6Ch] [ebp-54h] BYREF
  char TargetValue; // [esp+72h] [ebp-4Eh] BYREF
  char v28; // [esp+73h] [ebp-4Dh] BYREF
  char str[20]; // [esp+74h] [ebp-4Ch] BYREF
  char v30; // [esp+8Eh] [ebp-32h] BYREF
  char v31; // [esp+8Fh] [ebp-31h] BYREF
  int v32; // [esp+90h] [ebp-30h]
  int v33; // [esp+94h] [ebp-2Ch]
  char v34; // [esp+9Bh] [ebp-25h] BYREF
  CDB v35; // [esp+9Ch] [ebp-24h] BYREF
  char v36[4]; // [esp+ACh] [ebp-14h]
  void *Src; // [esp+B0h] [ebp-10h]
  int v38; // [esp+BCh] [ebp-4h]

  Src = CIOBuffer::Alloc();
  v32 = (int)Src;
  *((_BYTE *)Src + 2) = 0;
  packet = (char *)(v32 + 10);
  v33 = 0;
  CDB::CDB(&v35);
  v38 = 0;
  CDB::Bind(&v35, &n);
  CDB::Bind(&v35, str, 17);
  CDB::Bind(&TargetValue);
  CDB::Bind(&v24);
  CDB::Bind(&v35, &v22);
  CDB::Bind(&v34);
  CDB::Bind(&v30);
  CDB::Bind(&v28);
  CDB::Bind(&v20);
  CDB::Bind(&v21);
  CDB::Bind(&v31);
  CDB::Bind(&v25);
  if ( !CDBConfig::s_nEvent || CDBConfig::s_nEvent == 1 )
    v6 = 5;
  else
    v6 = 3;
  *(_DWORD *)v36 = v6;
  LOG_ERR(
    "SELECT TOP %d [PID], [Name], [Class], [Level], [GID], [Strength], [Health], [Intelligence], [Wisdom], [Dexterity], ["
    "Face], [Hair] FROM Player WHERE UID = %d ORDER BY [Level]",
    v6,
    a3);
  if ( CDB::Execute(
         &v35,
         "SELECT TOP %d [PID], [Name], [Class], [Level], [GID], [Strength], [Health], [Intelligence], [Wisdom], [Dexterit"
         "y], [Face], [Hair] FROM Player WHERE UID = %d ORDER BY [Level]",
         *(_DWORD *)v36,
         a3) )
  {
    while ( CDB::Fetch(&v35) )
    {
      packet = (char *)PutNumeric<int>(packet, n);
      packet = PutString(packet, str);
      packet = PutNumeric<unsigned char>(packet, TargetValue);
      packet = PutNumeric<unsigned char>(packet, v24);
      packet = (char *)PutNumeric<int>(packet, v22);
      packet = PutNumeric<unsigned char>(packet, v34);
      packet = PutNumeric<unsigned char>(packet, v30);
      packet = PutNumeric<unsigned char>(packet, v28);
      packet = PutNumeric<unsigned char>(packet, v20);
      packet = PutNumeric<unsigned char>(packet, v21);
      packet = PutNumeric<unsigned char>(packet, v31);
      v17 = PutNumeric<unsigned char>(packet, v25);
      packet = v17 + 1;
      *v17 = 0;
      CDB::CDB(&v19);
      LOBYTE(v38) = 1;
      CDB::Bind(&v19, &v18);
      LOG_ERR("SELECT TOP 13 [Index] FROM Item WHERE [PID] = %d AND ( [Info] & %d) = %d", n, 17, 1);
      if ( CDB::Execute(&v19, "SELECT TOP 13 [Index] FROM Item WHERE [PID] = %d AND ( [Info] & %d) = %d", n, 17, 1) )
      {
        while ( CDB::Fetch(&v19) )
        {
          packet = (char *)PutNumeric<short>(packet, v18);
          ++*v17;
        }
      }
      LOBYTE(v38) = 0;
      CDB::~CDB(&v19);
      ++v33;
    }
  }
  WritePacket((char *)(v32 + 3), "dbw", a2, v33, &packet[-v32 - 10]);
  *(_WORD *)v32 = (_WORD)packet - v32;
  *((_DWORD *)Src + 2000) = *(unsigned __int16 *)v32;
  CIOSocket::Write((CIOSocket *)this, (CIOBuffer *)Src);
  pBuffer = CIOBuffer::Alloc();
  v14 = pBuffer;
  pBuffer->m_buffer[2] = 29;
  packet = &v14->m_buffer[10];
  v12 = 0;
  CDB::CDB(&v16);
  LOBYTE(v38) = 2;
  CDB::Bind(&v16, &v9);
  CDB::Bind(&v16, v8, 17);
  CDB::Bind(&v10);
  CDB::Bind(&v11);
  CDB::Bind(&v15);
  LOG_ERR(
    "SELECT TOP 5 PlayerDeleted.PID, Name, [Level], Class, DayLeft = 14-datediff(dd, DeletedTime, getdate()) FROM PlayerD"
    "eleted, Player WHERE PlayerDeleted.UID = %d AND PlayerDeleted.PID= Player.PID ORDER BY DayLeft DESC",
    a3);
  if ( CDB::Execute(
         &v16,
         "SELECT TOP 5 PlayerDeleted.PID, Name, [Level], Class, DayLeft = 14-datediff(dd, DeletedTime, getdate()) FROM Pl"
         "ayerDeleted, Player WHERE PlayerDeleted.UID = %d AND PlayerDeleted.PID= Player.PID ORDER BY DayLeft DESC",
         a3) )
  {
    while ( CDB::Fetch(&v16) && v12 <= 5 )
    {
      packet = (char *)PutNumeric<int>(packet, v9);
      packet = PutString(packet, v8);
      packet = PutNumeric<unsigned char>(packet, v10);
      packet = PutNumeric<unsigned char>(packet, v11);
      packet = PutNumeric<unsigned char>(packet, v15);
      ++v12;
    }
  }
  WritePacket(&v14->m_buffer[3], "dbw", a2, v12, packet - &v14->m_buffer[10]);
  *(_WORD *)v14->m_buffer = (_WORD)packet - (_WORD)v14;
  pBuffer->m_dwSize = *(unsigned __int16 *)v14->m_buffer;
  CIOSocket::Write((CIOSocket *)this, pBuffer);
  LOBYTE(v38) = 0;
  CDB::~CDB(&v16);
  v38 = -1;
  CDB::~CDB(&v35);
}

//----- (00416E20) --------------------------------------------------------
void __thiscall CSocket::NewPlayer(CSocket *this, char *packet)
{
  tagRECT *v2; // edx
  int n; // [esp+4h] [ebp-70h] BYREF
  int i; // [esp+8h] [ebp-6Ch]
  int v6; // [esp+Ch] [ebp-68h] BYREF
  int v7; // [esp+10h] [ebp-64h]
  unsigned __int8 v8; // [esp+17h] [ebp-5Dh] BYREF
  int v9; // [esp+18h] [ebp-5Ch]
  int v10; // [esp+1Ch] [ebp-58h]
  int v11; // [esp+20h] [ebp-54h]
  int v12; // [esp+24h] [ebp-50h]
  int v13; // [esp+28h] [ebp-4Ch]
  unsigned __int8 v14; // [esp+2Eh] [ebp-46h] BYREF
  unsigned __int8 v15; // [esp+2Fh] [ebp-45h] BYREF
  const char *v16; // [esp+30h] [ebp-44h] BYREF
  int v17; // [esp+34h] [ebp-40h]
  int v18; // [esp+38h] [ebp-3Ch]
  unsigned __int8 v19; // [esp+3Ch] [ebp-38h] BYREF
  unsigned __int8 v20; // [esp+3Dh] [ebp-37h] BYREF
  unsigned __int8 v21; // [esp+3Eh] [ebp-36h] BYREF
  unsigned __int8 v22; // [esp+3Fh] [ebp-35h] BYREF
  char v23[4]; // [esp+40h] [ebp-34h] BYREF
  int TargetValue; // [esp+48h] [ebp-2Ch] BYREF
  char v25[4]; // [esp+4Ch] [ebp-28h] BYREF
  CDB v26; // [esp+50h] [ebp-24h] BYREF
  int v27; // [esp+60h] [ebp-14h]
  int v28; // [esp+64h] [ebp-10h]
  int v29; // [esp+70h] [ebp-4h]

  ReadPacket(packet, "dsdbbbbbbbb", &v6, &v16, v25, &v14, &v19, &v20, &v21, &v22, v23, &v15, &v8);
  if ( v14 <= 2u )
  {
    CDB::CDB(&v26);
    v29 = 0;
    CDB::Bind(&v26, &TargetValue);
    v27 = 2 * (CDBConfig::s_nEvent == 0) + 3;
    if ( CDB::Execute(&v26, "SELECT COUNT(*) FROM Player WHERE [UID] = %d", *(_DWORD *)v25)
      && CDB::Fetch(&v26)
      && TargetValue >= v27 )
    {
      CSocket::Write((int)this, 2, "db", v6, 3);
      v29 = -1;
      CDB::~CDB(&v26);
    }
    else
    {
      CDB::Reset(&v26);
      CDB::Bind(&v26, &TargetValue);
      if ( CDB::Execute(&v26, "SELECT COUNT(*) FROM ReservedName WHERE [Name] = '%s'", v16)
        && CDB::Fetch(&v26)
        && TargetValue > 0 )
      {
        CSocket::Write((int)this, 2, "db", v6, 6);
        v29 = -1;
        CDB::~CDB(&v26);
      }
      else
      {
        CDB::Reset(&v26);
        CDB::Bind(&v26, &TargetValue);
        if ( CDB::Execute(&v26, "SELECT COUNT(*) FROM Player WHERE [Name] = '%s'", v16)
          && CDB::Fetch(&v26)
          && TargetValue > 0 )
        {
          CSocket::Write((int)this, 2, "db", v6, 4);
          v29 = -1;
          CDB::~CDB(&v26);
        }
        else
        {
          v28 = 0;
          for ( i = 0; i < 5; ++i )
          {
            v28 += *(&v19 + i);
            *(&v19 + i) += LOBYTE(dword_43C4D8[7 * v14 + i]);
          }
          if ( v28 == 5 )
          {
            CDB::Reset(&v26);
            v2 = &g_rtCreate[g_nCreate & 3];
            v9 = v2->left;
            v10 = v2->top;
            v11 = v2->right;
            v12 = v2->bottom;
            ++g_nCreate;
            v17 = sub_41B360(v9, v11);
            v18 = sub_41B360(v10, v12);
            v13 = 2 * v20 * v20 / g_denoHP_0[v14] + 132;
            v7 = 2 * v22 * v22 / g_denoMP_0[v14] + v22 + 148;
            if ( CDB::ExecuteInsertUnique(
                   &v26,
                   "INSERT INTO Player ( [UID], [Name], [Class], [Strength], Health, Intelligence, Wisdom, Dexterity, [Cu"
                   "rHP], [CurMP], [Map], [X], [Y], [Z], [Face], [Hair]) VALUES ( %d, '%s', %d, %d, %d, %d, %d, %d, %d, %"
                   "d, %d, %d, %d, %d, %d, %d)",
                   *(_DWORD *)v25,
                   v16,
                   v14,
                   v19,
                   v20,
                   v21,
                   v22,
                   (unsigned __int8)v23[0],
                   v13,
                   v7,
                   0,
                   v17,
                   v18,
                   0,
                   v15,
                   v8) )
            {
              CSocket::Write((int)this, 2, "db", v6, 0);
            }
            else
            {
              CDB::Reset(&v26);
              n = 0;
              CDB::Bind(&v26, &n);
              if ( CDB::Execute(&v26, "SELECT [PID] FROM Player WHERE [Name] = '%s'", v16) && CDB::Fetch(&v26) )
              {
                LOG_DB(0, 2, n, *(int *)v25, 0, 0, 0, 0, 0);
                CDB::Reset(&v26);
                CDB::Execute(&v26, "INSERT INTO Skill VALUES ( %d, 0, 1)", n);
                CDB::Reset(&v26);
                CDB::Execute(&v26, "INSERT INTO Skill VALUES ( %d, 1, 1)", n);
                CDB::Reset(&v26);
                CDB::Execute(&v26, "INSERT INTO Skill VALUES ( %d, 11, 1)", n);
                if ( !CDBConfig::s_nEvent )
                {
                  CDB::Reset(&v26);
                  CDB::Execute(&v26, "INSERT INTO Skill VALUES ( %d, 62, 1)", n);
                }
                if ( v14 == 1 )
                {
                  CDB::Reset(&v26);
                  CDB::Execute(&v26, "INSERT INTO Skill VALUES ( %d, 4, 1)", n);
                }
                CDB::Reset(&v26);
                CDB::Execute(&v26, "INSERT INTO Quest VALUES (%d, 9001, 1, 0)", n);
                CSocket::Write((int)this, 2, "dbdb", v6, 1, n, v14);
              }
              else
              {
                CSocket::Write((int)this, 2, "db", v6, 0);
              }
            }
            v29 = -1;
            CDB::~CDB(&v26);
          }
          else
          {
            CSocket::Write((int)this, 2, "db", v6, 5);
            v29 = -1;
            CDB::~CDB(&v26);
          }
        }
      }
    }
  }
  else
  {
    CSocket::Write((int)this, 2, "db", v6, 2);
  }
}
// 43C4D8: using guessed type int dword_43C4D8[];

//----- (00417340) --------------------------------------------------------
void __stdcall sub_417340(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int TargetValue, int a10, int a11)
{
  CDB v11; // [esp+4h] [ebp-1Ch] BYREF
  int v12; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v11);
  v12 = 0;
  if ( !TargetValue )
  {
    CDB::Bind(&v11, &TargetValue);
    if ( !*(_BYTE *)a10
      || !CDB::Execute(&v11, "SELECT [UID] FROM Player WHERE [Name] = '%s'", (const char *)a10)
      || !CDB::Fetch(&v11) )
    {
      LOG_ERR(
        "CSocket::ForcedInStorage() ItemInfo(%d %d %d %d) Name(%s) Code(%d)",
        a3,
        a4,
        a6,
        a8,
        (const char *)a10,
        a11);
      v12 = -1;
      CDB::~CDB(&v11);
      return;
    }
    CDB::Reset(&v11);
  }
  CDB::Execute(
    &v11,
    "INSERT INTO Item ( [PID], [IID], [Index], [Prefix], [Info], [Num], [MaxEnd], [CurEnd], [SetGem]) VALUES ( %d, %d, %d"
    ", %d, %d, %d, %d, %d, %d)",
    TargetValue,
    a2,
    a3,
    a4,
    a5 & 0xE8 | 0x10,
    a6,
    a7,
    a7,
    a8);
  LOG_DB(5, a1, TargetValue, a11, a2, a3, a4, a6, a8);
  v12 = -1;
  CDB::~CDB(&v11);
}

//----- (00417480) --------------------------------------------------------
void __thiscall CSocket::SaveRevivalPt(CSocket *this, int nPID, int nRvId)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::ExecuteNoData(&v3, "UPDATE Player SET [RevivalId] = %d WHERE [PID] = %d", nRvId, nPID);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (004174F0) --------------------------------------------------------
void __thiscall CSocket::EventSave(CSocket *this, int nPID, int nCount, const char *info)
{
  _BYTE *v4; // eax
  int i; // [esp+4h] [ebp-2Ch]
  _BYTE *v6; // [esp+8h] [ebp-28h]
  unsigned __int8 v7; // [esp+Fh] [ebp-21h] BYREF
  CDB v8; // [esp+10h] [ebp-20h] BYREF
  int v9; // [esp+20h] [ebp-10h] BYREF
  int v10; // [esp+2Ch] [ebp-4h]

  v6 = info;
  CDB::CDB(&v8);
  v10 = 0;
  for ( i = 0; i < nCount; ++i )
  {
    v4 = GetNumeric<unsigned char>(v6, &v7);
    v6 = GetNumeric<int>(v4, &v9);
    CDB::Bind(&v8, &nCount);
    if ( CDB::Execute(&v8, "SELECT COUNT(*) FROM Event WHERE PID=%d AND Type=%d", nPID, v7)
      && CDB::Fetch(&v8)
      && nCount > 0 )
    {
      CDB::Reset(&v8);
      CDB::Execute(&v8, "UPDATE Event SET nF1=%d WHERE PID=%d AND Type=%d", v9, nPID, v7);
    }
    else
    {
      CDB::Reset(&v8);
      CDB::Execute(&v8, "INSERT INTO Event VALUES (%d,%d,%d)", nPID, v7, v9);
    }
  }
  v10 = -1;
  CDB::~CDB(&v8);
}

//----- (00417620) --------------------------------------------------------
void __thiscall CSocket::ProcessEvent(CSocket *this, int nId, int nEventCode, char *packet)
{
  const char *v5; // [esp+8h] [ebp-28h] BYREF
  int v6; // [esp+Ch] [ebp-24h]
  CDB v7; // [esp+10h] [ebp-20h] BYREF
  int TargetValue; // [esp+20h] [ebp-10h] BYREF
  int v9; // [esp+2Ch] [ebp-4h]

  if ( nEventCode == 3 )
  {
    ReadPacket(packet, "s", &v5);
    CDB::CDB(&v7);
    v9 = 0;
    v6 = 9;
    CDB::Bind(&v7, &TargetValue);
    if ( !CDB::Execute(&v7, "SELECT [UID] FROM Player WHERE [Name] = '%s'", v5) || !CDB::Fetch(&v7) )
      v6 = 6;
    CSocket::Write((int)this, 8, "dbbbd", nId, 3, 0, v6, TargetValue);
    v9 = -1;
    CDB::~CDB(&v7);
  }
}

//----- (00417700) --------------------------------------------------------
void __thiscall CSocket::GuildCreateSecedeCheck(CSocket *this, int nPlayer, int nCount, const char *info)
{
  int i; // [esp+4h] [ebp-2Ch]
  char v7[4]; // [esp+Ch] [ebp-24h] BYREF
  __time32_t TargetValue; // [esp+10h] [ebp-20h] BYREF
  CDB v9; // [esp+14h] [ebp-1Ch] BYREF
  int v10; // [esp+2Ch] [ebp-4h]

  CDB::CDB(&v9);
  v10 = 0;
  for ( i = 0; i < nCount; ++i )
  {
    info = (const char *)GetNumeric<int>(info, v7);
    TargetValue = 0;
    CDB::Reset(&v9);
    CDB::Bind(&v9, &TargetValue);
    CDB::ExecuteNoData(&v9, "SELECT Date FROM GuildMember WHERE GID=0 AND PID=%d", *(_DWORD *)v7);
    if ( CDB::Fetch(&v9) )
    {
      if ( (dword_43D974 & 0x100) == 0 && TargetValue > time(0) )
      {
        CSocket::Write((int)this, 9, "ddd", nPlayer, *(_DWORD *)v7, TargetValue);
        v10 = -1;
        CDB::~CDB(&v9);
        return;
      }
      CDB::Reset(&v9);
      CDB::Execute(&v9, "DELETE FROM GuildMember WHERE PID=%d", *(_DWORD *)v7);
    }
  }
  CSocket::Write((int)this, 9, "ddd", nPlayer, 0, 0);
  v10 = -1;
  CDB::~CDB(&v9);
}

//----- (00417850) --------------------------------------------------------
void __thiscall CSocket::GuildSecedeCheck(CSocket *this, int nPlayer, int nPID, int nGID)
{
  __time32_t TargetValue; // [esp+4h] [ebp-20h] BYREF
  CDB v6; // [esp+8h] [ebp-1Ch] BYREF
  int v7; // [esp+20h] [ebp-4h]

  CDB::CDB(&v6);
  v7 = 0;
  CDB::Bind(&v6, &TargetValue);
  CDB::ExecuteNoData(&v6, "SELECT Date FROM GuildMember WHERE GID=0 AND PID=%d", nPID);
  if ( CDB::Fetch(&v6) )
  {
    if ( (dword_43D974 & 0x100) == 0 && TargetValue > time(0) )
    {
      CSocket::Write((int)this, 10, "ddd", nPlayer, nGID, TargetValue);
      v7 = -1;
      CDB::~CDB(&v6);
      return;
    }
    CDB::Reset(&v6);
    CDB::Execute(&v6, "DELETE FROM GuildMember WHERE PID=%d", nPID);
  }
  CSocket::Write((int)this, 10, "ddd", nPlayer, nGID, 0);
  v7 = -1;
  CDB::~CDB(&v6);
}

//----- (00417950) --------------------------------------------------------
void __thiscall CSocket::GuildSameNameCheck(CSocket *this, int nPlayer, char *szGuildName)
{
  int TargetValue; // [esp+4h] [ebp-20h] BYREF
  CDB v5; // [esp+8h] [ebp-1Ch] BYREF
  int v6; // [esp+20h] [ebp-4h]

  CDB::CDB(&v5);
  v6 = 0;
  CDB::Bind(&v5, &TargetValue);
  if ( !CDB::Execute(&v5, "SELECT COUNT(*) FROM Guild WHERE Name='%s'", szGuildName) || !CDB::Fetch(&v5) )
    TargetValue = 2;
  CSocket::Write((int)this, 11, "dbs", nPlayer, (unsigned __int8)TargetValue, szGuildName);
  v6 = -1;
  CDB::~CDB(&v5);
}

//----- (00417A00) --------------------------------------------------------
void __thiscall CSocket::GuildCreate(CSocket *this, int nGID, char *szGuildName)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::Execute(&v3, aInsertIntoGuil_3, nGID, szGuildName, 3, 1, 1, 0, 0);
  CDB::Execute(&v3, "INSERT INTO GuildMember VALUES (%d,%d,%d,1,0)", nGID, nGID, 1);
  CDB::Execute(&v3, "UPDATE Player SET GID=%d WHERE PID=%d", nGID, nGID);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (00417AB0) --------------------------------------------------------
void __thiscall CSocket::GuildConflux(CSocket *this, int nGID, int nPID)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::Execute(&v3, "INSERT INTO GuildMember VALUES (%d,%d,%d,1,0)", nGID, nPID, 6);
  CDB::Execute(&v3, "UPDATE Player SET GID=%d WHERE PID=%d", nGID, nPID);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (00417B30) --------------------------------------------------------
void __thiscall CSocket::GuildSecederDelete(CSocket *this, int nPID)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v2);
  v3 = 0;
  CDB::Execute(&v2, "DELETE FROM GuildMember WHERE PID=%d", nPID);
  v3 = -1;
  CDB::~CDB(&v2);
}

//----- (00417BA0) --------------------------------------------------------
void __thiscall CSocket::GuildSeceder(CSocket *this, int nPID, int nSecedeDate)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::Execute(&v3, "UPDATE GuildMember SET GID=0, Date=%d WHERE PID=%d", nSecedeDate, nPID);
  CDB::Execute(&v3, "UPDATE Player SET GID=0 WHERE PID=%d", nPID);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (00417C20) --------------------------------------------------------
void __thiscall CSocket::GuildAppointment(CSocket *this, int nPID, int nClass, int nDate)
{
  CDB v4; // [esp+4h] [ebp-1Ch] BYREF
  int v5; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v4);
  v5 = 0;
  CDB::Execute(&v4, "UPDATE GuildMember SET Class=%d, Date=%d WHERE PID=%d", nClass, nDate, nPID);
  v5 = -1;
  CDB::~CDB(&v4);
}

//----- (00417C90) --------------------------------------------------------
void __thiscall CSocket::GuildDissolution(CSocket *this, int nGID, int nSecedeDate)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::Execute(&v3, "DELETE FROM Guild WHERE GID=%d", nGID);
  CDB::Execute(&v3, "UPDATE GuildMember SET GID=0, Date=%d WHERE GID=%d", nSecedeDate, nGID);
  CDB::Execute(&v3, "UPDATE Player SET GID=0 WHERE GID=%d", nGID);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (00417D20) --------------------------------------------------------
void __thiscall CSocket::GuildTitleChange(CSocket *this, int nGID, int nClass, char *szTitle)
{
  CDB v4; // [esp+8h] [ebp-1Ch] BYREF
  int v5; // [esp+20h] [ebp-4h]

  CDB::CDB(&v4);
  v5 = 0;
  switch ( nClass )
  {
    case 1:
      CDB::Execute(&v4, "UPDATE Guild SET Leader='%s' WHERE GID=%d", szTitle, nGID);
      break;
    case 2:
      CDB::Execute(&v4, "UPDATE Guild SET SubLeader='%s' WHERE GID=%d", szTitle, nGID);
      break;
    case 3:
      CDB::Execute(&v4, "UPDATE Guild SET Centurion='%s' WHERE GID=%d", szTitle, nGID);
      break;
    case 4:
      CDB::Execute(&v4, "UPDATE Guild SET Ten='%s' WHERE GID=%d", szTitle, nGID);
      break;
    case 5:
      CDB::Execute(&v4, "UPDATE Guild SET Regular='%s' WHERE GID=%d", szTitle, nGID);
      break;
    case 6:
      CDB::Execute(&v4, "UPDATE Guild SET Temp='%s' WHERE GID=%d", szTitle, nGID);
      break;
    default:
      break;
  }
  v5 = -1;
  CDB::~CDB(&v4);
}

//----- (00417E50) --------------------------------------------------------
void __thiscall CSocket::GuildTodayMessageChange(CSocket *this, int nGID, char *szMessage)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::Execute(&v3, "UPDATE Guild SET TodayMessage='%s' WHERE GID=%d", szMessage, nGID);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (00417EC0) --------------------------------------------------------
void __stdcall sub_417EC0(int a1, int a2, int a3)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::Execute(&v3, "UPDATE Guild SET Exp=Exp+%d WHERE GID=%d", a3, a1);
  LOG_DB(0, 32, a2, a1, 0, a3, 0, 0, 0);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (00417F50) --------------------------------------------------------
void __thiscall CSocket::GuildSetExp(CSocket *this, int nGID, int nExp)
{
  int TargetValue; // [esp+4h] [ebp-20h] BYREF
  CDB v4; // [esp+8h] [ebp-1Ch] BYREF
  int v5; // [esp+20h] [ebp-4h]

  TargetValue = 0;
  CDB::CDB(&v4);
  v5 = 0;
  CDB::Bind(&v4, &TargetValue);
  if ( CDB::ExecuteNoData(&v4, "SELECT GID FROM Guild WHERE Name='%s'", (const char *)nGID) )
  {
    CDB::Fetch(&v4);
    if ( TargetValue )
    {
      CDB::Reset(&v4);
      CDB::Execute(&v4, "UPDATE Guild SET Exp=%d WHERE GID=%d", nExp, TargetValue);
      LOG_DB(0, 32, 0, TargetValue, 0, nExp, 0, 0, 0);
    }
  }
  v5 = -1;
  CDB::~CDB(&v4);
}

//----- (00418020) --------------------------------------------------------
void __stdcall sub_418020(int a1, int a2, int a3, int a4, int a5, int a6)
{
  CDB v6; // [esp+4h] [ebp-1Ch] BYREF
  int v7; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v6);
  v7 = 0;
  CDB::Execute(
    &v6,
    "UPDATE Guild SET SubLeaderAble=%d, CenturionAble=%d, TenAble=%d, RegularAble=%d, TempAble=%d WHERE GID=%d",
    a2,
    a3,
    a4,
    a5,
    a6,
    a1);
  v7 = -1;
  CDB::~CDB(&v6);
}

//----- (004180A0) --------------------------------------------------------
void __stdcall sub_4180A0(int a1, int a2)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v2);
  v3 = 0;
  CDB::Execute(&v2, "UPDATE Guild SET AID=%d WHERE GID=%d", a1, a1);
  CDB::Execute(&v2, "INSERT INTO GuildAlliance VALUES (%d,0,0,0,0,0,0,0,%d)", a1, a2);
  LOG_DB(11, 33, a1, 0, 0, a2, 0, 0, 0);
  v3 = -1;
  CDB::~CDB(&v2);
}

//----- (00418140) --------------------------------------------------------
void __stdcall sub_418140(int a1, int a2, int a3)
{
  CDB v3; // [esp+8h] [ebp-1Ch] BYREF
  int v4; // [esp+20h] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::Execute(&v3, "UPDATE Guild SET AID=%d WHERE GID=%d", a1, a2);
  switch ( a3 )
  {
    case 1:
      CDB::Execute(&v3, "UPDATE GuildAlliance SET GID2=%d WHERE GID1=%d", a2, a1);
      goto LABEL_10;
    case 2:
      CDB::Execute(&v3, "UPDATE GuildAlliance SET GID3=%d WHERE GID1=%d", a2, a1);
      goto LABEL_10;
    case 3:
      CDB::Execute(&v3, "UPDATE GuildAlliance SET GID4=%d WHERE GID1=%d", a2, a1);
      goto LABEL_10;
    case 4:
      CDB::Execute(&v3, "UPDATE GuildAlliance SET GID5=%d WHERE GID1=%d", a2, a1);
      goto LABEL_10;
    case 5:
      CDB::Execute(&v3, "UPDATE GuildAlliance SET GID6=%d WHERE GID1=%d", a2, a1);
      goto LABEL_10;
    case 6:
      CDB::Execute(&v3, "UPDATE GuildAlliance SET GID7=%d WHERE GID1=%d", a2, a1);
      goto LABEL_10;
    case 7:
      CDB::Execute(&v3, "UPDATE GuildAlliance SET GID8=%d WHERE GID1=%d", a2, a1);
LABEL_10:
      LOG_DB(11, 34, a1, a2, 0, a3, 0, 0, 0);
      v4 = -1;
      CDB::~CDB(&v3);
      break;
    default:
      LOG_ERR("CSocket::AllianceJoin() alliance count error (aid:%d,gid=%d,count:%d)", a1, a2, a3);
      v4 = -1;
      CDB::~CDB(&v3);
      break;
  }
}

//----- (00418300) --------------------------------------------------------
void __stdcall sub_418300(int a1)
{
  CDB v1; // [esp+4h] [ebp-1Ch] BYREF
  int v2; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v1);
  v2 = 0;
  CDB::ExecuteNoData(&v1, "DELETE FROM GuildAlliance WHERE GID1=%d", a1);
  CDB::Execute(&v1, "UPDATE Guild SET AID=0 WHERE AID=%d", a1);
  LOG_DB(11, 35, a1, 0, 0, 0, 0, 0, 0);
  v2 = -1;
  CDB::~CDB(&v1);
}

//----- (004183A0) --------------------------------------------------------
void __stdcall sub_4183A0(int a1, int a2)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v2);
  v3 = 0;
  CDB::Execute(&v2, "UPDATE GuildAlliance SET Date=%d WHERE GID1=%d", a2, a1);
  LOG_DB(11, 36, a1, 0, 0, a2, 0, 0, 0);
  v3 = -1;
  CDB::~CDB(&v2);
}

//----- (00418430) --------------------------------------------------------
void __thiscall sub_418430(void *this)
{
  int v5; // [esp+4h] [ebp-40h] BYREF
  int v6; // [esp+8h] [ebp-3Ch] BYREF
  _BYTE *v7; // [esp+Ch] [ebp-38h]
  unsigned __int16 *v8; // [esp+10h] [ebp-34h]
  char v9; // [esp+17h] [ebp-2Dh] BYREF
  int v10; // [esp+18h] [ebp-2Ch]
  int n; // [esp+1Ch] [ebp-28h] BYREF
  char TargetValue; // [esp+23h] [ebp-21h] BYREF
  CDB v13; // [esp+24h] [ebp-20h] BYREF
  void *Src; // [esp+34h] [ebp-10h]
  int v15; // [esp+40h] [ebp-4h]

  v10 = 1;
  CDB::CDB(&v13);
  v15 = 0;
  CDB::Bind(&v13, &n);
  CDB::Bind(&v13, &v5);
  CDB::Bind(&v13, &v6);
  CDB::Bind(&TargetValue);
  CDB::Bind(&v9);
  CDB::Execute(&v13, "SELECT * FROM GuildCastle");
  while ( CDB::Fetch(&v13) )
  {
    Src = CIOBuffer::Alloc();
    v8 = (unsigned __int16 *)Src;
    *((_BYTE *)Src + 2) = 17;
    v7 = v8 + 2;
    v7 = PutNumeric<int>((_DWORD *)v8 + 1, n);
    v7 = PutNumeric<int>(v7, v5);
    v7 = PutNumeric<int>(v7, v6);
    v7 = PutNumeric<unsigned char>(v7, TargetValue);
    v7 = PutNumeric<unsigned char>(v7, v9);
    if ( v5 )
      v7 = sub_418BA0(v5, 1, v7);
    WritePacket((char *)v8 + 3, "b", (unsigned __int8)v10);
    *v8 = (_WORD)v7 - (_WORD)v8;
    *((_DWORD *)Src + 2000) = *v8;
    CIOSocket::Write((CIOSocket *)this, (CIOBuffer *)Src);
  }
  CSocket::Write((int)this, 17, "b", 0);
  v15 = -1;
  CDB::~CDB(&v13);
}

//----- (004185D0) --------------------------------------------------------
void __thiscall sub_4185D0(void *this)
{
  int n; // [esp+4h] [ebp-74h] BYREF
  char v6[4]; // [esp+8h] [ebp-70h] BYREF
  CDB v7; // [esp+Ch] [ebp-6Ch] BYREF
  char *packet; // [esp+1Ch] [ebp-5Ch]
  char str[20]; // [esp+20h] [ebp-58h] BYREF
  char v10[20]; // [esp+34h] [ebp-44h] BYREF
  char *v11; // [esp+4Ch] [ebp-2Ch]
  int v12; // [esp+50h] [ebp-28h]
  int TargetValue; // [esp+54h] [ebp-24h] BYREF
  CDB v14; // [esp+58h] [ebp-20h] BYREF
  void *Src; // [esp+68h] [ebp-10h]
  int v16; // [esp+74h] [ebp-4h]

  Src = CIOBuffer::Alloc();
  v11 = (char *)Src;
  *((_BYTE *)Src + 2) = 18;
  packet = v11 + 4;
  v12 = 0;
  CDB::CDB(&v14);
  v16 = 0;
  CDB::CDB(&v7);
  LOBYTE(v16) = 1;
  CDB::Bind(&v14, &TargetValue);
  CDB::Bind(&v14, &n);
  CDB::Bind(&v14, (int *)v6);
  CDB::Execute(&v14, "SELECT * FROM GuildWar");
  while ( CDB::Fetch(&v14) )
  {
    ++v12;
    packet = (char *)PutNumeric<int>(packet, TargetValue);
    packet = (char *)PutNumeric<int>(packet, n);
    packet = (char *)PutNumeric<int>(packet, *(int *)v6);
    CDB::Bind(&v7, str, 17);
    if ( !CDB::Execute(&v7, "SELECT [Name] FROM Guild WHERE GID=%d", *(_DWORD *)v6) || !CDB::Fetch(&v7) )
    {
      LOG_ERR("CSocket::WarInit() guild not find (gid:%d)", *(_DWORD *)v6);
      CIOBuffer::Free(Src);
      LOBYTE(v16) = 0;
      CDB::~CDB(&v7);
      v16 = -1;
      CDB::~CDB(&v14);
      return;
    }
    packet = PutString(packet, str);
    CDB::Reset(&v7);
    CDB::Bind(&v7, v10, 17);
    if ( !CDB::Execute(&v7, "SELECT [Name] FROM Player WHERE PID=%d", *(_DWORD *)v6) || !CDB::Fetch(&v7) )
    {
      LOG_ERR("CSocket::WarInit() Leader not find (gid:%d)", *(_DWORD *)v6);
      CIOBuffer::Free(Src);
      LOBYTE(v16) = 0;
      CDB::~CDB(&v7);
      v16 = -1;
      CDB::~CDB(&v14);
      return;
    }
    packet = PutString(packet, v10);
    CDB::Reset(&v7);
    if ( v12 >= 150 )
    {
      WritePacket(v11 + 3, "b", (unsigned __int8)v12);
      *(_WORD *)v11 = (_WORD)packet - (_WORD)v11;
      *((_DWORD *)Src + 2000) = *(unsigned __int16 *)v11;
      CIOSocket::Write((CIOSocket *)this, (CIOBuffer *)Src);
      v12 = 0;
      Src = CIOBuffer::Alloc();
      v11 = (char *)Src;
      *((_BYTE *)Src + 2) = 18;
      packet = v11 + 4;
    }
  }
  WritePacket(v11 + 3, "b", (unsigned __int8)v12);
  *(_WORD *)v11 = (_WORD)packet - (_WORD)v11;
  *((_DWORD *)Src + 2000) = *(unsigned __int16 *)v11;
  CIOSocket::Write((CIOSocket *)this, (CIOBuffer *)Src);
  if ( v12 )
    CSocket::Write((int)this, 18, "b", 0);
  LOBYTE(v16) = 0;
  CDB::~CDB(&v7);
  v16 = -1;
  CDB::~CDB(&v14);
}

//----- (004188D0) --------------------------------------------------------
void sub_4188D0()
{
  CDB v0; // [esp+4h] [ebp-1Ch] BYREF
  int v1; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v0);
  v1 = 0;
  CDB::ExecuteNoData(&v0, "DELETE FROM GuildWar");
  v1 = -1;
  CDB::~CDB(&v0);
}

//----- (00418930) --------------------------------------------------------
void __stdcall sub_418930(int a1, int a2, int a3)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::Execute(&v3, "INSERT INTO GuildWar VALUES (%d,%d,%d)", a1, a2, a3);
  LOG_DB(12, 37, 0, 0, 0, a1, a2, a3, 0);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (004189C0) --------------------------------------------------------
void __stdcall sub_4189C0(int a1, int a2)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v2);
  v3 = 0;
  CDB::Execute(&v2, "UPDATE GuildCastle SET GID=%d WHERE CID=%d", a2, a1);
  LOG_DB(12, 38, 0, 0, 0, a1, a2, 0, 0);
  v3 = -1;
  CDB::~CDB(&v2);
}

//----- (00418A50) --------------------------------------------------------
void __stdcall sub_418A50(int a1, int a2)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v2);
  v3 = 0;
  CDB::Execute(&v2, "UPDATE GuildCastle SET TaxRate=%d WHERE CID=%d", a2, a1);
  v3 = -1;
  CDB::~CDB(&v2);
}

//----- (00418AC0) --------------------------------------------------------
void __stdcall sub_418AC0(int a1, int a2)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v2);
  v3 = 0;
  CDB::Execute(&v2, "UPDATE GuildCastle SET [Tax] = %d WHERE [CID] = %d", a2, a1);
  v3 = -1;
  CDB::~CDB(&v2);
}

//----- (00418B30) --------------------------------------------------------
void __stdcall sub_418B30(int a1, int a2)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v2);
  v3 = 0;
  CDB::Execute(&v2, "UPDATE GuildCastle SET GateLimit=%d WHERE CID=%d", a2, a1);
  v3 = -1;
  CDB::~CDB(&v2);
}

//----- (00418BA0) --------------------------------------------------------
_BYTE *__stdcall sub_418BA0(int a1, int a2, _BYTE *a3)
{
  char *v3; // eax
  _DWORD *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  char *v18; // eax
  char *v19; // eax
  _WORD *v20; // eax
  _BYTE *v21; // eax
  _BYTE *v22; // eax
  char *v23; // eax
  char *v24; // eax
  int v26; // [esp+8h] [ebp-1E4h] BYREF
  char v27[4]; // [esp+Ch] [ebp-1E0h] BYREF
  char v28[4]; // [esp+10h] [ebp-1DCh] BYREF
  char v29[4]; // [esp+14h] [ebp-1D8h] BYREF
  char v30[4]; // [esp+18h] [ebp-1D4h] BYREF
  char v31[4]; // [esp+1Ch] [ebp-1D0h] BYREF
  char v32[4]; // [esp+20h] [ebp-1CCh] BYREF
  char v33[4]; // [esp+24h] [ebp-1C8h] BYREF
  int v34; // [esp+28h] [ebp-1C4h] BYREF
  char v35[20]; // [esp+2Ch] [ebp-1C0h] BYREF
  char v36[20]; // [esp+40h] [ebp-1ACh] BYREF
  unsigned __int16 v37; // [esp+54h] [ebp-198h] BYREF
  char v38[20]; // [esp+58h] [ebp-194h] BYREF
  int v39; // [esp+6Ch] [ebp-180h] BYREF
  char TargetValue; // [esp+73h] [ebp-179h] BYREF
  int v41; // [esp+74h] [ebp-178h] BYREF
  char v42; // [esp+7Bh] [ebp-171h] BYREF
  unsigned __int8 *v43; // [esp+7Ch] [ebp-170h]
  int v44; // [esp+80h] [ebp-16Ch] BYREF
  int v45; // [esp+84h] [ebp-168h] BYREF
  char v46[16]; // [esp+88h] [ebp-164h] BYREF
  char v47[16]; // [esp+98h] [ebp-154h] BYREF
  char v48[16]; // [esp+A8h] [ebp-144h] BYREF
  char v49[16]; // [esp+B8h] [ebp-134h] BYREF
  char str[20]; // [esp+C8h] [ebp-124h] BYREF
  int n; // [esp+DCh] [ebp-110h] BYREF
  char v52[184]; // [esp+E0h] [ebp-10Ch] BYREF
  int v53; // [esp+198h] [ebp-54h] BYREF
  int v54; // [esp+19Ch] [ebp-50h] BYREF
  char v55[16]; // [esp+1A0h] [ebp-4Ch] BYREF
  char v56[16]; // [esp+1B0h] [ebp-3Ch] BYREF
  int v57; // [esp+1C4h] [ebp-28h] BYREF
  int v58; // [esp+1C8h] [ebp-24h] BYREF
  CDB v59; // [esp+1CCh] [ebp-20h] BYREF
  int v60; // [esp+1DCh] [ebp-10h] BYREF
  int v61; // [esp+1E8h] [ebp-4h]
  char *packet; // [esp+1FCh] [ebp+10h]

  CDB::CDB(&v59);
  v61 = 0;
  CDB::Skip(&v59);
  CDB::Bind(&v59, str, 17);
  CDB::Bind(&v59, &n);
  CDB::Bind(&v59, &v54);
  CDB::Bind(&v59, v52, 181);
  CDB::Bind(&v59, v49, 15);
  CDB::Bind(&v59, v56, 15);
  CDB::Bind(&v59, v55, 15);
  CDB::Bind(&v59, v46, 15);
  CDB::Bind(&v59, v47, 15);
  CDB::Bind(&v59, v48, 15);
  CDB::Bind(&v59, &v57);
  CDB::Bind(&v59, &v58);
  CDB::Bind(&v59, &v60);
  CDB::Bind(&v59, &v45);
  CDB::Bind(&v59, &v53);
  CDB::Bind(&v59, &v44);
  if ( CDB::Execute(&v59, "SELECT * FROM Guild WHERE GID=%d", a1) && CDB::Fetch(&v59) )
  {
    v3 = PutString(a3, str);
    v4 = PutNumeric<int>(v3, n);
    v5 = (char *)PutNumeric<int>(v4, v54);
    v6 = PutString(v5, v52);
    v7 = PutString(v6, v49);
    v8 = PutString(v7, v56);
    v9 = PutString(v8, v55);
    v10 = PutString(v9, v46);
    v11 = PutString(v10, v47);
    v12 = PutString(v11, v48);
    v13 = PutNumeric<int>(v12, v57);
    v14 = PutNumeric<int>(v13, v58);
    v15 = PutNumeric<int>(v14, v60);
    v16 = PutNumeric<int>(v15, v45);
    v17 = PutNumeric<int>(v16, v53);
    v43 = (unsigned __int8 *)PutNumeric<int>(v17, v44);
    packet = (char *)(v43 + 1);
    *v43 = 0;
    CDB::Reset(&v59);
    CDB::Bind(&v59, &v39);
    CDB::Bind(&v59, v38, 17);
    CDB::Bind(&v59, &v37);
    CDB::Bind(&TargetValue);
    CDB::Bind(&v42);
    CDB::Bind(&v59, &v41);
    if ( CDB::Execute(
           &v59,
           "SELECT a.[PID],b.[Name],b.[Contribute],a.[Class],a.[ConnectTell],a.[Date] FROM GuildMember a, Player b WHERE "
           "a.GID=%d AND a.PID=b.PID",
           a1) )
    {
      while ( CDB::Fetch(&v59) )
      {
        v18 = (char *)PutNumeric<int>(packet, v39);
        v19 = PutString(v18, v38);
        v20 = PutNumeric<short>(v19, v37);
        v21 = PutNumeric<unsigned char>(v20, TargetValue);
        v22 = PutNumeric<unsigned char>(v21, v42);
        packet = (char *)PutNumeric<int>(v22, v41);
        ++*v43;
      }
    }
    if ( a2 && v44 )
    {
      v43 = PutNumeric<unsigned char>(packet, 1);
      a3 = v43 + 1;
      *v43 = 0;
      CDB::Reset(&v59);
      CDB::Bind(&v59, &v26);
      CDB::Bind(&v59, (int *)v27);
      CDB::Bind(&v59, (int *)v28);
      CDB::Bind(&v59, (int *)v29);
      CDB::Bind(&v59, (int *)v30);
      CDB::Bind(&v59, (int *)v31);
      CDB::Bind(&v59, (int *)v32);
      CDB::Bind(&v59, (int *)v33);
      CDB::Bind(&v59, &v34);
      if ( CDB::Execute(&v59, "SELECT * FROM GuildAlliance WHERE GID1=%d", v44) && CDB::Fetch(&v59) )
      {
        a3 = PutNumeric<int>(a3, v34);
        while ( *(&v26 + *v43) && *v43 < 8u )
        {
          CDB::Reset(&v59);
          CDB::Bind(&v59, v35, 17);
          CDB::Bind(&v59, v36, 17);
          CDB::Execute(
            &v59,
            "SELECT b.Name, a.Name FROM Player a, Guild b WHERE b.GID=%d AND a.PID=b.GID",
            *(&v26 + *v43));
          CDB::Fetch(&v59);
          v23 = (char *)PutNumeric<int>(a3, *(&v26 + *v43));
          v24 = PutString(v23, v35);
          a3 = PutString(v24, v36);
          ++*v43;
        }
      }
    }
    else
    {
      a3 = PutNumeric<unsigned char>(packet, 0);
    }
  }
  v61 = -1;
  CDB::~CDB(&v59);
  return a3;
}
// 41B150: using guessed type int __thiscall CDB::Skip(_DWORD);

//----- (004191C0) --------------------------------------------------------
void __thiscall sub_4191C0(void *this, int a2, int a3, int a4)
{
  _BYTE *v8; // [esp+4h] [ebp-30h]
  char TargetValue[4]; // [esp+8h] [ebp-2Ch] BYREF
  char *v10; // [esp+Ch] [ebp-28h]
  int v11; // [esp+10h] [ebp-24h]
  CDB v12; // [esp+14h] [ebp-20h] BYREF
  void *Src; // [esp+24h] [ebp-10h]
  int v14; // [esp+30h] [ebp-4h]

  Src = CIOBuffer::Alloc();
  v10 = (char *)Src;
  *((_BYTE *)Src + 2) = 20;
  v8 = v10 + 11;
  v11 = 0;
  CDB::CDB(&v12);
  v14 = 0;
  CDB::Bind(&v12, (int *)TargetValue);
  if ( CDB::Execute(&v12, "SELECT [Standard] FROM Guild WHERE ( [Standard] & 0xff00) = %d", a4) )
  {
    while ( CDB::Fetch(&v12) )
    {
      v8 = PutNumeric<unsigned char>(v8, TargetValue[0]);
      ++v11;
    }
  }
  WritePacket(v10 + 3, "dd", a2, v11);
  *(_WORD *)v10 = (_WORD)v8 - (_WORD)v10;
  *((_DWORD *)Src + 2000) = *(unsigned __int16 *)v10;
  CIOSocket::Write((CIOSocket *)this, (CIOBuffer *)Src);
  v14 = -1;
  CDB::~CDB(&v12);
}

//----- (004192D0) --------------------------------------------------------
void __thiscall sub_4192D0(void *this, int a2, int a3, int a4)
{
  int v8; // [esp+4h] [ebp-24h]
  int TargetValue; // [esp+8h] [ebp-20h] BYREF
  CDB v10; // [esp+Ch] [ebp-1Ch] BYREF
  int v11; // [esp+24h] [ebp-4h]

  v8 = 0;
  CDB::CDB(&v10);
  v11 = 0;
  CDB::Bind(&v10, &TargetValue);
  if ( CDB::Execute(&v10, "SELECT COUNT(*) FROM Guild WHERE [Standard] = %d", a4) && CDB::Fetch(&v10) && !TargetValue )
  {
    CDB::Reset(&v10);
    CDB::Execute(&v10, "UPDATE Guild SET [Standard] = %d WHERE [GID] = %d", a4, a3);
    v8 = 1;
  }
  CSocket::Write((int)this, 21, "dbdd", a2, v8, a3, a4);
  v11 = -1;
  CDB::~CDB(&v10);
}

//----- (004193B0) --------------------------------------------------------
void __thiscall sub_4193B0(void *this, int a2, int a3, int a4, int a5, const char *a6)
{
  int TargetValue; // [esp+4h] [ebp-20h] BYREF
  CDB v11; // [esp+8h] [ebp-1Ch] BYREF
  int v12; // [esp+20h] [ebp-4h]

  CDB::CDB(&v11);
  v12 = 0;
  CDB::Bind(&v11, &TargetValue);
  if ( CDB::Execute(&v11, "SELECT COUNT(*) FROM Player WHERE [UID] = %d", a4) && CDB::Fetch(&v11) && TargetValue > 2 )
  {
    CSocket::Write((int)this, 13, "dbbss", a2, 3, a3, &unk_42ED6E, &unk_42ED6D);
    v12 = -1;
    CDB::~CDB(&v11);
  }
  else
  {
    CDB::Reset(&v11);
    CDB::Bind(&v11, &TargetValue);
    if ( CDB::Execute(&v11, "SELECT COUNT(*) FROM Player WHERE [Name] = '%s'", a6)
      && CDB::Fetch(&v11)
      && TargetValue > 0 )
    {
      CSocket::Write((int)this, 13, "dbbss", a2, 4, a3, &unk_42EDA9, &unk_42EDA8);
      v12 = -1;
      CDB::~CDB(&v11);
    }
    else
    {
      CSocket::Write((int)this, 13, "dbbss", a2, 2, a3, a5, a6);
      v12 = -1;
      CDB::~CDB(&v11);
    }
  }
}

//----- (00419510) --------------------------------------------------------
void __thiscall sub_419510(void *this, int a2, int a3, int a4, const char *a5, int a6)
{
  char *v10; // [esp+4h] [ebp-A8h]
  char *v11; // [esp+4h] [ebp-A8h]
  char *v12; // [esp+4h] [ebp-A8h]
  char *v13; // [esp+4h] [ebp-A8h]
  __int16 v14[3]; // [esp+8h] [ebp-A4h] BYREF
  char v15; // [esp+Fh] [ebp-9Dh] BYREF
  char v16; // [esp+10h] [ebp-9Ch] BYREF
  char v17; // [esp+11h] [ebp-9Bh] BYREF
  char v18; // [esp+12h] [ebp-9Ah] BYREF
  char v19; // [esp+13h] [ebp-99h] BYREF
  int v20; // [esp+14h] [ebp-98h] BYREF
  int v21; // [esp+18h] [ebp-94h] BYREF
  char *v22; // [esp+1Ch] [ebp-90h]
  char v23; // [esp+23h] [ebp-89h] BYREF
  char v24; // [esp+24h] [ebp-88h] BYREF
  char v25; // [esp+25h] [ebp-87h] BYREF
  char v26; // [esp+26h] [ebp-86h] BYREF
  char v27; // [esp+27h] [ebp-85h] BYREF
  char v28; // [esp+28h] [ebp-84h] BYREF
  char v29; // [esp+29h] [ebp-83h] BYREF
  char v30; // [esp+2Ah] [ebp-82h] BYREF
  char v31; // [esp+2Bh] [ebp-81h] BYREF
  unsigned __int16 v32; // [esp+2Ch] [ebp-80h] BYREF
  char v33; // [esp+30h] [ebp-7Ch] BYREF
  char v34; // [esp+31h] [ebp-7Bh] BYREF
  char v35; // [esp+32h] [ebp-7Ah] BYREF
  char v36; // [esp+33h] [ebp-79h] BYREF
  unsigned __int16 v37; // [esp+34h] [ebp-78h] BYREF
  int v38; // [esp+38h] [ebp-74h] BYREF
  int n; // [esp+3Ch] [ebp-70h] BYREF
  int v40; // [esp+40h] [ebp-6Ch] BYREF
  char *packet; // [esp+44h] [ebp-68h]
  char v42; // [esp+4Bh] [ebp-61h] BYREF
  unsigned __int16 v43; // [esp+4Ch] [ebp-60h] BYREF
  unsigned __int16 v44; // [esp+50h] [ebp-5Ch] BYREF
  __int16 v45[3]; // [esp+54h] [ebp-58h] BYREF
  char v46; // [esp+5Bh] [ebp-51h] BYREF
  int v47; // [esp+5Ch] [ebp-50h] BYREF
  char v48; // [esp+62h] [ebp-4Ah] BYREF
  char v49; // [esp+63h] [ebp-49h] BYREF
  __int16 v50[2]; // [esp+64h] [ebp-48h] BYREF
  char v51; // [esp+69h] [ebp-43h] BYREF
  char v52; // [esp+6Ah] [ebp-42h] BYREF
  char v53; // [esp+6Bh] [ebp-41h] BYREF
  char *v54; // [esp+6Ch] [ebp-40h]
  int v55; // [esp+70h] [ebp-3Ch]
  int v56; // [esp+74h] [ebp-38h] BYREF
  __int64 v57; // [esp+78h] [ebp-34h] BYREF
  char v58; // [esp+85h] [ebp-27h] BYREF
  char v59; // [esp+86h] [ebp-26h] BYREF
  char TargetValue; // [esp+87h] [ebp-25h] BYREF
  CDB v61; // [esp+88h] [ebp-24h] BYREF
  void *Src; // [esp+98h] [ebp-14h]
  char v63; // [esp+9Eh] [ebp-Eh] BYREF
  char v64; // [esp+9Fh] [ebp-Dh] BYREF
  int v65; // [esp+A8h] [ebp-4h]

  Src = CIOBuffer::Alloc();
  v54 = (char *)Src;
  *((_BYTE *)Src + 2) = 14;
  packet = v54 + 12;
  v55 = 0;
  CDB::CDB(&v61);
  v65 = 0;
  CDB::Bind(&v61, &n);
  CDB::Bind(&v61, &v47);
  CDB::Bind(&TargetValue);
  CDB::Skip(&v61);
  CDB::Bind(&v48);
  CDB::Bind(&v63);
  CDB::Bind(&v42);
  CDB::Bind(&v61, (unsigned __int16 *)v50);
  CDB::Bind(&v61, &v57);
  Concurrency::details::ExternalStatistics::IncrementDequeuedTaskCounter(
    (Concurrency::details::ExternalStatistics *)&v61,
    2u);
  CDB::Bind(&v58);
  CDB::Bind(&v52);
  CDB::Bind(&v51);
  CDB::Bind(&v35);
  CDB::Bind(&v36);
  CDB::Bind(&v61, &v43);
  CDB::Bind(&v61, &v37);
  CDB::Bind(&v61, &v44);
  CDB::Bind(&v61, (unsigned __int16 *)v45);
  CDB::Bind(&v64);
  CDB::Bind(&v49);
  CDB::Bind(&v61, &v56);
  CDB::Bind(&v61, &v38);
  CDB::Bind(&v61, &v40);
  CDB::Bind(&v53);
  CDB::Bind(&v46);
  CDB::Bind(&v59);
  if ( CDB::Execute(&v61, "SELECT * FROM Player WHERE [Name] = '%s'", a5) && CDB::Fetch(&v61) && a4 == n )
  {
    if ( TargetValue == 1 )
    {
      v55 = 7;
    }
    else
    {
      v10 = packet++;
      v22 = packet;
      packet = PutString(packet, (const char *)a6);
      packet = PutNumeric<unsigned char>(packet, TargetValue);
      packet = PutNumeric<unsigned char>(packet, v48);
      packet = PutNumeric<unsigned char>(packet, v63);
      packet = PutNumeric<unsigned char>(packet, v42);
      packet = (char *)PutNumeric<short>(packet, v50[0]);
      packet = (char *)PutNumeric<__int64>(packet, v57, SHIDWORD(v57));
      packet = PutNumeric<unsigned char>(packet, v58);
      packet = PutNumeric<unsigned char>(packet, v52);
      packet = PutNumeric<unsigned char>(packet, v51);
      packet = PutNumeric<unsigned char>(packet, v35);
      packet = PutNumeric<unsigned char>(packet, v36);
      packet = (char *)PutNumeric<short>(packet, v43);
      packet = (char *)PutNumeric<short>(packet, v37);
      packet = (char *)PutNumeric<short>(packet, v44);
      packet = (char *)PutNumeric<short>(packet, v45[0]);
      packet = PutNumeric<unsigned char>(packet, v64);
      packet = PutNumeric<unsigned char>(packet, v49);
      packet = (char *)PutNumeric<int>(packet, v56);
      packet = (char *)PutNumeric<int>(packet, v38);
      packet = (char *)PutNumeric<int>(packet, v40);
      packet = PutNumeric<unsigned char>(packet, v53);
      packet = PutNumeric<unsigned char>(packet, v46);
      packet = PutNumeric<unsigned char>(packet, v59);
      *v10 = (_BYTE)packet - (_BYTE)v22;
      v11 = packet++;
      *v11 = 0;
      CDB::Reset(&v61);
      Concurrency::details::ExternalStatistics::IncrementDequeuedTaskCounter(
        (Concurrency::details::ExternalStatistics *)&v61,
        2u);
      CDB::Bind(&v61, (unsigned __int16 *)v14);
      CDB::Bind(&v26);
      CDB::Bind(&v61, &v20);
      CDB::Bind(&v61, &v21);
      CDB::Bind(&v23);
      CDB::Bind(&v27);
      CDB::Bind(&v30);
      CDB::Bind(&v24);
      CDB::Bind(&v17);
      CDB::Bind(&v28);
      CDB::Bind(&v29);
      CDB::Bind(&v18);
      CDB::Bind(&v34);
      CDB::Bind(&v31);
      CDB::Bind(&v19);
      if ( CDB::Execute(&v61, "SELECT TOP %d * FROM Item WHERE [PID] = %d AND ( [Info] & %d) = 0", 72, v47, 16) )
      {
        while ( CDB::Fetch(&v61) )
        {
          packet = (char *)PutNumeric<int>(packet, 0);
          packet = (char *)PutNumeric<short>(packet, v14[0]);
          packet = PutNumeric<unsigned char>(packet, v26);
          packet = (char *)PutNumeric<int>(packet, v20);
          packet = (char *)PutNumeric<int>(packet, v21);
          packet = PutNumeric<unsigned char>(packet, v23);
          packet = PutNumeric<unsigned char>(packet, v27);
          packet = PutNumeric<unsigned char>(packet, v30);
          packet = PutNumeric<unsigned char>(packet, v24);
          packet = PutNumeric<unsigned char>(packet, v17);
          packet = PutNumeric<unsigned char>(packet, v28);
          packet = PutNumeric<unsigned char>(packet, v29);
          packet = PutNumeric<unsigned char>(packet, v18);
          packet = PutNumeric<unsigned char>(packet, v34);
          packet = PutNumeric<unsigned char>(packet, v31);
          packet = PutNumeric<unsigned char>(packet, v19);
          ++*v11;
        }
      }
      v12 = packet++;
      *v12 = 0;
      CDB::Reset(&v61);
      CDB::Bind(&v15);
      CDB::Bind(&v25);
      if ( CDB::Execute(&v61, "SELECT TOP 64 [Index], [Level] FROM Skill WHERE [PID] = %d", v47) )
      {
        while ( CDB::Fetch(&v61) )
        {
          packet = PutNumeric<unsigned char>(packet, v15);
          packet = PutNumeric<unsigned char>(packet, v25);
          ++*v12;
        }
      }
      v13 = packet++;
      *v13 = 0;
      CDB::Reset(&v61);
      CDB::Skip(&v61);
      CDB::Bind(&v61, &v32);
      CDB::Bind(&v16);
      CDB::Bind(&v33);
      if ( CDB::Execute(&v61, "SELECT * FROM Quest WHERE [PID] = %d", v47) )
      {
        while ( CDB::Fetch(&v61) )
        {
          packet = (char *)PutNumeric<short>(packet, v32);
          packet = PutNumeric<unsigned char>(packet, v16);
          packet = PutNumeric<unsigned char>(packet, v33);
          ++*v13;
        }
      }
      v55 = 1;
    }
  }
  else
  {
    v55 = 6;
  }
  WritePacket(v54 + 3, "ddb", a2, a3, v55);
  *(_WORD *)v54 = (_WORD)packet - (_WORD)v54;
  *((_DWORD *)Src + 2000) = *(unsigned __int16 *)v54;
  CIOSocket::Write((CIOSocket *)this, (CIOBuffer *)Src);
  v65 = -1;
  CDB::~CDB(&v61);
}
// 41B150: using guessed type int __thiscall CDB::Skip(_DWORD);

//----- (00419D90) --------------------------------------------------------
void __thiscall sub_419D90(void *this, int a2, int a3, void *Src)
{
  int k; // [esp+4h] [ebp-A4h]
  int j; // [esp+8h] [ebp-A0h]
  int i; // [esp+Ch] [ebp-9Ch]
  unsigned __int16 v11[3]; // [esp+10h] [ebp-98h] BYREF
  unsigned __int8 v12; // [esp+16h] [ebp-92h] BYREF
  unsigned __int8 v13; // [esp+17h] [ebp-91h] BYREF
  unsigned __int8 v14; // [esp+18h] [ebp-90h] BYREF
  unsigned __int8 v15; // [esp+19h] [ebp-8Fh] BYREF
  unsigned __int8 v16; // [esp+1Ah] [ebp-8Eh] BYREF
  unsigned __int8 v17; // [esp+1Bh] [ebp-8Dh] BYREF
  int v18; // [esp+1Ch] [ebp-8Ch] BYREF
  int v19; // [esp+20h] [ebp-88h] BYREF
  unsigned __int8 v20; // [esp+24h] [ebp-84h] BYREF
  unsigned __int8 v21; // [esp+25h] [ebp-83h] BYREF
  unsigned __int8 v22; // [esp+26h] [ebp-82h] BYREF
  unsigned __int8 v23; // [esp+27h] [ebp-81h] BYREF
  unsigned __int8 v24; // [esp+28h] [ebp-80h] BYREF
  unsigned __int8 v25; // [esp+29h] [ebp-7Fh] BYREF
  unsigned __int8 v26; // [esp+2Ah] [ebp-7Eh] BYREF
  unsigned __int8 v27; // [esp+2Bh] [ebp-7Dh] BYREF
  unsigned __int16 v28[3]; // [esp+2Ch] [ebp-7Ch] BYREF
  unsigned __int8 v29; // [esp+33h] [ebp-75h] BYREF
  int v30; // [esp+34h] [ebp-74h] BYREF
  unsigned __int8 v31; // [esp+3Ah] [ebp-6Eh] BYREF
  unsigned __int8 v32; // [esp+3Bh] [ebp-6Dh] BYREF
  int n; // [esp+3Ch] [ebp-6Ch] BYREF
  unsigned __int8 v34; // [esp+42h] [ebp-66h] BYREF
  unsigned __int8 v35; // [esp+43h] [ebp-65h] BYREF
  unsigned __int16 v36; // [esp+44h] [ebp-64h] BYREF
  int v37; // [esp+48h] [ebp-60h] BYREF
  int v38; // [esp+4Ch] [ebp-5Ch] BYREF
  unsigned __int8 v39; // [esp+52h] [ebp-56h] BYREF
  unsigned __int8 v40; // [esp+53h] [ebp-55h] BYREF
  unsigned __int16 v41; // [esp+54h] [ebp-54h] BYREF
  unsigned __int16 v42; // [esp+58h] [ebp-50h] BYREF
  unsigned __int16 v43[2]; // [esp+5Ch] [ebp-4Ch] BYREF
  unsigned __int8 v44; // [esp+61h] [ebp-47h] BYREF
  unsigned __int8 v45; // [esp+62h] [ebp-46h] BYREF
  unsigned __int8 v46; // [esp+63h] [ebp-45h] BYREF
  unsigned __int16 v47; // [esp+64h] [ebp-44h] BYREF
  const char *v48; // [esp+68h] [ebp-40h] BYREF
  unsigned __int8 v49; // [esp+6Eh] [ebp-3Ah] BYREF
  unsigned __int8 v50; // [esp+6Fh] [ebp-39h] BYREF
  int v51; // [esp+70h] [ebp-38h] BYREF
  int TargetValue; // [esp+74h] [ebp-34h] BYREF
  unsigned __int8 v53; // [esp+7Ah] [ebp-2Eh] BYREF
  unsigned __int8 v54; // [esp+7Bh] [ebp-2Dh] BYREF
  __int64 v55; // [esp+7Ch] [ebp-2Ch] BYREF
  CDB v56; // [esp+88h] [ebp-20h] BYREF
  unsigned __int8 v57; // [esp+99h] [ebp-Fh] BYREF
  unsigned __int8 v58; // [esp+9Ah] [ebp-Eh] BYREF
  unsigned __int8 v59; // [esp+9Bh] [ebp-Dh] BYREF
  int v60; // [esp+A4h] [ebp-4h]
  char *Srca; // [esp+B8h] [ebp+10h]
  char *Srcb; // [esp+B8h] [ebp+10h]
  char *Srcc; // [esp+B8h] [ebp+10h]
  char *Srcd; // [esp+B8h] [ebp+10h]
  char *Srce; // [esp+B8h] [ebp+10h]

  CDB::CDB(&v56);
  v60 = 0;
  Srca = ReadPacket((char *)Src, "s", &v48);
  CDB::Bind(&v56, &TargetValue);
  if ( CDB::Execute(&v56, "SELECT COUNT(*) FROM Player WHERE [Name] = '%s'", v48) && CDB::Fetch(&v56) && TargetValue > 0 )
  {
    CSocket::Write((int)this, 15, "db", a2, 4);
    v60 = -1;
    CDB::~CDB(&v56);
  }
  else
  {
    CDB::Reset(&v56);
    Srcb = ReadPacket(
             Srca,
             "bbbbwIbbbbbwwwwbbdddbbb",
             &v57,
             &v44,
             &v58,
             &v39,
             &v47,
             &v55,
             &v53,
             &v49,
             &v46,
             &v34,
             &v35,
             &v41,
             &v36,
             &v42,
             v43,
             &v59,
             &v45,
             &v51,
             &v37,
             &v38,
             &v50,
             &v40,
             &v54);
    if ( CDB::ExecuteInsertUnique(
           &v56,
           "INSERT INTO Player ( [UID], [Admin], [Name], [Class], [Specialty], [Level], [Contribute], [Exp], [Strength], "
           "[Health], [Intelligence], [Wisdom], [Dexterity], [CurHP], [CurMP], [PUPoint], [SUPoint], [Killed], [Map], [X]"
           ", [Y], [Z], [Face], [Hair], [RevivalId]) VALUES ( %d, %d, '%s', %d, %d, %d, %d, %I64d, %d, %d, %d, %d, %d, %d"
           ", %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)",
           a3,
           v57,
           v48,
           v44,
           v58,
           v39,
           v47,
           v55,
           v53,
           v49,
           v46,
           v34,
           v35,
           v41,
           v36,
           v42,
           v43[0],
           v59,
           v45,
           v51,
           v37,
           v38,
           v50,
           v40,
           v54) )
    {
      CSocket::Write((int)this, 15, "db", a2, 0);
    }
    else
    {
      CDB::Reset(&v56);
      CDB::Bind(&v56, &n);
      if ( CDB::Execute(&v56, "SELECT [PID] FROM Player WHERE [Name] = '%s'", v48) && CDB::Fetch(&v56) )
      {
        Srcc = GetNumeric<unsigned char>(Srcb, &v15);
        for ( i = 0; i < v15; ++i )
        {
          Srcc = ReadPacket(
                   Srcc,
                   "dwbddbbbbbbbbbbb",
                   &v30,
                   v11,
                   &v22,
                   &v18,
                   &v19,
                   &v20,
                   &v23,
                   &v26,
                   &v21,
                   &v14,
                   &v24,
                   &v25,
                   &v16,
                   &v31,
                   &v27,
                   &v17);
          CSocket::s_nIID = v30;
          CDB::Reset(&v56);
          CDB::Execute(
            &v56,
            "INSERT INTO Item VALUES ( %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)",
            n,
            v30,
            v11[0],
            v22,
            v18,
            v19,
            v20,
            v23,
            v26,
            v21,
            v14,
            v24,
            v25,
            v16,
            v31,
            v27,
            v17);
        }
        Srcd = GetNumeric<unsigned char>(Srcc, &v15);
        for ( j = 0; j < v15; ++j )
        {
          Srcd = ReadPacket(Srcd, "bb", &v12, &v32);
          CDB::Reset(&v56);
          CDB::Execute(&v56, "INSERT INTO Skill VALUES ( %d, %d, %d)", n, v12, v32);
        }
        Srce = GetNumeric<unsigned char>(Srcd, &v15);
        for ( k = 0; k < v15; ++k )
        {
          Srce = ReadPacket(Srce, "wbb", v28, &v13, &v29);
          CDB::Reset(&v56);
          CDB::Execute(&v56, "INSERT INTO Quest VALUES ( %d, %d, %d, %d)", n, v28[0], v13, v29);
        }
        CSocket::Write((int)this, 15, "db", a2, 1);
      }
      else
      {
        CSocket::Write((int)this, 15, "db", a2, 0);
      }
    }
    v60 = -1;
    CDB::~CDB(&v56);
  }
}

//----- (0041A280) --------------------------------------------------------
void __stdcall sub_41A280(const char *a1, const char *a2, const char *a3)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::Execute(&v3, "INSERT INTO PKBulletin VALUES ( '%s', '%s', '%s')", a1, a2, a3);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (0041A2F0) --------------------------------------------------------
void __thiscall sub_41A2F0(void *this)
{
  char TargetValue[20]; // [esp+4h] [ebp-6Ch] BYREF
  char *v6; // [esp+18h] [ebp-58h]
  char *packet; // [esp+1Ch] [ebp-54h]
  unsigned __int16 *v8; // [esp+20h] [ebp-50h]
  char str[20]; // [esp+24h] [ebp-4Ch] BYREF
  char v10[20]; // [esp+38h] [ebp-38h] BYREF
  CDB v11; // [esp+50h] [ebp-20h] BYREF
  void *Src; // [esp+60h] [ebp-10h]
  int v13; // [esp+6Ch] [ebp-4h]

  Src = CIOBuffer::Alloc();
  v8 = (unsigned __int16 *)Src;
  *((_BYTE *)Src + 2) = 16;
  packet = (char *)v8 + 3;
  CDB::CDB(&v11);
  v13 = 0;
  CDB::Bind(&v11, TargetValue, 17);
  CDB::Bind(&v11, str, 17);
  CDB::Bind(&v11, v10, 17);
  v6 = packet++;
  *v6 = 0;
  if ( CDB::Execute(
         &v11,
         "SELECT TOP %d [NameGuild], [NameCatch], [NameAssassin] FROM PKBulletin ORDER BY [Index] DESC",
         20) )
  {
    while ( CDB::Fetch(&v11) )
    {
      packet = PutString(packet, TargetValue);
      packet = PutString(packet, str);
      packet = PutString(packet, v10);
      ++*v6;
    }
    if ( *v6 )
    {
      *v8 = (_WORD)packet - (_WORD)v8;
      *((_DWORD *)Src + 2000) = *v8;
      CIOSocket::Write((CIOSocket *)this, (CIOBuffer *)Src);
    }
    else
    {
      CIOBuffer::Release((CIOBuffer *)Src);
    }
  }
  v13 = -1;
  CDB::~CDB(&v11);
}

//----- (0041A450) --------------------------------------------------------
void __thiscall sub_41A450(void *this, int a2, int a3, void *Src)
{
  int v8; // [esp+4h] [ebp-50h] BYREF
  char TargetValue[40]; // [esp+8h] [ebp-4Ch] BYREF
  SQLINTEGER StrLen_or_Ind; // [esp+34h] [ebp-20h] BYREF
  CDB v11; // [esp+38h] [ebp-1Ch] BYREF
  int v12; // [esp+50h] [ebp-4h]

  StrLen_or_Ind = 0;
  CDB::CDB(&v11);
  v12 = 0;
  if ( a2 )
  {
    ReadPacket((char *)Src, "m", TargetValue, 40);
    StrLen_or_Ind = 40;
    sub_41B310(&v11.m_hStmt, 1u, 1, -2, -3, 0x28u, 0, TargetValue, 40, &StrLen_or_Ind);
    if ( !CDB::ExecuteNoData(&v11, "UPDATE Shortcut SET [Keys] = ? WHERE [PID] = %d", a3) )
      CDB::ExecuteInsertUnique(&v11, "INSERT INTO Shortcut VALUES ( %d, ?)", a3);
  }
  else
  {
    ReadPacket((char *)Src, "d", &v8);
    sub_41B2B0((int)&v11, -2, TargetValue, 40, &StrLen_or_Ind);
    if ( CDB::Execute(&v11, "SELECT [Keys] FROM Shortcut WHERE [PID] = %d", a3) && CDB::Fetch(&v11) )
      CSocket::Write((int)this, 19, "dbm", v8, 1, TargetValue, 40);
    else
      CSocket::Write((int)this, 19, "db", v8, 0);
  }
  v12 = -1;
  CDB::~CDB(&v11);
}

//----- (0041A5B0) --------------------------------------------------------
void __thiscall sub_41A5B0(void *this, int a2, int a3)
{
  char str[24]; // [esp+4h] [ebp-58h] BYREF
  int v8; // [esp+20h] [ebp-3Ch] BYREF
  int v9; // [esp+24h] [ebp-38h] BYREF
  char *packet; // [esp+28h] [ebp-34h]
  char TargetValue; // [esp+2Fh] [ebp-2Dh] BYREF
  char *v12; // [esp+30h] [ebp-2Ch]
  int n; // [esp+34h] [ebp-28h] BYREF
  int v14; // [esp+38h] [ebp-24h]
  CDB v15; // [esp+3Ch] [ebp-20h] BYREF
  void *Src; // [esp+4Ch] [ebp-10h]
  int v17; // [esp+58h] [ebp-4h]

  Src = CIOBuffer::Alloc();
  v12 = (char *)Src;
  *((_BYTE *)Src + 2) = 22;
  packet = v12 + 8;
  v14 = 0;
  CDB::CDB(&v15);
  v17 = 0;
  CDB::Skip(&v15);
  CDB::Bind(&v15, str, 21);
  CDB::Bind(&TargetValue);
  CDB::Bind(&v15, &n);
  CDB::Bind(&v15, &v8);
  CDB::Bind(&v15, &v9);
  if ( CDB::Execute(&v15, "SELECT * FROM Teleport WHERE [PID] = %d", a3) )
  {
    while ( CDB::Fetch(&v15) )
    {
      packet = PutString(packet, str);
      packet = PutNumeric<unsigned char>(packet, TargetValue);
      packet = (char *)PutNumeric<int>(packet, n);
      packet = (char *)PutNumeric<int>(packet, v8);
      packet = (char *)PutNumeric<int>(packet, v9);
      ++v14;
    }
  }
  WritePacket(v12 + 3, "db", a2, v14);
  *(_WORD *)v12 = (_WORD)packet - (_WORD)v12;
  *((_DWORD *)Src + 2000) = *(unsigned __int16 *)v12;
  CIOSocket::Write((CIOSocket *)this, (CIOBuffer *)Src);
  v17 = -1;
  CDB::~CDB(&v15);
}
// 41B150: using guessed type int __thiscall CDB::Skip(_DWORD);

//----- (0041A750) --------------------------------------------------------
void __thiscall sub_41A750(void *this, int a2, int a3, int a4, void *Src)
{
  char v9[4]; // [esp+8h] [ebp-34h] BYREF
  __int16 v10; // [esp+Ch] [ebp-30h]
  int v11; // [esp+10h] [ebp-2Ch] BYREF
  int v12; // [esp+14h] [ebp-28h] BYREF
  unsigned __int8 v13; // [esp+1Bh] [ebp-21h] BYREF
  int v14; // [esp+1Ch] [ebp-20h] BYREF
  CDB v15; // [esp+20h] [ebp-1Ch] BYREF
  int v16; // [esp+38h] [ebp-4h]

  CDB::CDB(&v15);
  v16 = 0;
  if ( a3 )
  {
    if ( a3 == 1 )
    {
      CDB::ExecuteNoData(&v15, "DELETE FROM Teleport WHERE [PID] = %d AND [LocName] = '%s'", a2, (const char *)a4);
    }
    else if ( a3 == 2 )
    {
      ReadPacket((char *)Src, "s", v9);
      CDB::ExecuteNoData(
        &v15,
        "UPDATE Teleport SET [LocName] = '%s' WHERE [PID] = %d AND [LocName] = '%s'",
        *(const char **)v9,
        a2,
        (const char *)a4);
    }
  }
  else
  {
    ReadPacket((char *)Src, "bddd", &v13, &v14, &v11, &v12);
    v10 = CDB::ExecuteInsertUnique(
            &v15,
            "INSERT INTO Teleport VALUES ( %d, '%s', %d, %d, %d, %d)",
            a2,
            (const char *)a4,
            v13,
            v14,
            v11,
            v12);
    CSocket::Write((int)this, 23, "dbbs", a2, 0, v10 == 0, a4);
  }
  v16 = -1;
  CDB::~CDB(&v15);
}

//----- (0041A890) --------------------------------------------------------
void __thiscall sub_41A890(void *this, int a2, int a3, const char *a4, const char *a5)
{
  CDB v9; // [esp+4h] [ebp-1Ch] BYREF
  int v10; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v9);
  v10 = 0;
  if ( CDB::ExecuteInsertUnique(&v9, "UPDATE Player SET [Name] = '%s' WHERE [PID] = %d", a5, a3) )
  {
    CSocket::Write((int)this, 26, "dbs", a2, 0, a5);
  }
  else
  {
    CDB::Reset(&v9);
    CDB::ExecuteNoData(&v9, "UPDATE MLM SET [Name] = '%s' WHERE [RPID] = %d AND [Relation] <> 0", a5, a3);
    CDB::Reset(&v9);
    CDB::ExecuteNoData(&v9, "UPDATE PKBulletin SET [NameCatch] = '%s' WHERE [NameCatch] = '%s'", a5, a4);
    CDB::Reset(&v9);
    CDB::ExecuteNoData(&v9, "UPDATE PKBulletin SET [NameAssassin] = '%s' WHERE [NameAssassin] = '%s'", a5, a4);
    CDB::Reset(&v9);
    CDB::ExecuteNoData(&v9, "UPDATE Friend SET [FName] = '%s' WHERE [FPID] = %d", a5, a3);
    CDB::Reset(&v9);
    CDB::ExecuteNoData(&v9, "UPDATE Mail SET [SName] = '%s' WHERE [SPID] = %d", a5, a3);
    CDB::Reset(&v9);
    CDB::ExecuteNoData(&v9, "UPDATE Mail SET [RName] = '%s' WHERE [RPID] = %d", a5, a3);
    CDB::Reset(&v9);
    CDB::Execute(&v9, "INSERT INTO NameChanged VALUES (GETDATE(), 0, %d, '%s', '%s')", a3, a4, a5);
    CSocket::Write((int)this, 26, "dbs", a2, 1, a5);
  }
  v10 = -1;
  CDB::~CDB(&v9);
}

//----- (0041AA30) --------------------------------------------------------
void __thiscall sub_41AA30(void *this, int a2, int a3, const char *a4, const char *a5)
{
  CDB v9; // [esp+4h] [ebp-1Ch] BYREF
  int v10; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v9);
  v10 = 0;
  if ( CDB::ExecuteInsertUnique(&v9, "UPDATE Guild SET [Name] = '%s' WHERE [GID] = %d", a5, a3) )
  {
    CSocket::Write((int)this, 27, "dbs", a2, 0, a5);
  }
  else
  {
    CDB::Reset(&v9);
    CDB::ExecuteNoData(&v9, "UPDATE PKBulletin SET [NameGuild] = '%s' WHERE [NameGuild] = '%s'", a5, a4);
    CDB::Reset(&v9);
    CDB::Execute(&v9, "INSERT INTO NameChanged VALUES (GETDATE(), 1, %d, '%s', '%s')", a3, a4, a5);
    CSocket::Write((int)this, 27, "dbs", a2, 1, a5);
  }
  v10 = -1;
  CDB::~CDB(&v9);
}

//----- (0041AB20) --------------------------------------------------------
void __stdcall sub_41AB20(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  CDB v7; // [esp+4h] [ebp-1Ch] BYREF
  int v8; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v7);
  v8 = 0;
  CDB::Execute(
    &v7,
    "INSERT INTO [Statistics] ([Knight], [Mage], [Archer], [TotalUser],[FishTrap], [PrivateShop], [Currency]) VALUES (%d,"
    " %d, %d, %d, %d, %d, %d)",
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7);
  v8 = -1;
  CDB::~CDB(&v7);
}

//----- (0041ABA0) --------------------------------------------------------
void __stdcall sub_41ABA0(int a1, int a2, int a3)
{
  CDB v3; // [esp+4h] [ebp-1Ch] BYREF
  int v4; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v3);
  v4 = 0;
  CDB::ExecuteNoData(&v3, "UPDATE Player SET [Face] = %d, [Hair] = %d WHERE [PID] = %d", a2, a3, a1);
  LOG_DB(0, 52, a1, 0, 0, a2, a3, 0, 0);
  v4 = -1;
  CDB::~CDB(&v3);
}

//----- (0041AC30) --------------------------------------------------------
void __stdcall sub_41AC30(int a1, int a2, int a3)
{
  CDB v3; // [esp+4h] [ebp-10h] BYREF

  CDB::CDB(&v3);
  CDB::~CDB(&v3);
}

//----- (0041AC50) --------------------------------------------------------
void __thiscall sub_41AC50(void *this, int a2, int a3)
{
  int TargetValue; // [esp+4h] [ebp-20h] BYREF
  CDB v8; // [esp+8h] [ebp-1Ch] BYREF
  int v9; // [esp+20h] [ebp-4h]

  TargetValue = 0;
  CDB::CDB(&v8);
  v9 = 0;
  CDB::Bind(&v8, &TargetValue);
  if ( CDB::Execute(&v8, "SELECT Event FROM Event_PID WHERE [PID] = %d", a2) && CDB::Fetch(&v8) )
    CSocket::Write((int)this, 28, "ddd", a2, TargetValue, a3);
  else
    CSocket::Write((int)this, 28, "ddd", a2, 0, a3);
  v9 = -1;
  CDB::~CDB(&v8);
}

//----- (0041AD20) --------------------------------------------------------
void __stdcall sub_41AD20(int a1, int a2)
{
  CDB v2; // [esp+4h] [ebp-1Ch] BYREF
  int v3; // [esp+1Ch] [ebp-4h]

  CDB::CDB(&v2);
  v3 = 0;
  CDB::Execute(&v2, "UPDATE Event_PID SET [EVENT] = %d WHERE [PID] = %d", a2, a1);
  v3 = -1;
  CDB::~CDB(&v2);
}

//----- (0041AD90) --------------------------------------------------------
int __stdcall sub_41AD90(int a1, int a2)
{
  int result; // eax
  int TargetValue; // [esp+14h] [ebp-20h] BYREF
  CDB v4; // [esp+18h] [ebp-1Ch] BYREF
  int v5; // [esp+30h] [ebp-4h]

  CDB::CDB(&v4);
  v5 = 0;
  CDB::Bind(&v4, &TargetValue);
  if ( CDB::Execute(&v4, "SELECT COUNT(*) FROM Player WHERE [UID] = %d", a1) && CDB::Fetch(&v4) )
  {
    if ( TargetValue >= 5 )
    {
      v5 = -1;
      CDB::~CDB(&v4);
      result = 1;
    }
    else
    {
      CDB::Reset(&v4);
      CDB::Bind(&v4, &a1);
      CDB::Execute(&v4, "SELECT UID FROM PlayerDeleted WHERE [PID] = %d", a2);
      if ( CDB::Fetch(&v4) )
      {
        CDB::Reset(&v4);
        CDB::Execute(&v4, "UPDATE Player SET [UID] = %d WHERE [PID] = %d", a1, a2);
        CDB::Reset(&v4);
        CDB::Execute(&v4, "DELETE FROM PlayerDeleted WHERE PID = %d", a2);
        v5 = -1;
        CDB::~CDB(&v4);
        result = 0;
      }
      else
      {
        v5 = -1;
        CDB::~CDB(&v4);
        result = 2;
      }
    }
  }
  else
  {
    v5 = -1;
    CDB::~CDB(&v4);
    result = 3;
  }
  return result;
}

//----- (0041AEF0) --------------------------------------------------------
void __thiscall CSyncPacket::Pop(CSyncPacket *this)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  int v4; // [esp-4h] [ebp-24h]
  char v6[4]; // [esp+8h] [ebp-18h] BYREF
  char v7[4]; // [esp+Ch] [ebp-14h] BYREF
  CSyncPacket::CElement v8; // [esp+10h] [ebp-10h] BYREF

  CSyncPacket::CElement::CElement(&v8, (CSocket *)0x7FFFFFFF, (CIOBuffer *)0xFFFFFFFF, 0);
  v2 = v1;
  v3 = (_DWORD *)std::vector<CSyncPacket::CElement>::iterator::operator*((char *)this + 32);
  *v3 = *v2;
  v3[1] = v2[1];
  v3[2] = v2[2];
  v3[3] = v2[3];
  v4 = std::vector<CIOSocket::CIOTimer>::end((_DWORD *)this + 4, (int)v7);
  std::vector<CSyncPacket::CElement>::iterator::operator++((_DWORD *)this + 8);
  if ( (unsigned __int8)unknown_libname_18(v4) )
    *((_DWORD *)this + 8) = *(_DWORD *)std::vector<CSyncPacket::CElement>::begin((int *)this + 4, v6);
}
// 41AF0B: variable 'v1' is possibly undefined
// 405110: using guessed type _DWORD __stdcall unknown_libname_18(_DWORD);

//----- (0041AF80) --------------------------------------------------------
void __thiscall CSyncPacket::CElement::CElement(CSyncPacket::CElement *this, CSocket *pSocket, CIOBuffer *pBuf, DBPACKET *packet)
{
  this->m_pSocket = pSocket;
  this->m_pBuf = pBuf;
  this->m_packet = packet;
  if ( packet )
    memcpy(this->data, packet, sizeof(this->data));
  else
    memset(this->data, 0, sizeof(this->data));
}

//----- (0041AFE0) --------------------------------------------------------
int __thiscall CSyncPacket::Front(char *this)
{
  return std::vector<CSyncPacket::CElement>::iterator::operator*(this + 32);
}

//----- (0041B000) --------------------------------------------------------
_DWORD *__thiscall CIOSocket::CIOTimerInstance::`scalar deleting destructor'(_DWORD *this, char a2)
{
  sub_410AB0(this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (0041B030) --------------------------------------------------------
LONG __thiscall CIOBuffer::AddRef(volatile LONG *this)
{
  return InterlockedIncrement(this + 2001);
}

//----- (0041B050) --------------------------------------------------------
void __thiscall CSyncPacket::Push(CSyncPacket *this, CSyncPacket::CElement *element)
{
  int v2; // eax
  int v3; // [esp-4h] [ebp-2Ch]
  char v5[4]; // [esp+8h] [ebp-20h] BYREF
  char v6[4]; // [esp+Ch] [ebp-1Ch] BYREF
  char v7[16]; // [esp+10h] [ebp-18h] BYREF
  char v8[4]; // [esp+20h] [ebp-8h] BYREF
  char v9[4]; // [esp+24h] [ebp-4h] BYREF

  *(CSyncPacket::CElement *)std::vector<CSyncPacket::CElement>::iterator::operator*((char *)this + 36) = *element;
  v3 = std::vector<CIOSocket::CIOTimer>::end((_DWORD *)this + 4, (int)v9);
  std::vector<CSyncPacket::CElement>::iterator::operator++((_DWORD *)this + 9);
  if ( (unsigned __int8)unknown_libname_18(v3) )
    *((_DWORD *)this + 9) = *(_DWORD *)std::vector<CSyncPacket::CElement>::begin((int *)this + 4, v8);
  if ( (unsigned __int8)unknown_libname_18((char *)this + 36) )
  {
    Concurrency::details::UMSFreeVirtualProcessorRoot::~UMSFreeVirtualProcessorRoot((Concurrency::details::UMSFreeVirtualProcessorRoot *)v7);
    *((_DWORD *)this + 9) = *(_DWORD *)std::vector<CSyncPacket::CElement>::insert(
                                         (int *)this + 4,
                                         (int)v6,
                                         *((_DWORD *)this + 9),
                                         v2);
    *((_DWORD *)this + 8) = *sub_41B5C0((int *)this + 9, v5, 1);
  }
}
// 41B0F1: variable 'v2' is possibly undefined
// 405110: using guessed type _DWORD __stdcall unknown_libname_18(_DWORD);

//----- (0041B1C0) --------------------------------------------------------
void __thiscall CDB::Bind(CDB *this, int *n)
{
  *n = 0;
  ++this->m_nBind;
  SQLBindCol(this->m_hStmt, this->m_nBind, 4, n, 4, &this->m_nInd);
}

//----- (0041B210) --------------------------------------------------------
void __thiscall CDB::Bind(CDB *this, __int64 *n)
{
  *n = 0i64;
  ++this->m_nBind;
  SQLBindCol(this->m_hStmt, this->m_nBind, -25, n, 8, &this->m_nInd);
}

//----- (0041B260) --------------------------------------------------------
void __thiscall CDB::Bind(CDB *this, char *str, int size)
{
  *str = 0;
  ++this->m_nBind;
  SQLBindCol(this->m_hStmt, this->m_nBind, 1, str, size, &this->m_nInd);
}

//----- (0041B2B0) --------------------------------------------------------
SQLRETURN __thiscall sub_41B2B0(int this, SQLSMALLINT TargetType, SQLPOINTER TargetValue, SQLINTEGER BufferLength, SQLINTEGER *StrLen_or_Ind)
{
  ++*(_DWORD *)(this + 12);
  return SQLBindCol(*(SQLHSTMT *)this, *(_WORD *)(this + 12), TargetType, TargetValue, BufferLength, StrLen_or_Ind);
}

//----- (0041B310) --------------------------------------------------------
SQLRETURN __thiscall sub_41B310(SQLHSTMT *this, SQLUSMALLINT ipar, SQLSMALLINT fParamType, SQLSMALLINT fCType, SQLSMALLINT fSqlType, SQLUINTEGER cbColDef, SQLSMALLINT ibScale, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER *pcbValue)
{
  return SQLBindParameter(*this, ipar, fParamType, fCType, fSqlType, cbColDef, ibScale, rgbValue, cbValueMax, pcbValue);
}

//----- (0041B360) --------------------------------------------------------
int __cdecl sub_41B360(int a1, int a2)
{
  int result; // eax

  if ( a1 >= a2 )
    result = a1;
  else
    result = a1 + sub_41C5A0() % (unsigned int)(a2 - a1 + 1);
  return result;
}

//----- (0041B390) --------------------------------------------------------
void __thiscall CDB::Bind(CDB *this, unsigned __int16 *n)
{
  *n = 0;
  ++this->m_nBind;
  SQLBindCol(this->m_hStmt, this->m_nBind, 5, n, 2, &this->m_nInd);
}

//----- (0041B3E0) --------------------------------------------------------
BOOL __thiscall std::vector<IPAddrMask>::empty(_DWORD *this)
{
  return std::vector<IPAddrMask>::size(this) == 0;
}

//----- (0041B400) --------------------------------------------------------
_DWORD *CMemoryPool<CPacket>::Alloc()
{
  _DWORD *result; // eax
  _DWORD *v1; // [esp+0h] [ebp-1Ch]
  CMemory **v2; // [esp+4h] [ebp-18h]
  _DWORD *v3; // [esp+Ch] [ebp-10h]

  CIOSpinLock::Enter(&dword_448DE4);
  v3 = (_DWORD *)dword_448DE0;
  if ( dword_448DE0 )
  {
    dword_448DE0 = *(_DWORD *)(dword_448DE0 + 16);
    CIOSpinLock::Leave(&dword_448DE4);
    result = v3;
  }
  else
  {
    CIOSpinLock::Leave(&dword_448DE4);
    v2 = operator new(0x18u);
    if ( v2 )
      v1 = sub_41B640(v2);
    else
      v1 = 0;
    result = v1;
  }
  return result;
}
// 448DE0: using guessed type int dword_448DE0;

//----- (0041B4B0) --------------------------------------------------------
LONG __cdecl sub_41B4B0(int a1)
{
  CIOSpinLock::Enter(&dword_448DE4);
  *(_DWORD *)(a1 + 16) = dword_448DE0;
  dword_448DE0 = a1;
  return CIOSpinLock::Leave(&dword_448DE4);
}
// 448DE0: using guessed type int dword_448DE0;

//----- (0041B4E0) --------------------------------------------------------
void *__thiscall std::vector<CSyncPacket::CElement>::begin(int *this, void *a2)
{
  sub_403E30(a2, this[1]);
  return a2;
}

//----- (0041B500) --------------------------------------------------------
int __thiscall std::vector<CSyncPacket::CElement>::insert(int *this, int a2, int a3, int a4)
{
  void *v4; // eax
  int *v5; // eax
  int v7; // [esp-4h] [ebp-18h]
  int v8; // [esp+0h] [ebp-14h]
  char v10[4]; // [esp+8h] [ebp-Ch] BYREF
  char v11[4]; // [esp+Ch] [ebp-8h] BYREF
  int v12; // [esp+10h] [ebp-4h]

  if ( std::vector<CSyncPacket::CElement>::size(this) )
  {
    v4 = std::vector<CSyncPacket::CElement>::begin(this, v11);
    v8 = std::vector<CSyncPacket::CElement>::iterator::operator-(&a3, (int)v4);
  }
  else
  {
    v8 = 0;
  }
  v12 = v8;
  std::vector<CSyncPacket::CElement>::_Insert_n(this, a3, 1u, (int *)a4);
  v7 = v12;
  v5 = (int *)std::vector<CSyncPacket::CElement>::begin(this, v10);
  sub_41B5C0(v5, (_DWORD *)a2, v7);
  return a2;
}

//----- (0041B580) --------------------------------------------------------
int __thiscall std::vector<CSyncPacket::CElement>::iterator::operator*(void *this)
{
  return unknown_libname_17(this);
}
// 405100: using guessed type int __thiscall unknown_libname_17(_DWORD);

//----- (0041B5A0) --------------------------------------------------------
_DWORD *__thiscall std::vector<CSyncPacket::CElement>::iterator::operator++(_DWORD *this)
{
  *this += 16;
  return this;
}

//----- (0041B5C0) --------------------------------------------------------
_DWORD *__thiscall sub_41B5C0(int *this, _DWORD *a1, int a2)
{
  int v4; // [esp+4h] [ebp-4h] BYREF

  v4 = *this;
  *a1 = *std::vector<CSyncPacket::CElement>::iterator::operator+=(&v4, a2);
  return a1;
}

//----- (0041B5F0) --------------------------------------------------------
int __thiscall std::vector<IPAddrMask>::iterator::operator->(void *this)
{
  return std::vector<CSyncPacket::CElement>::iterator::operator*(this);
}

//----- (0041B610) --------------------------------------------------------
_DWORD *__thiscall std::vector<IPAddrMask>::iterator::operator++(int *this, _DWORD *a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  v4 = *this;
  unknown_libname_16(this);
  *a2 = v4;
  return a2;
}
// 4050E0: using guessed type int __thiscall unknown_libname_16(_DWORD);

//----- (0041B640) --------------------------------------------------------
_DWORD *__thiscall sub_41B640(_DWORD *this)
{
  CIOObject::CIOObject((CIOObject *)this);
  *this = &off_42F870;
  return this;
}
// 42F870: using guessed type int (__stdcall *off_42F870)(int);

//----- (0041B660) --------------------------------------------------------
_DWORD *__thiscall sub_41B660(_DWORD *this)
{
  return CIOObject::~CIOObject(this);
}

//----- (0041B680) --------------------------------------------------------
int __thiscall std::vector<CSyncPacket::CElement>::size(_DWORD *this)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( this[1] )
    v2 = (this[2] - this[1]) >> 4;
  else
    v2 = 0;
  return v2;
}

//----- (0041B6C0) --------------------------------------------------------
void *__thiscall std::vector<CSyncPacket::CElement>::_Insert_n(_DWORD *this, int a2, unsigned int a3, int *a4)
{
  void *result; // eax
  int v5; // esi
  int v6; // eax
  unsigned int v7; // esi
  int v8; // eax
  int v9; // eax
  void *v10; // eax
  int v11; // [esp+0h] [ebp-50h] BYREF
  void *v12; // [esp+Ch] [ebp-44h]
  void *v13; // [esp+10h] [ebp-40h]
  unsigned int v14; // [esp+14h] [ebp-3Ch]
  int *v15; // [esp+18h] [ebp-38h]
  int v16; // [esp+1Ch] [ebp-34h]
  void *v17; // [esp+20h] [ebp-30h]
  void *v18; // [esp+24h] [ebp-2Ch]
  unsigned int v19; // [esp+28h] [ebp-28h]
  int v20[6]; // [esp+2Ch] [ebp-24h] BYREF
  int v21; // [esp+4Ch] [ebp-4h]
  int v22; // [esp+5Ch] [ebp+Ch]

  v20[5] = (int)&v11;
  v15 = this;
  v20[0] = *a4;
  v20[1] = a4[1];
  v20[2] = a4[2];
  v20[3] = a4[3];
  result = (void *)std::vector<CSyncPacket::CElement>::capacity(this);
  v19 = (unsigned int)result;
  if ( a3 )
  {
    v5 = std::vector<CSyncPacket::CElement>::size(v15);
    if ( std::vector<CSyncPacket::CElement>::max_size(v15) - v5 < a3 )
      std::vector<CSyncPacket::CElement>::_Xlen();
    v6 = std::vector<CSyncPacket::CElement>::size(v15);
    if ( v19 >= a3 + v6 )
    {
      if ( (v15[2] - a2) >> 4 >= a3 )
      {
        v16 = v15[2];
        v10 = std::vector<CSyncPacket::CElement>::_Ucopy<CSyncPacket::CElement *>(
                v15,
                v16 - 16 * a3,
                v16,
                (void *)v15[2]);
        v15[2] = (int)v10;
        sub_41BD10(a2, v16 - 16 * a3, v16);
        result = std::fill<CSyncPacket::CElement *,CSyncPacket::CElement>((_DWORD *)a2, (_DWORD *)(a2 + 16 * a3), v20);
      }
      else
      {
        std::vector<CSyncPacket::CElement>::_Ucopy<CSyncPacket::CElement *>(v15, a2, v15[2], (void *)(a2 + 16 * a3));
        v21 = 2;
        std::vector<CSyncPacket::CElement>::_Ufill(v15, (void *)v15[2], a3 - ((v15[2] - a2) >> 4), (int)v20);
        v21 = -1;
        v15[2] += 16 * a3;
        result = std::fill<CSyncPacket::CElement *,CSyncPacket::CElement>(
                   (_DWORD *)a2,
                   (_DWORD *)(v15[2] - 16 * a3),
                   v20);
      }
    }
    else
    {
      v7 = v19 >> 1;
      v8 = std::vector<CSyncPacket::CElement>::max_size(v15);
      if ( v8 - v7 >= v19 )
        v14 = v19 + (v19 >> 1);
      else
        v14 = 0;
      v19 = v14;
      v9 = std::vector<CSyncPacket::CElement>::size(v15);
      if ( v19 < a3 + v9 )
        v19 = a3 + std::vector<CSyncPacket::CElement>::size(v15);
      v17 = std::allocator<CSyncPacket::CElement>::allocate(v19);
      v18 = v17;
      v21 = 0;
      v13 = std::vector<CSyncPacket::CElement>::_Ucopy<CSyncPacket::CElement *>(v15, v15[1], a2, v17);
      v18 = v13;
      v12 = (void *)std::vector<CSyncPacket::CElement>::_Ufill(v15, v13, a3, (int)v20);
      v18 = v12;
      std::vector<CSyncPacket::CElement>::_Ucopy<CSyncPacket::CElement *>(v15, a2, v15[2], v12);
      v21 = -1;
      v22 = a3 + std::vector<CSyncPacket::CElement>::size(v15);
      if ( v15[1] )
      {
        std::vector<CSyncPacket::CElement>::_Destroy(v15, v15[1], v15[2]);
        std::allocator<CSyncPacket::CElement>::deallocate(v15[1], (v15[3] - v15[1]) >> 4);
      }
      v15[3] = (int)v17 + 16 * v19;
      v15[2] = (int)v17 + 16 * v22;
      result = v17;
      v15[1] = (int)v17;
    }
  }
  return result;
}

//----- (0041BA00) --------------------------------------------------------
_DWORD *__thiscall std::vector<CSyncPacket::CElement>::iterator::operator+=(_DWORD *this, int a2)
{
  *this += 16 * a2;
  return this;
}

//----- (0041BA20) --------------------------------------------------------
int __thiscall std::vector<CSyncPacket::CElement>::iterator::operator-(int *this, int a1)
{
  int v3; // [esp+4h] [ebp-4h] BYREF

  v3 = *this;
  return std::vector<CSyncPacket::CElement>::const_iterator::operator-(&v3, (_DWORD *)a1);
}

//----- (0041BA50) --------------------------------------------------------
int __thiscall std::vector<CSyncPacket::CElement>::capacity(_DWORD *this)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( this[1] )
    v2 = (this[3] - this[1]) >> 4;
  else
    v2 = 0;
  return v2;
}

//----- (0041BA90) --------------------------------------------------------
int __thiscall std::vector<CSyncPacket::CElement>::max_size(void *this)
{
  return std::allocator<CSyncPacket::CElement>::max_size();
}

//----- (0041BAB0) --------------------------------------------------------
int __thiscall std::vector<CSyncPacket::CElement>::_Destroy(void *this, int a2, int a3)
{
  return sub_41BD50(a2, a3);
}

//----- (0041BAE0) --------------------------------------------------------
int __thiscall std::vector<CSyncPacket::CElement>::_Ufill(void *this, void *a2, int a3, int a4)
{
  sub_41BD90(a2, a3, a4);
  return (int)a2 + 16 * a3;
}

//----- (0041BB10) --------------------------------------------------------
void __noreturn std::vector<CSyncPacket::CElement>::_Xlen()
{
  char v0[28]; // [esp+4h] [ebp-50h] BYREF
  char pExceptionObject[48]; // [esp+20h] [ebp-34h] BYREF
  int v2; // [esp+50h] [ebp-4h]

  std::string::string(v0, "vector<T> too long");
  v2 = 0;
  std::length_error::length_error((std::length_error *)pExceptionObject, (const std::length_error *)v0);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);
}

//----- (0041BB70) --------------------------------------------------------
CMemory **__stdcall std::allocator<CSyncPacket::CElement>::allocate(int a1)
{
  return sub_41BDD0(a1);
}

//----- (0041BB90) --------------------------------------------------------
int __thiscall std::vector<CSyncPacket::CElement>::const_iterator::operator-(_DWORD *this, _DWORD *a2)
{
  return (*this - *a2) >> 4;
}

//----- (0041BBB0) --------------------------------------------------------
int std::allocator<CSyncPacket::CElement>::max_size()
{
  return 0xFFFFFFF;
}

//----- (0041BBE0) --------------------------------------------------------
_BYTE *__cdecl PutNumeric<unsigned char>(_BYTE *a1, char a2)
{
  *a1 = a2;
  return a1 + 1;
}

//----- (0041BC00) --------------------------------------------------------
_WORD *__cdecl PutNumeric<short>(_WORD *a1, __int16 a2)
{
  *a1 = a2;
  return a1 + 1;
}

//----- (0041BC20) --------------------------------------------------------
_DWORD *__cdecl PutNumeric<__int64>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1 + 2;
}

//----- (0041BC40) --------------------------------------------------------
_DWORD *__cdecl PutNumeric<int>(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1 + 1;
}

//----- (0041BC60) --------------------------------------------------------
_BYTE *__cdecl GetNumeric<unsigned char>(_BYTE *a1, _BYTE *a2)
{
  *a2 = *a1;
  return a1 + 1;
}

//----- (0041BC80) --------------------------------------------------------
_DWORD *__cdecl GetNumeric<int>(_DWORD *a1, _DWORD *a2)
{
  *a2 = *a1;
  return a1 + 1;
}

//----- (0041BCA0) --------------------------------------------------------
void *__thiscall std::vector<CSyncPacket::CElement>::_Ucopy<CSyncPacket::CElement *>(void *this, int a2, int a3, void *a4)
{
  return sub_41BDF0(a2, a3, a4);
}

//----- (0041BCD0) --------------------------------------------------------
_DWORD *__cdecl std::fill<CSyncPacket::CElement *,CSyncPacket::CElement>(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  while ( a1 != a2 )
  {
    *a1 = *a3;
    a1[1] = a3[1];
    a1[2] = a3[2];
    a1[3] = a3[3];
    result = a1 + 4;
    a1 += 4;
  }
  return result;
}

//----- (0041BD10) --------------------------------------------------------
_DWORD *__cdecl sub_41BD10(int a1, int a2, int a3)
{
  unknown_libname_15(&a1, &a3);
  return std::_Copy_backward_opt<CSyncPacket::CElement *,CSyncPacket::CElement *>(
           (_DWORD *)a1,
           (_DWORD *)a2,
           (_DWORD *)a3);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (0041BD50) --------------------------------------------------------
int __cdecl sub_41BD50(int a1, int a2)
{
  unknown_libname_15(&a1, &a2);
  return std::_Destroy_range<CSyncPacket::CElement>(a1, a2);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (0041BD90) --------------------------------------------------------
void *__cdecl sub_41BD90(void *a1, int a2, int a3)
{
  unknown_libname_15(&a1, &a1);
  return std::_Uninit_fill_n<CSyncPacket::CElement *,unsigned int,CSyncPacket::CElement,std::allocator<CSyncPacket::CElement>>(
           a1,
           a2,
           a3);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (0041BDD0) --------------------------------------------------------
CMemory **__cdecl sub_41BDD0(int a1)
{
  return operator new(16 * a1);
}

//----- (0041BDF0) --------------------------------------------------------
void *__cdecl sub_41BDF0(int a1, int a2, void *a3)
{
  unknown_libname_15(&a1, &a3);
  return std::_Uninit_copy<CSyncPacket::CElement *,CSyncPacket::CElement *,std::allocator<CSyncPacket::CElement>>(
           a1,
           a2,
           a3);
}
// 404F10: using guessed type int __cdecl unknown_libname_15(_DWORD, _DWORD);

//----- (0041BE30) --------------------------------------------------------
_DWORD *__cdecl std::_Copy_backward_opt<CSyncPacket::CElement *,CSyncPacket::CElement *>(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  while ( a1 != a2 )
  {
    a2 -= 4;
    a3 -= 4;
    *a3 = *a2;
    a3[1] = a2[1];
    a3[2] = a2[2];
    a3[3] = a2[3];
  }
  return a3;
}

//----- (0041BE70) --------------------------------------------------------
int __cdecl std::_Destroy_range<CSyncPacket::CElement>(int a1, int a2)
{
  int result; // eax

  while ( a1 != a2 )
  {
    std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::string,std::less<int>,std::allocator<std::pair<int const,std::string>>,0>>::_Node *>::destroy(a1);
    result = a1 + 16;
    a1 += 16;
  }
  return result;
}

//----- (0041BEA0) --------------------------------------------------------
void *__cdecl std::_Uninit_fill_n<CSyncPacket::CElement *,unsigned int,CSyncPacket::CElement,std::allocator<CSyncPacket::CElement>>(void *a1, int a2, int a3)
{
  void *result; // eax
  _DWORD v4[8]; // [esp+0h] [ebp-20h] BYREF

  v4[4] = v4;
  result = a1;
  v4[3] = a1;
  v4[7] = 0;
  while ( a2 )
  {
    result = sub_41BF40(a1, a3);
    --a2;
    a1 = (char *)a1 + 16;
  }
  return result;
}

//----- (0041BF40) --------------------------------------------------------
_DWORD *__stdcall sub_41BF40(void *a1, int a2)
{
  return std::_Construct<CSyncPacket::CElement,CSyncPacket::CElement>(a1, a2);
}

//----- (0041BF60) --------------------------------------------------------
void *__cdecl std::_Uninit_copy<CSyncPacket::CElement *,CSyncPacket::CElement *,std::allocator<CSyncPacket::CElement>>(int a1, int a2, void *a3)
{
  _DWORD v4[8]; // [esp+0h] [ebp-20h] BYREF

  v4[4] = v4;
  v4[3] = a3;
  v4[7] = 0;
  while ( a1 != a2 )
  {
    sub_41BF40(a3, a1);
    a3 = (char *)a3 + 16;
    a1 += 16;
  }
  return a3;
}

//----- (0041C010) --------------------------------------------------------
_DWORD *__cdecl std::_Construct<CSyncPacket::CElement,CSyncPacket::CElement>(void *a1, int a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+4h] [ebp-4h]

  result = operator new(0x10u, a1);
  v3 = result;
  if ( result )
  {
    *result = *(_DWORD *)a2;
    result[1] = *(_DWORD *)(a2 + 4);
    result = *(_DWORD **)(a2 + 8);
    v3[2] = result;
    v3[3] = *(_DWORD *)(a2 + 12);
  }
  return result;
}

//----- (0041C060) --------------------------------------------------------
void __thiscall CSyncPacket::CSyncPacket(CSyncPacket *this)
{
  int v1; // eax
  int *v2; // eax
  int v3; // [esp-4h] [ebp-2Ch]
  char v5[4]; // [esp+4h] [ebp-24h] BYREF
  char v6[4]; // [esp+8h] [ebp-20h] BYREF
  char v7[16]; // [esp+Ch] [ebp-1Ch] BYREF
  int v8; // [esp+24h] [ebp-4h]

  CIOObject::CIOObject((CIOObject *)this);
  v8 = 0;
  *(_DWORD *)this = &off_42F888;
  sub_41C1C0((char *)this + 16);
  sub_41C210((char *)this + 32);
  sub_41C210((char *)this + 36);
  CIOCriticalSection::CIOCriticalSection((struct _RTL_CRITICAL_SECTION *)((char *)this + 40));
  LOBYTE(v8) = 2;
  *((_DWORD *)this + 18) = 0;
  Concurrency::details::UMSFreeVirtualProcessorRoot::~UMSFreeVirtualProcessorRoot((Concurrency::details::UMSFreeVirtualProcessorRoot *)v7);
  v3 = v1;
  v2 = (int *)std::vector<CSyncPacket::CElement>::begin((int *)this + 4, v6);
  *((_DWORD *)this + 9) = *(_DWORD *)std::vector<CSyncPacket::CElement>::insert((int *)this + 4, (int)v5, *v2, v3);
  *((_DWORD *)this + 8) = *((_DWORD *)this + 9);
}
// 41C0DC: variable 'v1' is possibly undefined
// 42F888: using guessed type int (__stdcall *off_42F888)(int);

//----- (0041C130) --------------------------------------------------------
void *__thiscall CSyncPacket::`vector deleting destructor'(void *this, char a2)
{
  CSyncPacket::~CSyncPacket((CSyncPacket *)this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (0041C160) --------------------------------------------------------
void __thiscall CSyncPacket::~CSyncPacket(CSyncPacket *this)
{
  CIOCriticalSection::~CIOCriticalSection((CIOCriticalSection *)((char *)this + 40));
  std::vector<CSyncPacket::CElement>::~vector<CSyncPacket::CElement>((char *)this + 16);
  CIOObject::~CIOObject(this);
}

//----- (0041C1C0) --------------------------------------------------------
_DWORD *__thiscall sub_41C1C0(void *this)
{
  void *v2; // [esp-4h] [ebp-Ch] BYREF
  _DWORD *v3; // [esp+0h] [ebp-8h]

  v3 = this;
  v2 = this;
  unknown_libname_9(&v2);
  sub_40D710(v3, (char)v2);
  sub_41C230(v3, 0);
  return v3;
}
// 403F50: using guessed type int __thiscall unknown_libname_9(_DWORD);

//----- (0041C1F0) --------------------------------------------------------
int *__thiscall std::vector<CSyncPacket::CElement>::~vector<CSyncPacket::CElement>(void *this)
{
  return std::vector<CSyncPacket::CElement>::_Tidy((int *)this);
}

//----- (0041C210) --------------------------------------------------------
void *__thiscall sub_41C210(void *this)
{
  unknown_libname_7(this);
  return this;
}
// 403080: using guessed type int __thiscall unknown_libname_7(_DWORD);

//----- (0041C230) --------------------------------------------------------
char __thiscall sub_41C230(_DWORD *this, unsigned int a2)
{
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  if ( !a2 )
    return 0;
  if ( std::vector<CSyncPacket::CElement>::max_size(this) < a2 )
    std::vector<CSyncPacket::CElement>::_Xlen();
  this[1] = std::allocator<CSyncPacket::CElement>::allocate(a2);
  this[2] = this[1];
  this[3] = this[1] + 16 * a2;
  return 1;
}

//----- (0041C2B0) --------------------------------------------------------
int *__thiscall std::vector<CSyncPacket::CElement>::_Tidy(int *this)
{
  int *result; // eax

  if ( this[1] )
  {
    std::vector<CSyncPacket::CElement>::_Destroy(this, this[1], this[2]);
    std::allocator<CSyncPacket::CElement>::deallocate(this[1], (this[3] - this[1]) >> 4);
  }
  this[1] = 0;
  this[2] = 0;
  result = this;
  this[3] = 0;
  return result;
}

//----- (0041C320) --------------------------------------------------------
char *__thiscall sub_41C320(char *this)
{
  unknown_libname_7(this + 4);
  return this;
}
// 403080: using guessed type int __thiscall unknown_libname_7(_DWORD);

//----- (0041C340) --------------------------------------------------------
LONG __thiscall CMemoryPool<CPacket>::CPool::~CPool(void *this)
{
  return CMemoryPool<CPacket>::FreeAll();
}

//----- (0041C350) --------------------------------------------------------
LONG CMemoryPool<CPacket>::FreeAll()
{
  void (__thiscall ***v1)(_DWORD, int); // [esp+Ch] [ebp-4h]

  CIOSpinLock::Enter(&dword_448DE4);
  while ( 1 )
  {
    v1 = (void (__thiscall ***)(_DWORD, int))dword_448DE0;
    if ( !dword_448DE0 )
      break;
    dword_448DE0 = *(_DWORD *)(dword_448DE0 + 16);
    if ( v1 )
      (**v1)(v1, 1);
  }
  return CIOSpinLock::Leave(&dword_448DE4);
}
// 448DE0: using guessed type int dword_448DE0;

//----- (0041C3C0) --------------------------------------------------------
BOOL __stdcall CStatus::Update()
{
  int v0; // eax

  Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(&CStatus::s_screen);
  Concurrency::details::WorkSearchContext::ResetLRCBias((Concurrency::details::WorkSearchContext *)&CStatus::s_screen);
  CScreen::Add(&CStatus::s_screen, 0, " Running Thread : %d", CIOSocket::s_nRunningThread);
  CScreen::Add(&CStatus::s_screen, 0, " Running DB Thread: %d", Addend);
  v0 = CServer::PendingWrite();
  CScreen::Add(&CStatus::s_screen, 0, " Pending Output : %d", v0);
  CScreen::Add(&CStatus::s_screen, 0, " Pending Packet : %d", *(&stru_4441A4 + 5));
  Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(&CStatus::s_screen);
  return InvalidateRect((HWND)*(&stru_4441A4 + 1), 0, 1);
}
// 40DE00: using guessed type int __thiscall Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(_DWORD);
// 40DE20: using guessed type int __thiscall Concurrency::details::_CancellationTokenCallback<_lambda_bd6029e2426d7ec37458070853043c08_>::_Exec(_DWORD);

//----- (0041C510) --------------------------------------------------------
__time32_t __stdcall InitRandom()
{
  unsigned int v0; // eax
  __time32_t result; // eax
  int i; // [esp+0h] [ebp-4h]
  int j; // [esp+0h] [ebp-4h]

  v0 = time(0);
  srand(v0);
  result = time(0);
  dword_448F30[0] = result;
  for ( i = 1; i < 32; ++i )
  {
    dword_448F30[i] = 1103515245 * dword_448F2C[i] + 12345;
    result = i + 1;
  }
  dword_448F28 = 2;
  for ( j = 0; j < 310; ++j )
    result = sub_41DE00();
  return result;
}
// 448F2C: using guessed type int dword_448F2C[];

//----- (0041C5A0) --------------------------------------------------------
int sub_41C5A0()
{
  char v0; // al

  v0 = InterlockedIncrement(&dword_448F28);
  dword_448F30[v0 & 0x1F] += dword_448F30[(v0 - 3) & 0x1F];
  return dword_448F30[v0 & 0x1F];
}

//----- (0041C610) --------------------------------------------------------
char *__stdcall WritePacketV(char *packet, char *va)
{
  int v2; // ecx
  int v4; // [esp+4h] [ebp-14h]
  size_t Size; // [esp+8h] [ebp-10h]
  void *Src; // [esp+Ch] [ebp-Ch]
  char *v7; // [esp+10h] [ebp-8h]
  char *v8; // [esp+14h] [ebp-4h]
  char *vaa; // [esp+24h] [ebp+Ch]
  char *vab; // [esp+24h] [ebp+Ch]

  vaa = va + 4;
  v8 = (char *)*((_DWORD *)vaa - 1);
  while ( 1 )
  {
    v4 = *v8++;
    switch ( v4 )
    {
      case 0:
        return packet;
      case 66:
      case 98:
        vaa += 4;
        *packet++ = *(vaa - 4);
        break;
      case 73:
        vaa += 8;
        *(_DWORD *)packet = *((_DWORD *)vaa - 2);
        *((_DWORD *)packet + 1) = *((_DWORD *)vaa - 1);
        packet += 8;
        break;
      case 77:
      case 109:
        vab = vaa + 4;
        Src = (void *)*((_DWORD *)vab - 1);
        vaa = vab + 4;
        Size = *((_DWORD *)vaa - 1);
        memcpy(packet, Src, Size);
        packet += Size;
        break;
      case 83:
      case 115:
        vaa += 4;
        v7 = (char *)*((_DWORD *)vaa - 1);
        if ( v7 )
        {
          do
          {
            *packet = *v7;
            v2 = *packet++;
            ++v7;
          }
          while ( v2 );
        }
        else
        {
          *packet++ = 0;
        }
        break;
      case 87:
      case 119:
        vaa += 4;
        *(_WORD *)packet = *((_WORD *)vaa - 2);
        packet += 2;
        break;
      case 100:
        vaa += 4;
        *(_DWORD *)packet = *((_DWORD *)vaa - 1);
        packet += 4;
        break;
      default:
        EBREAK();
        break;
    }
  }
}

//----- (0041C830) --------------------------------------------------------
char *WritePacket(char *packet, const char *formal, ...)
{
  return WritePacketV(packet, (char *)&formal);
}

//----- (0041C860) --------------------------------------------------------
char *__stdcall ReadPacketV(char *packet, char *va)
{
  _DWORD *v2; // edx
  int v4; // ecx
  int v6; // [esp+4h] [ebp-1Ch]
  int v7; // [esp+8h] [ebp-18h]
  char **v8; // [esp+Ch] [ebp-14h]
  size_t Size; // [esp+10h] [ebp-10h]
  void *v10; // [esp+14h] [ebp-Ch]
  char *v11; // [esp+18h] [ebp-8h]
  char *v12; // [esp+1Ch] [ebp-4h]
  char *vaa; // [esp+2Ch] [ebp+Ch]
  char *vab; // [esp+2Ch] [ebp+Ch]
  char *vac; // [esp+2Ch] [ebp+Ch]

  vaa = va + 4;
  v12 = (char *)*((_DWORD *)vaa - 1);
  while ( 1 )
  {
    v6 = *v12++;
    switch ( v6 )
    {
      case 0:
        return packet;
      case 66:
        vaa += 4;
        **((_DWORD **)vaa - 1) = *packet++;
        break;
      case 73:
        vaa += 4;
        v2 = (_DWORD *)*((_DWORD *)vaa - 1);
        *v2 = *(_DWORD *)packet;
        v2[1] = *((_DWORD *)packet + 1);
        packet += 8;
        break;
      case 77:
        vac = vaa + 4;
        v8 = (char **)*((_DWORD *)vac - 1);
        vaa = vac + 4;
        v7 = *((_DWORD *)vaa - 1);
        *v8 = packet;
        packet += v7;
        break;
      case 83:
        vaa += 4;
        v11 = (char *)*((_DWORD *)vaa - 1);
        do
        {
          *v11 = *packet;
          v4 = *v11++;
          ++packet;
        }
        while ( v4 );
        break;
      case 87:
        vaa += 4;
        **((_DWORD **)vaa - 1) = *(unsigned __int16 *)packet;
        packet += 2;
        break;
      case 98:
        vaa += 4;
        **((_BYTE **)vaa - 1) = *packet++;
        break;
      case 100:
        vaa += 4;
        **((_DWORD **)vaa - 1) = *(_DWORD *)packet;
        packet += 4;
        break;
      case 109:
        vab = vaa + 4;
        v10 = (void *)*((_DWORD *)vab - 1);
        vaa = vab + 4;
        Size = *((_DWORD *)vaa - 1);
        memcpy(v10, packet, Size);
        packet += Size;
        break;
      case 115:
        vaa += 4;
        **((_DWORD **)vaa - 1) = packet;
        while ( *packet++ )
          ;
        break;
      case 119:
        vaa += 4;
        **((_WORD **)vaa - 1) = *(_WORD *)packet;
        packet += 2;
        break;
      default:
        EBREAK();
        break;
    }
  }
}

//----- (0041CB40) --------------------------------------------------------
char *ReadPacket(char *packet, const char *formal, ...)
{
  return ReadPacketV(packet, (char *)&formal);
}

//----- (0041CB70) --------------------------------------------------------
char *__stdcall ScanPacketV(char *packet, char *end, char *va)
{
  _DWORD *v3; // edx
  int v5; // edx
  char *v7; // [esp+0h] [ebp-34h]
  char *v8; // [esp+4h] [ebp-30h]
  int v9; // [esp+Ch] [ebp-28h]
  size_t Size; // [esp+10h] [ebp-24h]
  void *v11; // [esp+14h] [ebp-20h]
  char *v12; // [esp+18h] [ebp-1Ch]
  int v13; // [esp+1Ch] [ebp-18h]
  int v14; // [esp+24h] [ebp-10h]
  char **v15; // [esp+28h] [ebp-Ch]
  char *v16; // [esp+30h] [ebp-4h]
  char *vaa; // [esp+44h] [ebp+10h]
  char *vab; // [esp+44h] [ebp+10h]
  char *vac; // [esp+44h] [ebp+10h]
  char *vad; // [esp+44h] [ebp+10h]

  vaa = va + 4;
  v16 = (char *)*((_DWORD *)vaa - 1);
  while ( 1 )
  {
LABEL_2:
    v9 = *v16++;
    switch ( v9 )
    {
      case 0:
        return packet;
      case 66:
        if ( packet < end )
        {
          vaa += 4;
          **((_DWORD **)vaa - 1) = *packet++;
        }
        continue;
      case 73:
        if ( packet + 8 <= end )
        {
          vaa += 4;
          v3 = (_DWORD *)*((_DWORD *)vaa - 1);
          *v3 = *(_DWORD *)packet;
          v3[1] = *((_DWORD *)packet + 1);
          packet += 8;
        }
        continue;
      case 83:
        vac = vaa + 4;
        v12 = (char *)*((_DWORD *)vac - 1);
        vaa = vac + 4;
        v13 = *((_DWORD *)vaa - 1);
        if ( v13 <= 0 )
          EBREAK();
        if ( packet == end )
        {
          *v12 = 0;
          continue;
        }
        if ( &packet[v13] >= end )
          v7 = end;
        else
          v7 = &packet[v13];
        while ( 1 )
        {
          *v12 = *packet;
          v5 = *v12++;
          ++packet;
          if ( !v5 )
            goto LABEL_2;
          if ( packet == v7 )
          {
            *(v12 - 1) = 0;
            goto LABEL_2;
          }
        }
      case 87:
        if ( packet + 2 <= end )
        {
          vaa += 4;
          **((_DWORD **)vaa - 1) = *(unsigned __int16 *)packet;
          packet += 2;
        }
        continue;
      case 98:
        if ( packet < end )
        {
          vaa += 4;
          **((_BYTE **)vaa - 1) = *packet++;
        }
        continue;
      case 100:
        if ( packet + 4 <= end )
        {
          vaa += 4;
          **((_DWORD **)vaa - 1) = *(_DWORD *)packet;
          packet += 4;
        }
        continue;
      case 109:
        vad = vaa + 4;
        v11 = (void *)*((_DWORD *)vad - 1);
        vaa = vad + 4;
        Size = *((_DWORD *)vaa - 1);
        if ( &packet[Size] <= end )
        {
          memcpy(v11, packet, Size);
          packet += Size;
        }
        continue;
      case 115:
        vab = vaa + 4;
        v15 = (char **)*((_DWORD *)vab - 1);
        vaa = vab + 4;
        v14 = *((_DWORD *)vaa - 1);
        *v15 = packet;
        if ( &packet[v14] >= end )
          v8 = end;
        else
          v8 = &packet[v14];
        break;
      case 119:
        if ( packet + 2 <= end )
        {
          vaa += 4;
          **((_WORD **)vaa - 1) = *(_WORD *)packet;
          packet += 2;
        }
        continue;
      default:
        EBREAK();
        continue;
    }
    while ( packet != v8 )
    {
      if ( !*packet++ )
        goto LABEL_2;
    }
    *v15 = (char *)&unk_437900;
  }
}

//----- (0041D0B0) --------------------------------------------------------
char *__stdcall PutString(char *packet, const char *str)
{
  int v2; // ecx

  do
  {
    *packet = *str;
    v2 = *packet++;
    ++str;
  }
  while ( v2 );
  return packet;
}

//----- (0041D0F0) --------------------------------------------------------
BOOL __cdecl CreatePath(const char *szPath)
{
  char *v2; // [esp+0h] [ebp-114h]
  CHAR PathName[268]; // [esp+4h] [ebp-110h] BYREF

  strcpy(PathName, szPath);
  v2 = strrchr(PathName, 92);
  if ( !v2 )
    return 0;
  *v2 = 0;
  if ( CreateDirectoryA(PathName, 0) )
    return 1;
  if ( GetLastError() != 3 )
    return 0;
  if ( CreatePath(PathName) )
    return CreateDirectoryA(PathName, 0);
  return 0;
}

//----- (0041D3D0) --------------------------------------------------------
BOOL __cdecl CheckResidentNum(char *szNum1, char *szNum2)
{
  int i; // [esp+0h] [ebp-54h]
  CHAR String; // [esp+4h] [ebp-50h] BYREF
  int v5; // [esp+5h] [ebp-4Fh]
  int v6; // [esp+9h] [ebp-4Bh]
  int v7; // [esp+Dh] [ebp-47h]
  char v8; // [esp+11h] [ebp-43h]
  int v9[12]; // [esp+20h] [ebp-34h]
  int v10; // [esp+50h] [ebp-4h]

  String = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  strcat(&String, szNum1);
  strcat(&String, szNum2);
  if ( !&String )
    return 0;
  if ( lstrlenA(&String) != 13 )
    return 0;
  v9[0] = 2;
  v9[1] = 3;
  v9[2] = 4;
  v9[3] = 5;
  v9[4] = 6;
  v9[5] = 7;
  v9[6] = 8;
  v9[7] = 9;
  v9[8] = 2;
  v9[9] = 3;
  v9[10] = 4;
  v9[11] = 5;
  v10 = 0;
  for ( i = 0; i < 12; ++i )
    v10 += v9[i] * (*(&String + i) - 48);
  return (11 * (v10 / 11) + 11 - v10) % 10 == SHIBYTE(v7) - 48;
}

//----- (0041D600) --------------------------------------------------------
void sub_41D600()
{
  int v0; // [esp+0h] [ebp-8h]
  int C; // [esp+4h] [ebp-4h]

  for ( C = 0; C < 256; ++C )
  {
    if ( IsDBCSLeadByte(C) )
      LOBYTE(v0) = -1;
    else
      v0 = tolower(C) & 0x7F;
    byte_448E28[C] = v0;
  }
}

//----- (0041DC30) --------------------------------------------------------
void __cdecl LogPacket(int nType, int nSize, char *buffer)
{
  int v3; // [esp+4h] [ebp-84h]
  char *Buffer; // [esp+8h] [ebp-80h]
  char *v5; // [esp+Ch] [ebp-7Ch]
  char v6[116]; // [esp+10h] [ebp-78h] BYREF

  ELOG("LogPacket nType(%d) nSize(%d)\n", nType, nSize);
  if ( nType == -1 )
  {
    if ( nSize > 1024 )
      nSize = 1024;
  }
  else if ( nSize > 64 )
  {
    nSize = 64;
  }
  v5 = buffer;
  while ( nSize > 0 )
  {
    Buffer = v6;
    v3 = 0;
    while ( nSize > 0 && v3 < 32 )
    {
      Buffer += sprintf(Buffer, "%02x", (unsigned __int8)*v5++);
      --nSize;
      if ( (++v3 & 3) == 0 )
        Buffer += sprintf(Buffer, " ");
    }
    ELOG("%p: %s\n", buffer, v6);
    buffer = v5;
  }
}

//----- (0041DD60) --------------------------------------------------------
void *__cdecl sub_41DD60(void *a1)
{
  CHAR *i; // [esp+4h] [ebp-114h]
  CHAR Filename[268]; // [esp+8h] [ebp-110h] BYREF

  GetModuleFileNameA(0, Filename, 0x104u);
  for ( i = Filename; *i; ++i )
  {
    if ( *i == 92 )
      *i = 47;
  }
  std::string::string(a1, Filename);
  return a1;
}

//----- (0041DE00) --------------------------------------------------------
unsigned int sub_41DE00()
{
  return (unsigned int)sub_41C5A0() >> 1;
}

//----- (0041DE10) --------------------------------------------------------
void *__thiscall sub_41DE10(void *this)
{
  sub_41D600();
  dword_448FB0 = GetACP();
  return this;
}
// 448FB0: using guessed type int dword_448FB0;

//----- (0041EED8) --------------------------------------------------------
_DWORD *__thiscall sub_41EED8(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[1] = 0;
  this[2] = 0;
  *this = &off_437A20;
  return result;
}
// 437A20: using guessed type int (__stdcall *off_437A20)(char);

//----- (0041EF33) --------------------------------------------------------
void __thiscall exception::~exception(exception *this)
{
  bool v1; // zf

  v1 = this->_m_doFree == 0;
  this->__vftable = (exception_vtbl *)&off_437A20;
  if ( !v1 )
    free((void *)this->_m_what);
}
// 437A20: using guessed type int (__stdcall *off_437A20)(char);

//----- (0041EF56) --------------------------------------------------------
void *__thiscall exception::`vector deleting destructor'(void *this, char a2)
{
  exception::~exception((exception *)this);
  if ( (a2 & 1) != 0 )
    operator delete((int)this);
  return this;
}

//----- (0041F848) --------------------------------------------------------
int __cdecl _set_security_error_handler(int a1)
{
  int result; // eax

  result = dword_448FDC;
  dword_448FDC = a1;
  return result;
}
// 448FDC: using guessed type int dword_448FDC;

//----- (0041FE1C) --------------------------------------------------------
unsigned int __cdecl fwrite_0(const void *buffer, unsigned int size, unsigned int count, _iobuf *stream)
{
  unsigned int v5; // [esp+Ch] [ebp-1Ch]

  _lock_file(stream);
  v5 = fwrite(buffer, size, count, stream);
  _unlock_file(stream);
  return v5;
}

//----- (0042023C) --------------------------------------------------------
int sub_42023C()
{
  return flsall(1);
}
// 420117: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (00422196) --------------------------------------------------------
void __stdcall __noreturn _inconsistency()
{
  if ( off_43D2A4 )
    off_43D2A4();
  __pInconsistency();
}
// 43D2A4: using guessed type int (*off_43D2A4)(void);

//----- (00426145) --------------------------------------------------------
void __cdecl _RTC_Initialize()
{
  void (__cdecl *const *i)(); // [esp+Ch] [ebp-1Ch]

  for ( i = __rtc_izz; i < __rtc_izz; ++i )
  {
    if ( *i )
      (*i)();
  }
}

//----- (00426189) --------------------------------------------------------
void __cdecl _RTC_Terminate()
{
  void (__cdecl *const *i)(); // [esp+Ch] [ebp-1Ch]

  for ( i = __rtc_tzz; i < __rtc_tzz; ++i )
  {
    if ( *i )
      (*i)();
  }
}

//----- (00429900) --------------------------------------------------------
int sub_429900()
{
  return std::string::~string(CDBConfig::s_strODBC);
}

//----- (00429910) --------------------------------------------------------
int sub_429910()
{
  return std::string::~string(CDBConfig::s_strMailServer);
}

//----- (00429920) --------------------------------------------------------
int sub_429920()
{
  return std::string::~string(CDBConfig::s_strMailFrom);
}

//----- (00429930) --------------------------------------------------------
int sub_429930()
{
  return std::string::~string(CDBConfig::s_strMailTo);
}

//----- (00429940) --------------------------------------------------------
int *sub_429940()
{
  return std::vector<IPAddrMask>::~vector<IPAddrMask>(CDBConfig::s_vSubNet);
}

//----- (00429950) --------------------------------------------------------
int sub_429950()
{
  return std::map<int,std::string>::~map<int,std::string>(dword_43DA08);
}

//----- (00429960) --------------------------------------------------------
void sub_429960()
{
  CIOException::CInit::~CInit(&unk_443E04);
}

//----- (00429970) --------------------------------------------------------
void sub_429970()
{
  CIOCriticalSection::~CIOCriticalSection(&stru_444038);
}

//----- (00429980) --------------------------------------------------------
int sub_429980()
{
  return sub_40ACE0(&unk_444058);
}

//----- (00429990) --------------------------------------------------------
int *sub_429990()
{
  return std::priority_queue<CIOSocket::CIOTimer>::~priority_queue<CIOSocket::CIOTimer,std::vector<CIOSocket::CIOTimer>,std::less<CIOSocket::CIOTimer>>(&unk_44405C);
}

//----- (004299A0) --------------------------------------------------------
_DWORD *sub_4299A0()
{
  return sub_41B660(&g_instance);
}

//----- (004299B0) --------------------------------------------------------
void sub_4299B0()
{
  sub_4101E0((char *)&CScreen::s_pScreen);
}

//----- (004299C0) --------------------------------------------------------
void sub_4299C0()
{
  CLog::CInit::~CInit(&unk_444154);
}

//----- (004299D0) --------------------------------------------------------
void sub_4299D0()
{
  sub_410860(&stru_4441A4 + 7);
}

//----- (004299E0) --------------------------------------------------------
void sub_4299E0()
{
  `eh vector destructor iterator'(&g_syncPacket, 0x4Cu, 256, (void (__thiscall *)(void *))CSyncPacket::~CSyncPacket);
}

//----- (00429A00) --------------------------------------------------------
LONG sub_429A00()
{
  return CMemoryPool<CPacket>::CPool::~CPool(&dword_448DE0);
}
// 448DE0: using guessed type int dword_448DE0;

//----- (00429A10) --------------------------------------------------------
void sub_429A10()
{
  sub_4101E0((char *)&CStatus::s_screen);
}

// nfuncs=920 queued=593 decompiled=593 lumina nreq=0 worse=0 better=0
// ALL OK, 593 function(s) have been successfully decompiled
